<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="2021/04/26/%E9%9D%A2%E7%BB%8F/"/>
      <url>2021/04/26/%E9%9D%A2%E7%BB%8F/</url>
      
        <content type="html"><![CDATA[<h1><span id="微信广州音视频若参与">微信–广州–音视频若参与</span></h1><h2><span id="1面">1面</span></h2><ul><li>Handler</li><li>算法手动实现LRU</li><li>四种引用类型   软引用 什么情况用到</li><li>Recyclerview深挖<ul><li>双层嵌套时的滑动冲突 </li><li>NestedScrollView了解过a面</li><li>Recyclerview动画 ，Default….</li><li>四级缓存  不同ViewType怎么存 </li></ul></li><li>事件分发   来  回</li><li>Hashmap遍历能增删吗？Concurret呢？HashTable呢</li></ul><h2><span id="2面">2面</span></h2><ul><li><p>面试官人很好，先做了自我介绍</p></li><li><p>联创</p></li><li><p>Recyclerview  数独算法，你是怎么实现的</p></li><li><p>算法有点慢，有没有比较特别的地方，唯一，i随即生成可拖动组件</p></li><li><p>个人博客</p></li><li><p>成绩</p></li><li><p>联创o仿抖音，思路，使用框架，预加载？肯定会卡</p></li><li><p>onBInViewi中new不会很卡</p></li><li><p>flutter有了解深层吗？</p></li><li><p>牛喝水、称重智力题</p></li><li><p>你大学最有n成就感的事</p></li><li><p>你觉得你与别人的优点是什么</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>音视频</title>
      <link href="2021/04/25/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
      <url>2021/04/25/%E9%9F%B3%E8%A7%86%E9%A2%91/</url>
      
        <content type="html"><![CDATA[<h1><span id="音视频">音视频</span></h1><h2><span id="基本概念">基本概念</span></h2><h3><span id="i-b-p-帧">I B P 帧</span></h3><p>I frame:自身可以通过视频解压算法解压成一张单独的完整的图片。</p><p>P frame：需要参考其前面的一个I frame 或者P frame来生成一张完整的图片。</p><p>B frame:则要参考其前一个I或者P帧及其后面的一个P帧来生成一张完整的图片</p><p>GOP  Group of picture  一组变化不大的视频帧<br>GOP的第一帧成为关键帧：<strong>IDR</strong></p><p>IDR都是I帧，可以防止一帧解码出错，导致后面所有帧解码出错的问题。当解码器在解码到IDR的时候，会将之前的参考帧清空，重新开始一个新的序列，这样，即便前面一帧解码出现重大错误，也不会蔓延到后面的数据中。</p><h3><span id="dts-pts">DTS 、PTS</span></h3><p>DTS： Decoding Time Stamp  标识读入内存中的ｂｉｔ流在什么时候开始送入解码器中进行解码</p><p>PTS :   Presentation Time Stamp  度量解码后的视频帧什么时候被显示出来</p><p><strong>在没有B帧的情况下，DTS和PTS的输出顺序是一样的，一旦存在B帧，PTS和DTS则会不同</strong></p><h3><span id="色彩空间-yuv">色彩空间 YUV</span></h3><p>亮度和色度分离 Y 亮度  UV 两种色度</p><p>Y：亮度，就是灰度值。除了表示亮度信号外，还含有较多的绿色通道量。<br>U：蓝色通道与亮度的差值。<br>V：红色通道与亮度的差值。</p><p><strong>优势</strong></p><p>人眼对亮度敏感，对色度不敏感，因此减少部分UV的数据量，人眼却无法感知出来，这样可以通过压缩UV的分辨率，在不影响观感的前提下，减小视频的体积。</p><h4><span id="存储方式">存储方式</span></h4><p>planar  packed</p><p><strong>planar 先存all Y 再U  V</strong></p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210427090315589.png" alt="image-20210427090315589"></p><p>packed 顺序存储</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210427090350317.png" alt="image-20210427090350317"></p><p>pakced存储方式已经非常少用，大部分视频都是采用planar存储方式。</p><p>细分planar</p><ol><li><p>YUV  4：4：4 一个Y对应一组UV</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210427090442152.png" alt="image-20210427090442152"></p></li><li><p>YUV 4：2：2 每两个Y对应一组UV</p><p><img src="/home/pplong/.config/Typora/typora-user-images/image-20210427090512408.png" alt="image-20210427090512408"></p></li><li><p>YUV 4：2：0 每四个Y公用一组UV</p><p><strong>最常用</strong></p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210427090547683.png" alt="image-20210427090547683"></p><p>420又分两种模式 三平面存储 </p><p>YYYYYYYYUUVV（如I420）或YYYYYYYYVVUU（如YV12）</p><p>420SP 两平面存储  YYYYYYYYUVUV（如NV12）或YYYYYYYYVUVU（如NV21）</p></li></ol><h3><span id="acc">ACC</span></h3><p>两种格式 ADIF 、ADTS</p><h4><span id="adif">ADIF</span></h4><p>Audio Data Interchange Format。 音频数据交换格式</p><p>可以确定的找到这个音频数据的开始，不需进行在音频数据流中间开始的解码，即它的<strong>解码必须在明确定义的开始处进行</strong>。这种格式常用在磁盘文件中。</p><h4><span id="adts">ADTS：</span></h4><p>Audio Data Transport Stream。 音频数据传输流。这种格式的特征是它是一个有同步字的比特流，解码可以在这个流中任何位置开始。它的特征类似于mp3数据流格式。</p><h3><span id="硬解码和软解码">硬解码和软解码</span></h3><h2><span id="图像基础">图像基础</span></h2><h3><span id="矢量图-位图">矢量图、位图</span></h3><ol><li>矢量图</li><li>位图</li></ol><h3><span id="颜色">颜色</span></h3><h4><span id="rgb">RGB</span></h4><ol><li><p>RGB16 </p><p>RGB565  </p><p>RGB555 最高位不用</p></li><li><p>RGB24 </p><p>内存中是 BGR </p></li><li><p>RGB32</p><p>BGR 后8个字节保留</p><p>ARGB32 ： BGRA A代表ALPHA透明度</p></li></ol><h4><span id="ycbcr">YCbCr</span></h4><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210427093047209.png" alt="image-20210427093047209"></p><p>文章有转载</p><p><a href="https://zhuanlan.zhihu.com/p/347989727">https://zhuanlan.zhihu.com/p/347989727</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/04/15/JetPack%E5%AD%A6%E4%B9%A0/"/>
      <url>2021/04/15/JetPack%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1><span id="jetpack学习">Jetpack学习</span></h1><hr><p>四大块：Architecture、UI、Foundationy 以及 Behavior</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/04/15/hello-world/"/>
      <url>2021/04/15/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2><span id="quick-start">Quick Start</span></h2><h3><span id="create-a-new-post">Create a new post</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3><span id="run-server">Run server</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3><span id="generate-static-files">Generate static files</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3><span id="deploy-to-remote-sites">Deploy to remote sites</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin学习</title>
      <link href="2021/04/12/Kotlin%E5%AD%A6%E4%B9%A0/"/>
      <url>2021/04/12/Kotlin%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1><span id="kotlin学习">Kotlin学习</span></h1><span id="more"></span><h2><span id="基础">基础</span></h2><p>尽量使用val进行编写</p><h3><span id="类">类</span></h3><ul><li>构造方法更加简洁</li><li>主构造器的参数不能在子方法中调用  init方法可以有多个 顺序从上到下</li></ul><p><strong>声明</strong></p><ul><li>by lazy : 变量必须引用不可变 无法通过var实现   线程安全</li><li>lateinit ：用于var遍历延迟声明，不能用于基本数据类型….</li><li>by Delegates.notNull<t> 让基本数据类型var也具有延迟初始化效果</t></li></ul><h3><span id="接口">接口</span></h3><ul><li>支持抽象属性，属性不能直接复制 要通过get来复制</li></ul><h2><span id="异同">异同</span></h2><h2><span id="问题">问题</span></h2><p>为啥Int ==   === 都是true？</p><p>如果比较的是基本类型的话，则===的判断效果也是==</p>]]></content>
      
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RecylerView滑动嵌套的问题</title>
      <link href="2021/04/10/RecylerView%E6%BB%91%E5%8A%A8%E5%B5%8C%E5%A5%97%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>2021/04/10/RecylerView%E6%BB%91%E5%8A%A8%E5%B5%8C%E5%A5%97%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1><span id="recycleview滑动嵌套问题">RecycleView滑动嵌套问题</span></h1><h2><span id="问题引入">问题引入</span></h2><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210410162131807.png" alt="image-20210410162131807"></p><p>父rec和子recy都是竖直或者横向的时候，这个时候滑动，只有父布局会响应</p><p>原因：父rec消耗了此次点击事件</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android个人开发时总结</title>
      <link href="2021/03/06/Android%E4%B8%AA%E4%BA%BA%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
      <url>2021/03/06/Android%E4%B8%AA%E4%BA%BA%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1><span id="android个人项目开发总结">Android个人项目开发总结</span></h1><hr><h2><span id="dddraft-手账">dddraft 手账</span></h2><h3><span id="布局处理">布局处理</span></h3><p>问题 ： RecycleView滑动后返回  内容消失   —-RecycleView的复用机制</p><p>解决 ：尝试取消RecycleView的复用   未果</p><span id="more"></span><p>​    后使用Scrollview 包裹 RelativeLayout，能够解决滑动后的View消失</p><p>​    但是又涉及到内部12个月份的布局顺序排列问题，这里最初使用的是RelativeLayout的顺序排序，但是顺序排序会造成之后动态添加的元素，也会按照这个顺序排序，即添加在顶部或者底部。</p><p>​    这里我之后的解决方案并不是很好，我采用了初始化时动态生成12个View，并且固定的设置每个view的topmargin</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环体内</span></span><br><span class="line">params.topMargin = (i - <span class="number">1</span>) * <span class="number">1029</span>;</span><br><span class="line">scrollLinearLayout.addView(view, params);</span><br></pre></td></tr></table></figure><h3><span id="自定义的drugimageview">自定义的DrugImageView</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解决滑动时带来的 ACTION_CANCEL 的问题（事件分发）</span></span><br><span class="line"><span class="comment">//阻止父层的View截获touch事件</span></span><br><span class="line">getParent().requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>解决拖动问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">    isUpRepeat = <span class="keyword">false</span>;</span><br><span class="line">    lastX = (<span class="keyword">int</span>) event.getX();</span><br><span class="line">    lastY = (<span class="keyword">int</span>) event.getY();</span><br><span class="line">    startTime = System.currentTimeMillis();</span><br><span class="line">    endTime = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 还原初始点击时 相对图片的xy 坐标</span></span><br><span class="line">    listener.onDragDown();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">    <span class="keyword">if</span> (fingerCount == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (endTime - startTime &gt; ClickTimeDuration) &#123;</span><br><span class="line">            offsetX = (<span class="keyword">int</span>) (event.getX() - lastX);</span><br><span class="line">            offsetY = (<span class="keyword">int</span>) (event.getY() - lastY);</span><br><span class="line">            rootView.layout(getLeft() + offsetX, getTop() + offsetY, getRight() + offsetX, getBottom() + offsetY);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>layout 会使其getLeft 等都发生改变</p><p>核心思想：</p><p>通过lastX记录点击时手指相对于图片内部的位置，然后通过offsetX进行滑动时相对起点的判断，判断永远都是在内部的，但是layout是在外部进行的</p><h3><span id="scalegesturedetector问题">ScaleGestureDetector问题</span></h3><p>按照比例进行缩放，但是最初检测不到缩小的手势</p><p>只有先放大后才能够检测到缩小的指令，这里不清楚</p><h3><span id="writeableedittext">WriteableEditText</span></h3><p>可动态设置的字体  –大小  –和颜色的TextView ，并且确保同一个Text中可以有多个不同格式的Text，并且可拖动</p><ul><li>单击和长按的判断 。实现单击显示/隐藏button，长按实现拖动</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">    firstClickTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">if</span> (firstClickTime - secondClickTime &gt; timeDuration) &#123;</span><br><span class="line">        Toast.makeText(context, <span class="string">&quot;&gt;200&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">    <span class="keyword">if</span> (isFirstClicked) &#123;</span><br><span class="line">        initX = (<span class="keyword">int</span>) event.getRawX();</span><br><span class="line">        initY = (<span class="keyword">int</span>) event.getRawY();</span><br><span class="line">        isFirstClicked = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    listener.onMove(rootView, (<span class="keyword">int</span>) event.getRawX(), (<span class="keyword">int</span>) event.getRawY(), initX, initY);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">    Log.d(<span class="string">&quot;Writebale&quot;</span>, <span class="string">&quot;down&quot;</span>);</span><br><span class="line"></span><br><span class="line">    secondClickTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">if</span> (secondClickTime - firstClickTime &lt; timeDuration) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dragButton.getAlpha() != <span class="number">0</span>) &#123;</span><br><span class="line">            dragButton.setAlpha(<span class="number">0</span>);</span><br><span class="line">            borderView.setAlpha(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dragButton.setAlpha(<span class="number">1</span>);</span><br><span class="line">            borderView.setAlpha(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><ul><li><p>另一种动态设置位置的方式</p><p>回调中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMove</span><span class="params">(View v, <span class="keyword">int</span> rawx, <span class="keyword">int</span> rawy, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//x： first rawx</span></span><br><span class="line">    Rect scrollBounds = <span class="keyword">new</span> Rect();</span><br><span class="line">    scrollView.getDrawingRect(scrollBounds);</span><br><span class="line">    <span class="comment">//获取整个scrollView的大小</span></span><br><span class="line">    v.setX(rawx - x);</span><br><span class="line">    v.setY(rawy - y + scrollBounds.top);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>文字方面，多个EditText放在一起后 滑动消失再返回后发现输入的字体消失，这里要通过TextWatcher实现保存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">editText.getEditText().addTextChangedListener(<span class="keyword">new</span> TextWatcher() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeTextChanged</span><span class="params">(CharSequence s, <span class="keyword">int</span> start, <span class="keyword">int</span> count, <span class="keyword">int</span> after)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequiresApi(api = Build.VERSION_CODES.P)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTextChanged</span><span class="params">(CharSequence s, <span class="keyword">int</span> start, <span class="keyword">int</span> before, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        TextStyleHelper.setEditText(s, currentTextStyle, editText, start, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterTextChanged</span><span class="params">(Editable s)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//设置指针位置 editText.getEditText().setSelection(s.length());</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3><span id="scannablestring">ScannableString</span></h3><p>实现TextView的多格式字体显示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">editText.getEditText().removeTextChangedListener(watcher);</span><br><span class="line">editText.getEditText().setText(ss);</span><br><span class="line">editText.getEditText().addTextChangedListener(watcher);</span><br></pre></td></tr></table></figure><p>核心： 先在内部除去watcher 添加文字后再恢复watcher</p><p>原因： 死循环</p><p>当一个TextView中含有TextWatcher时 在调用setText时，会先去搜索是否有TextWatcher  又我这里的setText方法是在TextWatcher中调用的，所以就形成了一个死循环 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendOnTextChanged</span><span class="params">(CharSequence text, <span class="keyword">int</span> start, <span class="keyword">int</span> before, <span class="keyword">int</span> after)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//去遍历所有的TextWatcher</span></span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;TextWatcher&gt; list = mListeners;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> count = list.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="comment">//调用onTextChanged的方法</span></span><br><span class="line">            list.get(i).onTextChanged(text, start, before, after);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mEditor != <span class="keyword">null</span>) mEditor.sendOnTextChanged(start, before, after);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="sudoko-数独游戏">Sudoko 数独游戏</span></h2>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>格式</title>
      <link href="2021/02/23/%E6%A0%BC%E5%BC%8F/"/>
      <url>2021/02/23/%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p><span style="color:red;font-size:24px">nihao</span></p><p><span style="color:red;font-size:24px">问题</span></p><p><span style="color:orange;font-size:24px">重点</span></p><p><span style="color: #DA70D6;font-size:24px">未解决问题</span></p><p><span style="color: #DAA520;font-size:24px">流程</span></p><p><span style="color:#8A2BE2;font-size:24px">看情况</span></p><p><span style="color: #00BFFF;font-size:24px">个人理解</span></p><p><span style="color:#3CB371;font-size:24px">醒悟</span></p><p><span style="color:#FA8072;font-size:24px">标题</span></p><p><span style="color:#FA8072;font-size:24px">是</span></p>]]></content>
      
      
      <categories>
          
          <category> 模块 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网</title>
      <link href="2021/01/22/%E8%AE%A1%E7%BD%91/"/>
      <url>2021/01/22/%E8%AE%A1%E7%BD%91/</url>
      
        <content type="html"><![CDATA[<h1><span id="计网">计网</span></h1><!-- toc --><ul><li><a href="#%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE">五层协议</a><ul><li><a href="#%E7%89%A9%E7%90%86%E5%B1%82">物理层</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82">数据链路层</a><ul><li><a href="#%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7">封装成帧</a></li><li><a href="#%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B">差错检测</a></li><li><a href="#%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93">可靠传输</a></li><li><a href="#%E5%9C%B0%E5%9D%80">地址</a><ul><li><a href="#mac%E5%9C%B0%E5%9D%80">Mac地址</a></li><li><a href="#ip%E5%9C%B0%E5%9D%80">IP地址</a></li><li><a href="#arp">ARP</a></li></ul></li></ul></li><li><a href="#%E7%BD%91%E7%BB%9C%E5%B1%82">网络层</a><ul><li><a href="#ipv4">IPV4</a><ul><li><a href="#%E5%88%86%E7%B1%BB%E7%BC%96%E5%88%B6">分类编制</a></li><li><a href="#%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91">划分子网</a></li><li><a href="#%E6%97%A0%E5%88%86%E7%B1%BB%E7%BC%96%E5%9D%80">无分类编址</a></li></ul></li></ul></li></ul></li><li><a href="#http">Http</a></li><li><a href="#https">Https</a><ul><li><a href="#http20-%E4%B8%8E-http-1x%E7%9A%84%E5%8C%BA%E5%88%AB">Http2.0 与 Http 1.x的区别</a><ul><li><a href="#1-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8">1. 多路复用</a></li><li><a href="#2-%E9%A6%96%E9%83%A8%E5%8E%8B%E7%BC%A9">2. 首部压缩</a></li><li><a href="#3-http2%E6%94%AF%E6%8C%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81"><strong>3. HTTP2支持服务器推送</strong></a></li></ul></li></ul></li><li><a href="#tcp%E5%8D%8F%E8%AE%AE">TCP协议</a><ul><li><a href="#%E6%8A%A5%E6%96%87%E4%BF%A1%E6%81%AF">报文信息</a></li><li><a href="#%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93-1">可靠传输</a></li><li><a href="#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%97%B6%E9%97%B4%E9%80%89%E6%8B%A9">超时重传时间选择</a></li><li><a href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">流量控制</a></li></ul></li><li><a href="#udp">UDP</a></li><li><a href="#dns">DNS</a></li><li><a href="#%E7%BD%91%E7%BB%9C%E6%8B%A5%E5%A1%9E">网络拥塞</a><ul><li><a href="#tcp-tahoe">TCP Tahoe</a></li><li><a href="#tcp-reno-%E6%94%B9%E8%BF%9B%E5%90%8E">TCP Reno 改进后</a></li></ul></li><li><a href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%9A%84%E5%8C%BA%E5%88%AB">对称加密和非对称加密的区别</a><ul><li><a href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86">对称加密</a></li><li><a href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86">非对称加密</a></li></ul></li><li><a href="#md5">MD5</a><ul><li><a href="#%E7%94%A8%E9%80%94">用途</a></li><li><a href="#%E8%BF%87%E7%A8%8B">过程</a></li></ul></li><li><a href="#%E5%8F%A6%E5%A4%96%E7%9A%84%E9%97%AE%E9%A2%98">另外的问题</a><ul><li><a href="#%E5%86%85%E7%BD%91%E5%92%8C%E5%A4%96%E7%BD%91%E7%9A%84%E5%8C%BA%E5%88%AB">内网和外网的区别</a></li><li><a href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%A0%81">常见的网络请求码</a></li></ul></li></ul><!-- tocstop --><h2><span id="五层协议">五层协议</span></h2><h3><span id="物理层">物理层</span></h3><p>解决在各种传输媒体上传输比特0 和 1 的问题，给数据链路层提供透明传输比特流的服务</p><p>透明： 数据链路层不需要知道物理层使用什么方法传输的</p><span id="more"></span><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210331214511474.png" alt="image-20210331214511474"></p><h3><span id="数据链路层">数据链路层</span></h3><p>三个重要问题： 封装成帧、差错检测、可靠传输 </p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210331214815983.png" alt="image-20210331214815983"></p><p> 链路：一个节点到相邻节点的一段物理线路，中间没有任何其他的交换节点</p><p>数据链路：实现通信协议的硬件和软件加到连路上，以帧单位封装处理</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210331215104288.png" alt="image-20210331215104288"></p><p>帧传输过程中出现误码（1变成0） </p><p>发送方发送数据前将发送的数据和算法计算出<strong>检错码</strong>，放在帧尾</p><p>接受方再进行验证，如果错误，则不会接受该帧，就丢弃了</p><h4><span id="封装成帧">封装成帧</span></h4><p>给上层交付的协议数据单元添加帧头和帧尾使之成为帧</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210331215956065.png" alt="image-20210331215956065"></p><p>帧头帧尾：进行帧定界  — </p><ol><li>帧定界标志（不一定有）</li><li>物理层添加前导码，帧间隔时间 96bit</li></ol><p>透明传输：数据链路层对上层交付的传输数据没有任何限制，就好像数据链路层不存在一样</p><ul><li>面向字节的物理链路使用字节填充的方法实现透明传输 – ESC 27</li><li>面向比特的物理链路使用比特填充的方法实现透明传输</li></ul><p>如何解决不同方式的误判（与界定符相同）</p><h4><span id="差错检测">差错检测</span></h4><p><strong>比特差错</strong>：比特传输时1 0 可能会改变</p><p>误码率：错误的比特占比  </p><p>判断：差错检测码</p><ol><li><p>奇偶校验： 在数据后添加1 是的整个数据 的1 的个数为奇数(奇校验)或者偶数(偶校验)</p><p>缺点，只能检测奇数位的错误</p></li><li><p>循环冗余校验：双方约定好一个生成多项式（多项式的各项系数生成比特串），发送方基于待发送的数据和生成多项式计算出差错检测码，也就是冗余码，添加到带传输的后面一起传输（类似Digest的数字签名），接收方通过此方法判断</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210331221431870.png" alt="image-20210331221431870"></p></li></ol><h4><span id="可靠传输">可靠传输</span></h4><p>向上层的服务类型：</p><p>不可靠传输服务：丢弃有误码的帧，然后什么都不做</p><p>可靠传输服务：发送端发什么就接受什</p><p>一般交由上层处理</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210401102629080.png" alt="image-20210401102629080"></p><p><strong>点对点协议</strong></p><p>PPP Point to Point Protocol</p><p>为在点对点链路传输各种协议数据报提供了标准方法</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210401104045712.png" alt="image-20210401104045712"></p><p>从ISP 互联网服务提供商  中国移动….. 获得提供的合法ip地址   </p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210401103306939.png" alt="image-20210401103306939"></p><p>存在误判 ，解决方法  </p><ol><li><p>帧定界 </p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210401103442613.png" alt="image-20210401103442613"></p></li><li><p>前导码</p></li></ol><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210401103535405.png" alt="image-20210401103535405"></p><h4><span id="地址">地址</span></h4><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210401104430428.png" alt="image-20210401104430428"></p><h5><span id="mac地址">Mac地址</span></h5><p>点对点信道的数据链路层不需要地址</p><p>使用广播信道的数据链路层需要使用地址来区分</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210401104748601.png" alt="image-20210401104748601"></p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210401104856860.png" alt="image-20210401104856860"></p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210401105646563.png"></p><p>单播  发送Mac地址不匹配，丢弃</p><p>广播帧 目的字段 FFFFFFFFFFFF  接受</p><p>多播  多播地址  多播组列表</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210401105523344.png" alt="image-20210401105523344"></p><h5><span id="ip地址">IP地址</span></h5><p>网际层</p><p>因特网上主机和路由器使用的地址  </p><p>网络编号 和 主机编号</p><p>同一网络的网络编号是相同的 </p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210401110022989.png" alt="image-20210401110022989"></p><p>网络传播需要IP地址和Mac地址</p><p>网络传输中主机有运输层和应用层… 而路由器的最高层就是网络层</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210401222930927.png" alt="image-20210401222930927"></p><p>封装时的地址</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210401223316294.png" alt="image-20210401223316294"></p><h5><span id="arp">ARP</span></h5><p> IP地址转MAC地址</p><p>地址解析协议</p><p>每个主机都有 ARP高速缓存表 —- 电话簿</p><p>ARP请求报文发送在MAC帧中 只能在一个网络  一个链路中使用</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210401223810852.png" alt="image-20210401223810852"></p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210401224012968.png" alt="image-20210401224012968"></p><h3><span id="网络层">网络层</span></h3><p>主要任务：实现网络互连，实现数据包在网络间的传输</p><p>解决问题：网络层寻址问题  提供怎样的服务   路由选择问题（不同路径选择）</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210401224627313.png" alt="image-20210401224627313"></p><p>**网络层提供的两种服务    **</p><p>面向连接的虚电路服务：</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210401224838914.png" alt="image-20210401224838914"></p><ul><li><p>无连接的数据报服务</p><p>TCP/IP体系结构的因特网网际层采用</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210401225008037.png" alt="image-20210401225008037"></p></li></ul><h4><span id="ipv4">IPV4</span></h4><p>因特网每一台主机/路由器 的每一个接口分配在全世界唯一的32比特标识符</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210401225354928.png" alt="image-20210401225354928"></p><h5><span id="分类编制">分类编制</span></h5><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210401225751543.png" alt="image-20210401225751543"></p><p>A类地址</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210401230004953.png" alt="image-20210401230004953"></p><p>B类地址</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210401230208878.png" alt="image-20210401230208878"></p><p>C类地址</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210401230335803.png" alt="image-20210401230335803"></p><p>特殊情况</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210401230644359.png" alt="image-20210401230644359"></p><h5><span id="划分子网">划分子网</span></h5><p>需要划分子网，利用原有网络中大量剩余的IP地址，分配第三部分…</p><p>因此有了：<strong>子网掩码</strong></p><p>32比特的子网掩码可以表明分类IP地址的主机号部分被借用了几个比特作为子网号</p><p>注意不同的网络类别有不同位数的网络号和主机号</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210402084027580.png" alt="image-20210402084027580"></p><p>举个例子</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210402084230681.png" alt="image-20210402084230681"></p><p>如何被划分成两个子网的</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210402084626964.png" alt="image-20210402084626964"></p><p>默认子网掩码</p><p>A类 8位网络号 ： 255.0.0.0</p><p>B类 16位网络号 255.255.0.0</p><p>C类 24位网络号 255.255.255.0</p><p>注意，主机号为0代表有一个 为1000000 代表有两个 （注意方向和顺序）</p><h5><span id="无分类编址">无分类编址</span></h5><p>数量巨大的C雷王因为地址空间太小并没有充分使用，而IP地址仍在加速消耗，IPV4地址空间紧张</p><p><strong>CIDR Classless Inter Domain Routing</strong></p><p>消除了传统的A\B\C类地址和划分子网的概念，更有效的分配Ipv4地址空间，并且可以在新的Ipv6使用之前允许因特网的规模继续增长</p><p>斜线记法</p><p>128.14.35.7 / 20  代表网络前缀占用的比特数量为20 主机编号就为12</p><p> 路由聚合   （构造超网）</p><p>方法： 找共同前缀 </p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210402090132427.png" alt="image-20210402090132427"></p><p><strong>IPV4的地址应用规划</strong></p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210402091203126.png" alt="image-20210402091203126"></p><p> 定长： 先确定主机数</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210402091834330.png" alt="image-20210402091834330"></p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210402092118490.png" alt="image-20210402092118490"></p><p>变长的子网掩码相当于串行动态分配</p><h2><span id="http">Http</span></h2><p>HyperTextTransferProtocol  超文本传输协议  用于从WWW服务器传输超文本到本地浏览器的传输协议</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210310221622240.png" alt="image-20210310221622240"></p><p>所有消息用明文发送  通过公共的互联网</p><h2><span id="https">Https</span></h2><p>两大法宝 </p><p>SSL  Secure Sockets Layer 安全套接层 使用公匙加密  SSL证书 </p><p>TLS  Transport Layer Security 传输层安全   最新行业标准加密协议  继承SSL </p><p>非明文</p><h3><span id="http20-与-http-1x的区别">Http2.0 与 Http 1.x的区别</span></h3><h4><span id="1-多路复用">1. 多路复用</span></h4><p>​    多路复用技术：单连接多资源的方式，减少服务端的链接压力,内存占用更    少,连接吞吐量更大；由于减少TCP 慢启动时间，提高传输的速度</p><p>​    允许单一HTTP 2 连接同时发起多重的请求 - 响应消息</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210310221742708.png" alt="image-20210310221742708"></p><p>二进制分帧</p><p>在二进制分帧层中， HTTP/2 会将所有传输的信息分割为帧（frame）,并对它们采用二进制格式的编码 ，其中 首部信息会被封装到 HEADER frame，而相应的 Request Body 则封装到 DATA frame 里面。</p><p>HTTP 性能优化的<strong>关键并不在于高带宽，而是低延迟</strong>。TCP 连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。</p><h4><span id="2-首部压缩">2. 首部压缩</span></h4><p>​     HTTP/1 中，HTTP 请求和响应都是由「状态行、请求 / 响应头部、消息主体」三部分组成。一般而言，消息主体都会经过 gzip 压缩，或者本身传输的就是压缩过后的二进制文件（例如图片、音频），但状态行和头部却没有经过任何压缩，直接以纯文本传输。</p><p>随着 Web 功能越来越复杂，每个页面产生的请求数也越来越多，导致消耗在头部的流量越来越多，尤其是每次都要传输 UserAgent、Cookie 这类不会频繁变动的内容，完全是一种浪费。</p><p>我们再用通俗的语言解释下，压缩的原理。头部压缩需要在支持 HTTP/2 的浏览器和服务端之间：</p><ul><li>维护一份相同的静态字典（Static Table），包含常见的头部名称，以及特别常见的头部名称与值的组合；</li><li>维护一份相同的动态字典（Dynamic Table），可以动态的添加内容；</li><li>支持基于静态哈夫曼码表的哈夫曼编码（Huffman Coding）；</li></ul><p>静态字典的作用有两个：</p><p>1）对于完全匹配的头部键值对，例如 “:method :GET”，可以直接使用一个字符表示；</p><p>2）对于头部名称可以匹配的键值对，例如 “cookie :xxxxxxx”，可以将名称使用一个字符表示。</p><p>HTTP/2 中的静态字典如下（以下只截取了部分，完整表格在这里）：</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210310224715407.png" alt="image-20210310224715407"></p><p>浏览器和服务端都可以向动态字典中添加键值对，之后这个键值对就可以使用一个字符表示了。需要注意的是，动态字典上下文有关，需要为每个 HTTP/2 连接维护不同的字典。在传输过程中使用，使用字符代替键值对大大减少传输的数据量。</p><h4><span id="3-http2支持服务器推送"><strong>3. HTTP2支持服务器推送</strong></span></h4><p>服务端推送是一种在客户端请求之前发送数据的机制。当代网页使用了许多资源:HTML、样式表、脚本、图片等等。在HTTP/1.x中这些资源每一个都必须明确地请求。这可能是一个很慢的过程。浏览器从获取HTML开始，然后在它解析和评估页面的时候，增量地获取更多的资源。因为服务器必须等待浏览器做每一个请求，网络经常是空闲的和未充分使用的。</p><p>为了改善延迟，HTTP/2引入了server push，它允许服务端推送资源给浏览器，在浏览器明确地请求之前。一个服务器经常知道一个页面需要很多附加资源，在它响应浏览器第一个请求的时候，可以开始推送这些资源。这允许服务端去完全充分地利用一个可能空闲的网络，改善页面加载时间。</p><h2><span id="tcp协议">TCP协议</span></h2><p>Transmission Control Protocol  传输控制协议</p><p>属于哪一层   运输层   网际层都使用IP协议</p><p>面向连接  通信前要建立TCP逻辑连接 — 三次握手、面向字节流、首部开销大 min20字节 max60字节</p><p>可靠传输：重传机制（下文有讲）、流量控制、拥塞控制</p><h3><span id="报文信息">报文信息</span></h3><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210331203958930.png" alt="image-20210331203958930"></p><h3><span id="可靠传输">可靠传输</span></h3><p>以字节为单位的滑动窗口  — 接受窗口和发送窗口</p><p>已收到ack确定的报文可以delete  </p><p>未按序到达的数据包一般临时存放在接受窗口中，等到缺少的字节收到后再按序交付上层应用</p><p><strong>累计确认！</strong></p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210331211800303.png" alt="image-20210331211800303"></p><h3><span id="超时重传时间选择">超时重传时间选择</span></h3><p>RTT： 报文段往返时间（每次可能不同）</p><p>RTO: 超时重传时间</p><p>如何合理设置RTO时间  </p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210331212813944.png" alt="image-20210331212813944"></p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210331212910233.png" alt="image-20210331212910233"></p><p><strong>报文段丢失重发的情况  误判</strong></p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210331213047103.png" alt="image-20210331213047103"></p><p><strong>传报文段超时情况</strong></p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210331213204617.png" alt="image-20210331213204617"></p><p>针对以上两种情况的新算法：</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210331213442132.png" alt="image-20210331213442132"></p><h3><span id="流量控制">流量控制</span></h3><p>发送方的数据发的太快以至于接收方接受不下，会造成数据的丢失 （2MSL ）</p><p>基于滑动窗口机制</p><p>接受窗口 rwnd</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210331210025354.png" alt="image-20210331210025354"></p><p>解决死锁： 持续计时器  </p><p>接收方收到0窗口通知时，开启计时器，超时则发送零窗口的探测报文(携带1字节数据)，如果对方发来的报文创口也是零，则重置计时器继续等待，如果不是零则打破僵局</p><p><strong>既然服务器的窗口为0，那为什么还能接受发送方发来的探测报文段？</strong></p><p>规定接受 0窗口探测报文段、确认报文段、携带紧急数据的报文段</p><p><strong>三次握手</strong></p><p><strong>四次挥手</strong></p><p><strong>为什么一定要三握四挥？</strong></p><p><strong>为什么会有2MSL？他有什么作用</strong></p><h2><span id="udp">UDP</span></h2><p>User Datagram Protocol</p><p>无连接，可随时发送数据、网络开销小 速度快 、支持一对一 一对多(广播、多播(指定)) 多对一、报文直接打包、首部开销小 8 字节</p><p>面向报文，直接加个报文头就发出去了</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210331204004782.png" alt="image-20210331204004782"></p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210331203219149.png" alt="image-20210331203219149"></p><h2><span id="dns">DNS</span></h2><p>Domain Name ( to ip )System 解析域名   电话簿</p><p>过程：</p><ol><li><p>浏览器缓存</p></li><li><p>系统缓存</p></li><li><p>ISP、 因特网服务商</p></li><li><p>根域名服务器  全世界13组 ，可能这个根域名服务器不知道他的ip，但是可以知道谁可以</p><p>.com 顶级域名服务器  TLD(.com   .net  …)</p></li><li><p>TLD也不知道时，给权限名称服务器  啥都知道</p></li></ol><p>回传时，进行保存</p><h2><span id="网络拥塞">网络拥塞</span></h2><p>拥塞： 网络中某一资源的需求 超过了该资源所能提供的可用部分，网络性能将会变差，出现拥塞而不控制，则网络的吞吐量就会随着负荷的增大而下降（堵车）</p><p> <img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210331193813129.png" alt="image-20210331193813129"></p><p>cnwd、ssthresh、rtt、swnd、数据包文段、重传计时器</p><h3><span id="tcp-tahoe">TCP Tahoe</span></h3><p>慢开始 cnwd &gt;&gt; 1</p><p>拥塞避免   cnwd++</p><h3><span id="tcp-reno-改进后">TCP Reno 改进后</span></h3><p>原因： 有时 个别报文段在网络中丢失，但实际上网络并未发生拥塞，这将导致发送方超时重传，并误认为网络发生拥塞。发送方错误地启动慢开始算法，降低了传输效率</p><p>快重传  让发送方尽快知道发生了个别报文段的丢失 ，而不是让超市重传计时器超时后再重传  相等的ack  == 3时，则相应的报文段立即重传，不会再等超时计时器超时时再重传，接下来执行快恢复算法</p><p><strong>问题： 重传后那丢失之前的数据包都收到了，那接收方重复确认时收到了之后的报文段吗</strong></p><p>收到了</p><p>快恢复</p><p>ssthresh 和 cwnd值为当前窗口的一半， 执行拥塞避免算法</p><p>也有一些把cwnd = 新的sstresh +3</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210331194703992.png" alt="image-20210331194703992"></p><h2><span id="对称加密和非对称加密的区别">对称加密和非对称加密的区别</span></h2><h3><span id="对称加密">对称加密</span></h3><p>加密和解密使用的秘匙是同一个</p><p>优点：算法公开，计算量小，加密速度快，加密效率高</p><p>缺点：数据传送前，双方必须商定好密匙，保存。如果一方密匙泄露被黑客拦截，则加密信息不安全，每次使用对称加密算法，都需要使用其他人不知道的唯一密匙，是的双方拥有的密匙数量大  </p><p>常见： DES  AES 3DES</p><h3><span id="非对称加密">非对称加密</span></h3><p>需要公开密匙和私有密匙，一方加密，另一方的密匙就解密</p><p>过程： 甲方生成密匙 ，将其中一把作为共有的并向其他方公开，得到公有密匙的乙方使用该密匙对机密信息进行加密后发送给甲方，甲方再用私有的密匙对加密信息进行解密</p><p>优点：安全</p><p>缺点：速度慢</p><p>常见：RSA  ECC</p><h2><span id="md5">MD5</span></h2><p>MD5讯息摘要演算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码杂凑函数，可以产生出一个128位元（16位元组）的散列值（hash value），用于确保信息传输完整一致。</p><p>MD5不可逆的原因是其是一种散列函数，使用的是hash算法，在计算过程中原文的部分信息是丢失了的</p><p>不过有个地方值得指出的是，一个MD5理论上的确是可能对应无数多个原文的，因为MD5是有限多个的而原文可以是无数多个。比如主流使用的MD5将任意长度的“字节串映射为一个128bit的大整数。也就是一共有2^128种可能，大概是3.4*10^38，这个数字是有限多个的，而但是世界上可以被用来加密的原文则会有无数的可能性。</p><h3><span id="用途">用途</span></h3><ol><li><p>防止被篡改</p></li><li><p>防止直接看到明文 —- 前后比较</p><p>​    现在很多网站在数据库存储用户的密码的时候都是存储用户密码的MD5值。这样就算不法分子得到数据库的用户密码的MD5值，也无法知道用户的密码。（比如在UNIX系统中用户的密码就是以MD5（或其它类似的算法）经加密后存储在文件系统中。当用户登录的时候，系统把用户输入的密码计算成MD5值，然后再去和保存在文件系统中的MD5值进行比较，进而确定输入的密码是否正确。通过这样的步骤，系统在并不知道用户密码的明码的情况下就可以确定用户登录系统的合法性。这不但可以避免用户的密码被具有系统管理员权限的用户知道，而且还在一定程度上增加了密码被破解的难度。）</p></li><li><p>防止抵赖–数字签名</p></li></ol><h3><span id="过程">过程</span></h3><p>对MD5算法简要的叙述可以为：MD5以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。</p><h2><span id="另外的问题">另外的问题</span></h2><h3><span id="内网和外网的区别">内网和外网的区别</span></h3><p>内网又称局域网（Local Area Network，LAN）是指在某一区域内由多台计算机互联成的计算机组。一般是方圆几千米以内。</p><p>局域网是封闭型的，可以由办公室内的两台计算机组成，也可以由一个公司内的上千台计算机组成。</p><p>局域网主要特点是：</p><p>1、覆盖的地理范围较小，只在一个相对独立的局部范围内联，如一座或集中的建筑群内。</p><p>2、使用专门铺设的传输介质进行联网，数据传输速率高（10Mb/s～10Gb/s）</p><p>3、通信延迟时间短，可靠性较高</p><p>4、局域网可以支持多种传输介质</p><p>外网又被称为广域网（WAN），就是我们通常所说的Internet，它是一个遍及全世界的网络。它可以连接极其大的物理范围，属于远程性的网络，已经实现了跨国互联，局域网以及城域网都远远比不上外网，外网是许多的计算机相互之间用线路连接形成的。</p><p>目前为止，因特网就是世界上最大的外网，它的覆盖范围无可匹敌。一些相隔较远的设备就需要外网的连接，这些设备中比较常见的是路由器和交换机 。</p><p>外网还分为了好几类，按照网络的使用类型可以分成公共传输、专用传输和无线传输三类网络传输。</p><p><strong>迅雷为什么会员可以加速那么快？</strong></p><p><strong>QQ传文件为什么那么快？</strong></p><h3><span id="常见的网络请求码">常见的网络请求码</span></h3><ul><li>101 等到接受其他部分</li><li>200 处理成功</li><li>201 请求成功服务器创建 了新的资源</li><li>202 服务器接受请求但未处理</li><li>301 永久移动</li><li>302 临时移动</li><li>400 错误请求  语法</li><li>401 未授权  需要登陆</li><li>403 禁止 服务器拒绝请求</li><li>404 u找不到请求页面</li><li>405 禁止请求n中制定的方法</li><li>408 请求超时</li><li>500 服务器内部u错误</li><li>503 服务不可用</li><li>505 http版本不支持</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面试总结</title>
      <link href="2021/01/20/Java%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
      <url>2021/01/20/Java%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1><span id="java-se">Java SE</span></h1><!--toc--><h2><span id="集合">集合</span></h2><h3><span id="arraylist">ArrayList</span></h3><ul><li>允许添加多个null值<ul><li>属性 size 是指 elementData 中实际有多少个元素，而 elementData.length 为集合容量 </li></ul></li><li>DEFAULTCAPACITY_EMPTY_ELEMENTDATA和EMPTY_ELEMENTDATA区别： 构造函数 是否有initialCapacity</li><li>第一次添加元素时扩容   默认初始的集合容量 10</li><li>每次增删都使modCount增加 ，并且增删会进行modCount的检查，例如在迭代时进行增删操作时 会报错，Itr中的expectedModCount与modCount不一致！</li></ul><p><span style="color:red;font-size:20px;">面试：优化数组 </span></p><span id="more"></span><p>标记-清除法</p><h3><span id="hashmap">HashMap</span></h3><p>内部hash函数</p><p>put前要进行对再次对hashcode再次hash，也就是高16 和低 16做异或运算</p><p><strong>为什么要重写equals 和hascode方法    ，puVal方法中有提到</strong></p><p>注意区分Node的hash 和 key的hashcode</p><p>基本类型的hashcode方法</p><p>自动装箱  最硬核的居然是Integer的hashcode方法，居然就返回的value！！</p><ul><li><p>为什么要右移16位？ </p><p>减少碰撞 降低hash冲突</p><p>JDK 1.8 put </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">       <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">           <span class="comment">//重点关注</span></span><br><span class="line">           n = (tab = resize()).length;</span><br><span class="line">       <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">           tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           Node&lt;K,V&gt; e; K k;</span><br><span class="line">           <span class="comment">//重点关注</span></span><br><span class="line">           <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">               ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">               <span class="comment">//这句话允许了配的钥匙可以开相同的锁</span></span><br><span class="line">               e = p;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">               e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                   <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                       <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                           treeifyBin(tab, hash);</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                       ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   p = e;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                   e.value = value;</span><br><span class="line">               afterNodeAccess(e);</span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       ++modCount;</span><br><span class="line">       <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">           resize();</span><br><span class="line">       afterNodeInsertion(evict);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>resize扩容机制  </p><p>JDK 1.6 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">       Entry[] src = table;</span><br><span class="line">       <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123;</span><br><span class="line">           Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">               src[j] = <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">do</span> &#123;</span><br><span class="line">                   Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                   <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">                   e.next = newTable[i];</span><br><span class="line">                   newTable[i] = e;</span><br><span class="line">                   e = next;</span><br><span class="line">               &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>注意 &amp; oldCap  和 &amp;oldCap-1 的区别！！！</p><p>注意这里的 (e.hash &amp; oldCap) == 0</p><p><a href="https://blog.csdn.net/u010425839/article/details/106620440?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-1.control&amp;dist_request_id=1328767.10456.16173490220630373&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-1.control">https://blog.csdn.net/u010425839/article/details/106620440?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-1.control&amp;dist_request_id=1328767.10456.16173490220630373&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-1.control</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line"><span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line"><span class="keyword">int</span> oldThr = threshold;</span><br><span class="line"><span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span> oldTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">             oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">        newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">    newCap = oldThr;</span><br><span class="line"><span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">    newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">    newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">              (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line">threshold = newThr;</span><br><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">table = newTab;</span><br><span class="line"><span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                Node&lt;K,V&gt; next;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    next = e.next;</span><br><span class="line">                    <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                            loHead = e;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            loTail.next = e;</span><br><span class="line">                        loTail = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                            hiHead = e;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            hiTail.next = e;</span><br><span class="line">                        hiTail = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                    newTab[j] = loHead;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                    newTab[j + oldCap] = hiHead;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newTab;</span><br></pre></td></tr></table></figure><p>首先将高16位无符号右移16位与低十六位做异或运算。如果不这样做，而是直接做&amp;运算那么高十六位所代表的部分特征就可能被丢失 将高十六位无符号右移之后与低十六位做异或运算使得高十六位的特征与低十六位的特征进行了混合得到的新的数值中就高位与低位的信息都被保留了 ，而在这里采用异或运算而不采用&amp; ，| 运算的原因是 异或运算能更好的保留各部分的特征，如果采用&amp;运算计算出来的值会向1靠拢，采用|运算计算出来的值会向0靠拢</p></li><li><p>Node 单链表结构</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210228192712917.png" alt="image-20210228192712917"></p></li><li><p>扩容机制</p></li><li><p>hash碰撞</p></li></ul><p>发生hash碰撞时 当前的元素生成新的节点保存在链表的尾部</p><h3><span id="linkedhashmap">LinkedHashMap</span></h3><p><strong>结构</strong></p><p>accessOrder有什么用？</p><p>transient关键字不可见 ？</p><p><strong>实现LRU</strong></p><p><strong>插入删除原理</strong></p><p><strong>hashmap留的后门</strong></p><p>哪种情况下get也会使得重新排序</p><h3><span id="hashtable">Hashtable</span></h3><p>Hashtable既不支持Null key也不支持Null value</p><p>为啥？</p><p>这是因为Hashtable使用的是安全失败机制（fail-safe），这种机制会使你此次读到的数据不一定是最新的数据。</p><p>如果你使用null值，就会使得其无法判断对应的key是不存在还是为空，因为你无法再调用一次contain(key）来对key是否存在进行判断，ConcurrentHashMap同理。</p><p><strong>解决问题</strong></p><p>多线程下添加元素的安全性</p><p>何为安全？多线程插入时的线程不安全问题  – 用hashTable可解决</p><p><strong>如何实现</strong></p><p>synchronized 锁方法</p><h3><span id="concurrenthashmap">ConcurrentHashMap</span></h3><p>优先选择– 性能效率更高</p><p>能说说什么是快速失败什么是安全失败吗？</p><p>快速失败  modCount 不能在多线程下并发修改</p><p>安全失败  concurrent包下的容器都是</p><h3><span id="synchronizedmap">SynchronizedMap</span></h3><p>排斥所 Object mutex</p><p>就是加锁</p><h2><span id="clone">Clone</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User u1 = <span class="keyword">new</span> User(...);</span><br><span class="line">User u2 = u1;<span class="comment">//将u1的reference给了u2</span></span><br><span class="line">u1 != u2</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Obj obj = <span class="keyword">new</span> Obj();</span><br><span class="line">obj = <span class="keyword">new</span> Obj();</span><br><span class="line">obj.stu = <span class="keyword">new</span> Stu();</span><br><span class="line">Obj obj2 = (Obj) obj.clone();</span><br><span class="line">System.out.println(obj2==obj);</span><br><span class="line">System.out.println(obj2.stu == obj.stu);</span><br><span class="line">System.out.println();</span><br></pre></td></tr></table></figure><p>此时操作u2/u1 都会使另一个的值发生改变</p><p>但如果我们不想改变另一个的值就需要使用到clone</p><p>实现Cloneable接口 //Cloneable接口没有具体的实现方法，他相当于是一个标识，如果类没有继承cloneable接口而调用clone方法，会抛出<strong>CloneNotSupportedExcepion异常</strong></p><h2><span id></span></h2><h3><span id="深拷贝和浅拷贝">深拷贝和浅拷贝</span></h3><p>浅拷贝</p><p>clone无法clone 一个对象中的另一个对象，还是是一个reference</p><p>深拷贝</p><p>在对象的对象中实现cloneable接口，重写clone方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    Obj obj = (Obj) <span class="keyword">super</span>.clone();</span><br><span class="line">    obj.stu = (Stu) stu.clone();</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="clone的保护机制">clone的保护机制</span></h3><p>object类中有protected 的native方法 clone，且 User肯定是继承了Object，为什么</p><p><span style="color:red;font-size:24px">未实现Cloneable接口的类不能调用clone方法</span></p><h4><span id="延伸-protected的作用范围">延伸： protected的作用范围</span></h4><p>一个public 类， 有protected的方法，</p><p>如果在同包下新建类继承他，这个新建的类对象能够调用protecTed的方法</p><p>如果在不同包下 新建一个类 继承他， 创建这个类的对象，不能调用 clone方法，但是可以在这个类中重写protected的方法，这样就能够调用。</p><p><span style="color:#3CB371;font-size:24px">这就是protected的 派生类对同包可见，不同包不可见的原理</span></p><p> protected受访问保护规则是很微妙的。虽然protected域对所有子类都可见。但是有一点很重要，子类只能在自己的作用范围内访问自己继承的那个父类protected域，而无法到访问别的子类（同父类的亲兄弟）所继承的protected域和父类对象的protected域</p><h2><span id="实现serlizable接口的类中uid是啥">实现Serlizable接口的类中UID是啥？</span></h2><p>java序列化机制。简单来说，JAVA序列化的机制是通过 判断类的serialVersionUID来验证的版本一致的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID于本地相应实体类的serialVersionUID进行比较。如果相同说明是一致的，可以进行反序列化，否则会出现反序列化版本一致的异常，即是InvalidCastException</p><p>显示声明serialVersionUID可以避免对象不一致，</p><h2><span id="equals-和-hascode方法">equals 和 hascode方法</span></h2><h3><span id="为什么要重写">为什么要重写</span></h3><p>公式：</p><p>hashcode相等时内容不一定相等</p><p>equals相等时hashcode必须相等</p><p>hashmap 存入自定义类时引发的问题</p><p>想用表面一样的两把钥匙去开同一扇门的问题</p><h3><span id="hashcode方法如何重写">hashcode方法如何重写</span></h3><p>到底要比较什么属性或者对象</p><h3><span id="equals方法如何重写">equals方法如何重写</span></h3><p>hash值相同时，由于你 hashmap判断链表时，hash值会用equals 方法比较两个对象， 所以如果要开锁，这里就需要重写equals方法</p><p>Object类原生的equals方法就是判断地址，所以这里需要重写</p><h3><span id="string类的equals">String类的equals</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">    <span class="comment">//内存地址相等</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    String anotherString = (String)anObject;</span><br><span class="line">    <span class="keyword">int</span> n = value.length;</span><br><span class="line">    <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">        <span class="comment">//比较字符串长度</span></span><br><span class="line">        <span class="keyword">char</span> v1[] = value;</span><br><span class="line">        <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//逐一比较字符</span></span><br><span class="line">            <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><h2><span id="abstrackstringbuilder">AbstrackStringBuilder</span></h2><p>构成</p><p>char[] value , int count</p><h3><span id="stringbuilder">StringBuilder</span></h3><p>static final long serialVersionUID = 4383685877147921099L;</p><p>区分 length() 和 capacity() </p><ul><li><p>capacity大小并不是2的幂次方</p></li><li><p>默认16长度，后append多少，就加多少 16 是默认预留的输入长度间隔，超过16则引起扩容</p></li><li><p>容量判断  ensureCapacityInternal(int minimumCapacity)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// mini--- all words</span></span><br><span class="line">    <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        value = Arrays.copyOf(value,</span><br><span class="line">                newCapacity(minimumCapacity));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>扩容机制 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">newCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// why add 2 ?</span></span><br><span class="line">    <span class="comment">//这里也就说明了为什么capacity为什么不是2的幂次方的问题了</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = (value.length &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (newCapacity &lt;= <span class="number">0</span> || MAX_ARRAY_SIZE - newCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        ? hugeCapacity(minCapacity)</span><br><span class="line">        : newCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Integer.MAX_VALUE - minCapacity &lt; <span class="number">0</span>) &#123; <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE)</span><br><span class="line">        ? minCapacity : MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>核心添加方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String 类下的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getChars</span><span class="params">(<span class="keyword">int</span> srcBegin, <span class="keyword">int</span> srcEnd, <span class="keyword">char</span> dst[], <span class="keyword">int</span> dstBegin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (srcBegin &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(srcBegin);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (srcEnd &gt; value.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(srcEnd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (srcBegin &gt; srcEnd) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(srcEnd - srcBegin);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//核心</span></span><br><span class="line">        System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p>追问？ 有了解过底层的arraycopy方法吗？</p><h3><span id="stringbuffer">StringBuffer</span></h3><p>结构： transient char[]  toStringCache , static final long serialVersionUId</p><h4><span id="为何是线程安全的">为何是线程安全的？</span></h4><p>使用synchronized </p><h2><span id="接口-继承-泛型">接口、继承、泛型</span></h2><p>如何看待接口和抽象类？</p><p>你怎么理解泛型？有什么作用？</p><h2><span id="深入synchronized">深入Synchronized</span></h2><p><strong>Java中的锁类型</strong></p><p>可重入锁、公平锁、互斥锁、自旋锁、偏向锁、轻量级锁、读写锁、共享锁</p><p>ReentrantLock 加锁原理： 更改标识符的值  </p><p>synchronized 到底改变的是对象的什么属性？？？</p><p><strong>对象头</strong></p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210307090828271.png" alt="image-20210307090828271"></p><p><strong>隐式</strong></p><p>synchronized方法 monitorexit</p><p>JVM可以从方法常量池中的方法表结构(method_info Structure) 中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法</p><p>当方法调用时，调用指令将会 检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有monitor（虚拟机规范中用的是管程一词）， 然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor</p><p><strong>为何class文件会有两个monitorexit</strong></p><p>synchronized代码块  会有monitorenter…</p><p>为了保证在方法异常完成时 monitorenter 和 monitorexit 指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行 monitorexit 指令。从字节码中也可以看出多了一个monitorexit指令，它就是异常结束时被执行的释放monitor 的指令。</p><p><strong>为什么早期是重量级锁</strong></p><p>同时我们还必须注意到的是在Java早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的Mutex Lock来实现的，而操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高</p><h3><span id="jvm对锁的优化"><strong>JVM对锁的优化</strong></span></h3><p>锁的升级： 无锁–偏向–轻量–重量</p><p><strong>偏向锁</strong></p><p>在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁(会涉及到一些CAS操作,耗时)的代价而引入偏向锁。偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。所以，对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁</p><p><strong>轻量级锁</strong></p><p>倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)，此时Mark Word 的结构也变为轻量级锁的结构。轻量级锁能够提升程序性能的依据是“对绝大部分的锁，在整个同步周期内都不存在竞争”，注意这是经验数据。需要了解的是，轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。</p><p><strong>自旋锁</strong></p><p>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。这是基于在大多数情况下，线程持有锁的时间都不会太长，如果直接挂起操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，因此自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)，一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式，这种方式确实也是可以提升效率的。最后没办法也就只能升级为重量级锁了</p><p><strong>锁消除</strong></p><p>ava虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间，如下StringBuffer的append是一个同步方法，但是在add方法中的StringBuffer属于一个局部变量，并且不会被其他线程所使用，因此StringBuffer不可能存在共享资源竞争的情景，JVM会自动将其锁消除</p><h3><span id="自旋锁">自旋锁</span></h3><p>CAS   没有获取到锁的线程是不会阻塞的，要通过控制循环值不断获取</p><p>3个操作数  内存值 V（共享） 旧的预期值E（缓存） 要修改的新值N，仅当E == N时，才会修改  E!=N时，则再次查询主存中的V 使 E == N </p><p>底层：硬件</p><h2><span id="三大特性">三大特性</span></h2><h3><span id="原子性">原子性</span></h3><p>一个或者多个操作在CPU执行的过程中不被中断的特性</p><h4><span id="可见性">可见性</span></h4><p>一个线程修改一个变量后，其他线程能够立即得知这个修改</p><p>各自的线程有其工作内存，即保存时的副本存储的空间</p><h4><span id="有序性">有序性</span></h4><p>代码的执行顺序  </p><p>编译器 和 处理器执行指令时会进行从排序，改变语序   这里<strong>注意什么时候能改什么时候不能改！</strong></p><h3><span id="volatile">Volatile</span></h3><ol><li><p>保证不同线程对变量操作的内存可见性（修改变量直接刷新回主存），使缓存行无效</p></li><li><p><strong>禁止指令重排序</strong>   注意是并不是完全就是一样的顺序，只保证先后顺序</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210313233725385.png" alt="image-20210313233725385"></p></li></ol><h4><span id="happens-before-原则">happens - before 原则</span></h4><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210313233650045.png" alt="image-20210313233650045"></p><h4><span id="volatile-到底锁什么">volatile 到底锁什么？</span></h4><h4><span id="为什么不能保证-count-原子性">为什么不能保证 count++ 原子性？</span></h4><p>单个变量的读写 具有原子性</p><p>但复合操作则不行</p><p>底层机制：内存屏障</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210313233706649.png" alt="image-20210313233706649"></p><p>使用 ： 状态标记、单例模式</p><h3><span id="juc">JUC</span></h3><h4><span id="问题">问题</span></h4><h5><span id="synchronized到底是什么-原理">synchronized到底是什么  原理？</span></h5><p>synchronized是一个重量级锁，实现依赖于JVM 的 monitor 监视器锁。主要使用monitorenter和monitorexit指令来实现方法同步和代码块同步。在编译的是时候，会将monitorexit指令插入到同步代码块的开始位置，而monitorexit插入方法结束处和异常处，并且每一个monitorexit都有一个与之对应的monitorexit。</p><p><strong>任何对象都有一个monitor与之关联</strong>，当一个monitor被持有后，它将被处于锁定状态，线程执行到monitorenter指令时间，会<strong>尝试获取对象所对应的monitor的所有权</strong>，即获取获得对象的锁，由于在编译期会将monitorexit插入到方法结束处和异常处，所以在方法执行完毕或者出现异常的情况会自动释放锁</p><h4><span id="锁">锁</span></h4><p>结构  可重入锁 读锁 写锁 </p><p>将大的方法加入同步锁会影响执行效率</p><p>sleep 抱着锁睡觉</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210303172037854.png" alt="image-20210303172037854"></p><h5><span id="锁到底锁什么">锁到底锁什么</span></h5><p>synchronized 默认锁的是this  方法的调用者</p><p>​    但是this 中的对象则不能同步 ，要同步哪个对象 就锁哪个</p><h5><span id="死锁">死锁</span></h5><p><strong>两个或多个线程在等待对方释放资源；某个同步块同时拥有两个以上对象的锁</strong> </p><p>产生死锁的条件<br>1.互斥条件：一个资源每次只能被一个进程使用。<br>2.请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>3.不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。<br>4.循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</p><h4><span id="synchronized和lock的区别">Synchronized和Lock的区别</span></h4><ul><li>Lock可以判断是否获取到了锁</li><li>lock必须要手动释放，如果不释放锁，则出现死锁</li><li>Lock不一定会等待下去</li><li>可重入锁，不可中断，非公平 </li><li>Lock适合锁大量的代码</li></ul><h4><span id="虚假唤醒">虚假唤醒</span></h4><p>等待应该总是在循环中</p><p>嵌套的syn语句</p><h4><span id="condition">Condition</span></h4><p>精准唤醒和停止   顺序唤醒 </p><h4><span id="8锁问题">⑧锁问题</span></h4><h3><span id="向下转型和向上转型">向下转型和向上转型</span></h3><p>将整个继承关系想像成由上至下</p><p>向上转型   子转父（包括接口） 丢失方法</p><p>向下转型   父转子   重新获得失去的方法</p><p>联想 ：Android中findViewById中就是需要向下转型</p><h3><span id="自动拆箱和装箱">自动拆箱和装箱</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer a = <span class="number">127</span>;</span><br><span class="line">Integer b = <span class="number">127</span>;</span><br><span class="line">System.out.println(a == b);</span><br><span class="line"><span class="comment">//false </span></span><br><span class="line"><span class="comment">//字节码 比较时涉及到intValue方法</span></span><br><span class="line"><span class="comment">//new时涉及valueOf方法</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">        <span class="comment">//可以自行设置max的最大值</span></span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>涉及到的静态内部类的知识</p><p>静态内部类只会在使用到该内部类时才会加载，否则是不会加载的，也就是只有使用到new Integer的valueOf方法时，才会加载该内部类</p><h2><span id="io操作">I/O操作</span></h2><h3><span id="常见几大输入输出类">常见几大输入输出类</span></h3><h2><span id="面试问题">面试问题</span></h2><p>为什么0.1+0.2= 0.30000000004</p><p>short s1 = 1; s1 = s1 + 1;</p><p>HashSet内部如何实现？为什么要重写hashcode 和 equals方法？</p><p>try catch 中 return 会怎么样？ 调用system.exit呢</p><p>为什么作为方法传参时，String 是不可变，但例如自定义类的引用 // 数组  是可变的呢</p><ul><li>在我们进行传递时不管是值传递还是地址传递传递的都会copy一个副本进行传递而不是‘原件’。在引用数据类型中，副本与原件指向同一个地址时改变地址内部的值原件会受到影响，但是如果改变了副本指向的地址那么副本的一切变化于原件就没有关系了。<br>所以当 方法中的s发生改变时相当于将副本指向了新的地址于原件自然就没有关系了，方法外部的s没有变化也就解释的通了。</li></ul><p><strong>为什么String是不可变的</strong></p><p>内部final修饰 ，s1 = s2 是允许的，仅改变指向的引用地址</p><p>是否可以改变value的值？ 可以，反射</p><p><strong>抽象类和接口的区别</strong></p><p>抽象类 代码复用    相同的行为…. </p><p>接口是对类的约束，强制要求不同的类有相同的行为</p><p><strong>JDK 8新特性</strong></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android面试总结</title>
      <link href="2021/01/10/Android%E9%9D%A2%E8%AF%95/"/>
      <url>2021/01/10/Android%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1><span id="android面试总结">Android面试总结</span></h1><!-- toc --><ul><li><a href="#cas">CAS</a><ul><li><a href="#ipc%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1">IPC进程间通信</a><ul><li><a href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB">线程和进程的关系</a></li><li><a href="#android%E4%B8%AD%E7%9A%84ipc">Android中的IPC</a><ul><li><a href="#aidl">AIDL</a></li><li><a href="#binder">Binder</a></li><li><a href="#%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F">序列化的两种方式</a></li></ul></li></ul></li></ul></li><li><a href="#andoird">Andoird</a><ul><li><a href="#%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86">启动原理</a></li><li><a href="#%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6">事件分发机制</a><ul><li><a href="#dispatchtouchevent">dispatchTouchEvent</a></li><li><a href="#onintercepttouchevent">onInterceptTouchEvent</a></li><li><a href="#ontouchevent">onTouchEvent</a></li></ul></li><li><a href="#view%E5%8E%9F%E7%90%86">View原理</a><ul><li><a href="#activty%E7%9A%84%E5%90%AF%E5%8A%A8%E9%A1%BA%E5%BA%8F">Activty的启动顺序</a></li><li><a href="#activity%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F">Activity启动模式</a></li><li><a href="#%E5%AF%B9activity%E8%BF%9B%E8%A1%8C%E7%BC%93%E5%AD%98">对activity进行缓存</a></li><li><a href="#activity%E9%97%B4%E9%80%9A%E4%BF%A1">Activity间通信</a></li><li><a href="#view%E7%BB%93%E6%9E%84">View结构</a></li><li><a href="#view%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B">View绘制流程</a><ul><li><a href="#measure">measure</a></li><li><a href="#layout">layout</a></li><li><a href="#draw">draw</a></li></ul></li></ul></li><li><a href="#%E6%A8%AA%E7%AB%96%E5%B1%8F%E5%88%87%E6%8D%A2%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">横竖屏切换的生命周期</a></li><li><a href="#gradle">Gradle</a><ul><li><a href="#%E6%98%AF%E4%BB%80%E4%B9%88">是什么</a></li><li><a href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">配置文件</a></li></ul></li><li><a href="#fragment">Fragment</a><ul><li><a href="#%E4%B8%8Eactivity%E9%80%9A%E4%BF%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F">与Activity通信的几种方式</a></li></ul></li><li><a href="#handler">Handler</a><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFhandler">什么是Handler</a></li><li><a href="#%E9%97%AE%E9%A2%98%E7%9A%84%E5%87%BA%E5%8F%91%E7%82%B9">问题的出发点</a></li><li><a href="#%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86">通信原理</a></li><li><a href="#%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1">线程通信</a><ul><li><a href="#asynctask">AsyncTask</a></li></ul></li><li><a href="#handlerthread">HandlerThread</a></li><li><a href="#%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98">面试问题</a></li><li><a href="#%E9%A2%9D%E5%A4%96%E7%9A%84%E9%97%AE%E9%A2%98">额外的问题</a></li></ul></li><li><a href="#intent">Intent</a></li><li><a href="#recycleview">RecycleView</a><ul><li><a href="#%E4%B8%8Elistview%E7%9A%84%E4%B8%8D%E5%90%8C%E7%82%B9">与ListVIew的不同点</a></li><li><a href="#%E6%BB%9A%E5%8A%A8%E6%9C%BA%E5%88%B6">滚动机制</a></li><li><a href="#%E5%9B%9B%E7%BA%A7%E7%BC%93%E5%AD%98">四级缓存</a></li><li><a href="#%E5%B5%8C%E5%A5%97%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81">嵌套如何解决滑动冲突</a></li><li><a href="#%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B%E5%92%8C%E5%A4%8D%E7%94%A8%E6%9C%BA%E5%88%B6">具体流程和复用机制</a></li><li><a href="#%E5%86%85%E9%83%A8%E7%B1%BB">内部类</a><ul><li><a href="#recyler">Recyler</a></li><li><a href="#recycledviewpool">RecycledViewPool</a></li></ul></li><li><a href="#%E6%96%B9%E6%B3%95">方法</a></li><li><a href="#layoutmanager">LayoutManager</a></li></ul></li><li><a href="#android%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86">Android启动原理</a></li><li><a href="#%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D">屏幕适配</a><ul><li><a href="#%E6%A6%82%E5%BF%B5">概念</a></li></ul></li><li><a href="#framework">Framework</a><ul><li><a href="#%E6%A6%82%E5%BF%B5-1">概念</a></li></ul></li><li><a href="#contentprovider">ContentProvider</a><ul><li><a href="#%E4%BD%9C%E7%94%A8">作用</a></li></ul></li><li><a href="#okhttp">OkHttp</a><ul><li><a href="#%E6%A0%B8%E5%BF%83%E7%B1%BB">核心类</a></li><li><a href="#%E6%B5%81%E7%A8%8B%E5%88%86%E8%BF%B0">流程分述</a><ul><li><a href="#1-%E5%A6%82%E4%BD%95%E5%8F%91%E9%80%81">1. 如何发送</a></li><li><a href="#2-%E8%A2%AB%E8%B0%81%E5%A4%84%E7%90%86">2. 被谁处理</a></li><li><a href="#3-%E5%A6%82%E4%BD%95%E7%BB%B4%E6%8A%A4">3. 如何维护</a></li><li><a href="#4-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F">4. 建造者模式</a></li><li><a href="#5-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F">5. 责任链模式</a></li></ul></li></ul></li><li><a href="#retrofit">Retrofit</a><ul><li><a href="#%E5%A5%BD%E5%A4%84">好处</a></li><li><a href="#%E5%8E%9F%E7%90%86">原理</a><ul><li><a href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">动态代理</a></li></ul></li><li><a href="#%E7%B1%BB">类</a></li><li><a href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">设计模式</a></li><li><a href="#%E5%B7%AE%E5%BC%82">差异</a></li><li><a href="#%E9%97%AE%E9%A2%98">问题</a></li></ul></li><li><a href="#volley">Volley</a></li><li><a href="#%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E6%A1%86%E6%9E%B6">图片加载框架</a></li><li><a href="#glide">Glide</a><ul><li><a href="#from">from</a></li><li><a href="#load">load</a></li><li><a href="#into">into</a></li></ul></li><li><a href="#%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98-1">面试问题</a><ul><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%90%E7%BA%BF%E7%A8%8B%E4%B8%8D%E8%83%BD%E6%9B%B4%E6%96%B0ui">为什么子线程不能更新UI</a></li><li><a href="#viewpost-%E5%92%8C-handlerpost%E7%9A%84%E5%8C%BA%E5%88%AB">View.post 和 Handler.post的区别</a></li><li><a href="#gradle%E5%88%B0%E5%BA%95%E6%98%AF%E4%B8%AA%E5%95%A5">Gradle到底是个啥</a></li></ul></li></ul></li><li><a href="#mysql">Mysql</a><ul><li><a href="#%E5%BC%95%E6%93%8E">引擎</a><ul><li><a href="#myiasm">MyIAsm</a></li><li><a href="#inoodb">Inoodb</a></li></ul></li><li><a href="#%E7%B4%A2%E5%BC%95">索引</a><ul><li><a href="#myiasm%E5%92%8Cinoodb%E7%9A%84%E4%B8%8D%E5%90%8C">MyIAsm和Inoodb的不同</a></li></ul></li></ul></li><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86">计算机原理</a></li><li><a href="#%E9%9D%A2%E8%AF%95">面试</a></li></ul><!-- tocstop --><h2><span id="cas">CAS</span></h2><h3><span id="ipc进程间通信">IPC进程间通信</span></h3><p>Inter-Process Communication </p><ul><li>Windows：通过剪切板、管道、油槽等进行进程间通讯。</li><li>Linux：通过命名空间、共享内容、信号量等进行进程间通讯。</li><li>Android：没有完全继承Linux，比如，其独具特色的通讯方式有Binder、Socket等等。</li><li><span id="more"></span></li></ul><h4><span id="线程和进程的关系">线程和进程的关系</span></h4><p>进程： 一个执行单元 一个程序或者应用</p><p>进程是程序运行和资源分配的基本单位</p><p>线程： CPU调度的最小单元  有限的系统资源</p><p>是cpu调度和分派的基本单位</p><p>Android中 进程空间划分为用户空间和内核空间，进程间用户空间不可分享，但内核空间可分享  所有进程共用一个内核空间</p><p>进程内用户空间 和内核空间交互 要通过系统调用</p><ol><li>copy_from_user（）：将用户空间的数据拷贝到内核空间</li><li>copy_to_user（）：将内核空间的数据拷贝到用户空间</li></ol><h4><span id="android中的ipc">Android中的IPC</span></h4><h5><span id="aidl">AIDL</span></h5><p>AIDL     <strong>Android Interface definition language</strong></p><p>C/S 端的AIDL名称  （包名+类名）必须一致</p><p>内部类 Proxy  Stub  都implementes这个接口</p><p>AIDL层双方通信方式类似 符号引用</p><h5><span id="binder">Binder</span></h5><p>设计基于C/S结构  客户端进程获取服务端进程的代理，并通过向这个代理借口方法中读写数据来完成进程间的数据通信</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210321133957552.png" alt="image-20210321133957552"></p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210320184127616.png" alt="image-20210320184127616"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS1kM2M3OGIxOTNjM2U4YTM4LnBuZz9pbWFnZU1vZ3IyL2F1dG8tb3JpZW50L3N0cmlwJTdDaW1hZ2VWaWV3Mi8yL3cvMTI0MA" alt="img"></p><p>传统进程通信</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210320192944412.png" alt="image-20210320192944412"></p><p>Binder通信</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210321134303878.png" alt="image-20210321134303878"></p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210320192905310.png" alt="image-20210320192905310"></p><p>Binder可理解为是一种虚拟的物理设备，它的设备驱动是/dev/binder</p><p>从Android Framework角度来说，Binder是ServiceManager连接各种Manager（ActivityManager、WindowManager，etc）和相应ManagerService的桥梁</p><p>从Android应用层来说，Binder是客户端和服务端进行通信的媒介，当你bindService的时候，服务端会返回一个包含了服务端业务调用的Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务或者数据，这里的服务包括普通服务和基于AIDL的服务。</p><p><strong>Binder一个很重要的作用是：将客户端的请求参数通过Parcel包装后传到远程服务端，远程服务端解析数据并执行对应的操作，同时客户端线程挂起，当服务端方法执行完毕后，再将返回结果写入到另外一个Parcel中并将其通过Binder传回到客户端，客户端接收到返回数据的Parcel后，Binder会解析数据包中的内容并将原始结果返回给客户端，至此，整个Binder的工作过程就完成了。由此可见，Binder更像一个数据通道，Parcel对象就在这个通道中跨进程传输，至于双方如何通信，这并不负责，只需要双方按照约定好的规范去打包和解包数据即可。</strong></p><p>三层结构：</p><p>Client：具体和某一个Service通信，先从ServiceManager获取该Service的相关信息，根据得到的Serviice信息和Service所在的Serve进程建立通信</p><p>Server：注册Service到ServiceManager</p><p>ServiceManager： 管理这些Service 并向Client提供相关的接口</p><p>Android系统会为每一个应用分配一个唯一的UID，具有相同UID的应用才能共享数据。要求两个应用具有相同的ShareUID并且签名相同才可以跑在同一个进程中。在这种情况下，它们可以互相访问对方的私有数据，比如data目录、组件信息等，不管它们是否跑在同一个进程中。当然如果它们跑在同一个进程中，那么除了能共享data目录、组件信息，还可以共享内存数据，或者说它们看起来就像是一个应用的两个部分。</p><h5><span id="序列化的两种方式">序列化的两种方式</span></h5><p>Parcelable</p><p>Serializable</p><h2><span id="andoird">Andoird</span></h2><h3><span id="启动原理">启动原理</span></h3><p><a href="https://www.jianshu.com/p/12de32b31836">https://www.jianshu.com/p/12de32b31836</a></p><h2><span id></span></h2><h3><span id="事件分发机制">事件分发机制</span></h3><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210301164920245.png" alt="image-20210301164920245"></p><h4><span id="dispatchtouchevent">dispatchTouchEvent</span></h4><p>true ： 已经进行了处理，不在向下传递，停止分发</p><p>false： 未处理，继续分发    一般默认返回false</p><h4><span id="onintercepttouchevent">onInterceptTouchEvent</span></h4><p>Viewgroup特有</p><p>事件传入 dispatch内部 调用这个方法</p><p>false ： 子View 调用dispatc…</p><p>true：交给该Viewgourp的onTouchEvent方法处理 ，不过也要看他自己能不能有没有ontouchEvent</p><h4><span id="ontouchevent">onTouchEvent</span></h4><p>Activity层</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210301174949296.png" alt="image-20210301174949296"></p><p>ViewGroup层</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210301180054892.png" alt="image-20210301180054892"></p><p>View层</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210301182854640.png" alt="image-20210301182854640"></p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210301182955527.png" alt="image-20210301182955527"></p><h3><span id="view原理">View原理</span></h3><h4><span id="activty的启动顺序">Activty的启动顺序</span></h4><p>onCreate – onStart —onResume </p><p>home键返回后  onPause  – onStop   从后台返回时  onStart — onResume</p><p>打开新的activity’时  onpause  –onStop</p><p>关闭程序后  onPuase – onStop – onDestroy – onDetachedFromWindow</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210314102121692.png" alt="image-20210314102121692"></p><h4><span id="activity启动模式">Activity启动模式</span></h4><ol><li><p>standard 默认标准模式，每启动一个都会创建实例</p><p>应用： B站视频打开</p></li><li><p>singleTop 栈顶复用，在栈顶 就调用onNewIntent复用 </p></li><li><p>singleTask 栈内复用， 本栈内只要用该类型的activty就会将顶部的activity出栈</p></li><li><p>singleInstance 单例模式，单独给activity创建一个栈</p><p>前台任务栈  后台任务栈</p></li></ol><h4><span id="对activity进行缓存">对activity进行缓存</span></h4><ul><li>打开新的Activity / Home键 / 电源键  onStop后会调用onSaveInstanceState 方法，可以在参数bundle中进行保存</li><li>onRestoreInstanceState 对数据进行恢复</li></ul><h4><span id="activity间通信">Activity间通信</span></h4><ol><li>Intent – Bundle</li><li>Service</li></ol><h4><span id="view结构">View结构</span></h4><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210314103217599.png" alt="image-20210314103217599"></p><p>View 树结构</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210314103242042.png" alt="image-20210314103242042"></p><h4><span id="view绘制流程">View绘制流程</span></h4><h5><span id="measure">measure</span></h5><h5><span id="layout">layout</span></h5><h5><span id="draw">draw</span></h5><h3><span id="横竖屏切换的生命周期">横竖屏切换的生命周期</span></h3><h3><span id="gradle">Gradle</span></h3><h4><span id="是什么">是什么</span></h4><p>Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化构建开源工具。它使用一种基于Groovy的特定领域语言(DSL)来声明项目设置，抛弃了基于XML的各种繁琐配置。</p><ol><li>Gradle是一个自动化构建工具</li><li>兼容Maven等仓库</li><li>基于Groovy的特定领域语言来声明名目设置</li></ol><h4><span id="配置文件">配置文件</span></h4><ol><li>settings.gradle:整个Project的配置文件，可以设置包含哪些module</li><li>build.gradle （Project的gradle文件）:整个Project的配置文件</li><li>build.gradle（Module）：Module的配置文件</li><li>gradle.properties：可以在 gradle.properties 文件中配置一些变量</li></ol><h3><span id="fragment">Fragment</span></h3><p><span style="color: #00BFFF;font-size:24px">结合BottomNavigationView使用</span></p><p><span style="color:#3CB371;font-size:24px">如何减少Fragment切换时的重复创建？transaction.replace方法如何？ 有没有考虑用过hide 、add、show的方法？状态保存？</span></p><p>先创建所有fragment的对象，在需要时初始化，如果切换时隐藏，需要时在利用，这样也能够进行状态的保存了</p><p>fragment中 onHiddenChange方法可以监听 hide状态</p><p><strong>fragmentTransaction  addToBackStack 有什么作用?</strong></p><p>记录当前事务， backPress时 依次弹栈</p><h4><span id="与activity通信的几种方式">与Activity通信的几种方式</span></h4><ol><li>接口  传入activity的view</li><li>getActivity 调用其中的公共方法</li><li>广播？</li><li>getActivity.getFragmentManager.findFragmentById</li></ol><h3><span id="handler">Handler</span></h3><h4><span id="什么是handler">什么是Handler</span></h4><p>Android SDK 处理异步消息的核心类</p><p>子线程与主线程通过Handler 通信，子线程通过Hanlder通知主线程的Ui更新</p><p>Handler  Message  MessageQueue    Looper   Thread</p><h4><span id="问题的出发点">问题的出发点</span></h4><p>Handler 多层嵌套过程如何？</p><p>试图在子线程中更改UI:</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210305160239366.png" alt="image-20210305160239366"></p><p>在子线程中添加Looper会报错   且通过Looper.getMainLooper  或者myLooper获取的值和主线程的是一样的</p><h4><span id="通信原理">通信原理</span></h4><p>Message内部结构</p><p>clear方法</p><p>MessageQueue 进表出表  enqueueMessage的最终结果  Meeage按照when的时间远近排序  —涉及链表的操作</p><p>Looper—&gt;ThreadLocal </p><p>looper内部   loop()方法    找是否当前when有一个message     如果message自己能处理就自己处理，如果不能自己处理，就看handler是否能够法处理（回调监听器  mCallBack   有bool值 类似ontouch）    最后看回调监听器的返回值，看是否执行重写的handleMessage</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            handleCallback(msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4><span id="线程通信">线程通信</span></h4><p>Message线程间通信的数据载体</p><h5><span id="asynctask">AsyncTask</span></h5><p>异步任务    对Handler 和Thread的封装  更简洁高效   且封装了ThreadPool</p><ul><li>Message视角</li></ul><p><span style="color: #00BFFF;font-size:18px">一个线程可以有多个Handler，一个线程的多个Handler只能有一个相同的Looper以及Looper的MessageQueue。Handler初始化时会初始化自身持有的Loope以及looper的messageQueue，发送消息时，先进入到handler.post/send中，然后在mQueue中进行enqueueMessage，通过message的when对当前插入的message进行排序（当然肯定是锁了的），确保一个messagequeue中的所有message都是以when进行排序的</span></p><ul><li><p>Handler视角</p><p><span style="color:#3CB371;font-size:24px">Handler在进行处理时会通过系统持续循环的looper的loop方法进行搜索，判断当前的时间点是否有与when相同的message等待被处理，如果需要被处理，则会有一套分发机制。先看message是否带有callback的回调方法，如果没有，则看当前handler是否有callback的回调，如果还是没有，则去找handler自身写的handlemessage方法，这个方法也是暴露的，可以重写</span></p></li></ul><h4><span id="handlerthread">HandlerThread</span></h4><p>就是内置handler的thread</p><h4><span id="面试问题">面试问题</span></h4><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210305165916419.png" alt="image-20210305165916419"></p><p><span style="color:red;font-size:20px;">一个线程有几个Handler</span></p><p>多个handler</p><p><span style="color:red;font-size:20px;">一个线程有几个looper，如何保证</span></p><p>只有一个Looper</p><ul><li>线程和looper的关系</li></ul><p><span style="color:red;font-size:20px;">重点： 内存泄漏</span></p><p>根本原因：内部变量？会持有外部类的引用  ，而activity被handler持有</p><p>MessageQueue  –&gt;Message  –&gt;Handler  -&gt;HandleR  -&gt;this (Activity)   –&gt;拥有大量的内存</p><p>问题转为JVM问题     GC   可达性分析   发现是可达的，故不会GC</p><p>解决方案</p><p>static    弱引用 / 软引用   </p><p>destroy时 清理handler 所有的message   messagequeue  quitsafely</p><p><span style="color:red;font-size:20px;">如何在子线程中使用Handler</span></p><p>HandlerThread</p><p>如何解决      锁机制</p><p><span style="color:red;font-size:20px;">HandlerThread的不同</span></p><p><span style="color:red;font-size:20px;">没有消息时会怎么办</span></p><h4><span id="额外的问题">额外的问题</span></h4><p>为什么 runOnUiThread 执行耗时操作还是 会影响主线程的执行</p><h3><span id="intent">Intent</span></h3><h3><span id="recycleview">RecycleView</span></h3><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210306140559042.png" alt="image-20210306140559042"></p><h4><span id="与listview的不同点">与ListVIew的不同点</span></h4><p>缓存机制不同</p><h4><span id="滚动机制">滚动机制</span></h4><p>onTouch  – scrollBy   – fill  –  layoutChunk填充  —next –tryGetViewHolder….复用 —  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getItemDecorInsetsForChild</span><br><span class="line">   </span><br></pre></td></tr></table></figure><p>解决itemdecoration</p><h4><span id="四级缓存">四级缓存</span></h4><p>mAttachedScrap(屏幕内)// mCaneScrap，mCacheViews(屏幕外)，mViewCacheExtension(自定义缓存)，mRecyclerPool(缓存池)</p><p>缓存和复用到底在处理什么？ View ？ ViewHolder？</p><ol><li>首先在mChangeScrap  两种方式  position / id(stable id)</li><li>mattachScrap  和HiddenView 动画和 cachedView   by position/ id</li><li>自定义</li><li>缓存池</li><li>createViewHolder - -onCreateViewHolder创建</li></ol><p><strong>缓存</strong></p><p>Recycler</p><p>fill之前</p><ol><li><p>mCachedView   把索引0 的holder放到pool中</p></li><li><p>pool中存</p><p>根据ViewType</p><p>sparseArray 键值对存储 类似hashmap</p><p>如果同类项的array已经超过5个， 则不放了！</p></li></ol><p>都在内部类Recylcer</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210316193720147.png" alt="image-20210316193720147"></p><p>缓存池的结构</p><h4><span id="嵌套如何解决滑动冲突">嵌套如何解决滑动冲突</span></h4><h4><span id="具体流程和复用机制">具体流程和复用机制</span></h4><h4><span id="内部类">内部类</span></h4><h5><span id="recyler">Recyler</span></h5><p>tryGetViewHolderForPositionByDeadline</p><h5><span id="recycledviewpool">RecycledViewPool</span></h5><h4><span id="方法">方法</span></h4><p>onBindView 缓存的个数  10 </p><p>onTouchEvent  触碰关键的函数    —-   滚动机制  scrollBy</p><p>—-fill</p><h4><span id="layoutmanager">LayoutManager</span></h4><p>measure方法主要是交给他来做的</p><h3><span id="android启动原理">Android启动原理</span></h3><p>hhhh</p><q>sbsbsb</q><pre><code> w;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</code></pre><h3><span id="屏幕适配">屏幕适配</span></h3><h4><span id="概念">概念</span></h4><p>dp ：      density-independent pixels n个实际像素，与设备dpi相关，与px（像素）换算关系：dp/160 = px/dpi。  px = dp*dpi /160</p><p>那么dp究竟解决了适配上的什么问题？可以看出1dp = 1/160inch；那么它至少能解决一个问题，就是你在布局文件写某个View的宽和高为160dp*160dp，这个View在任何分辨率的屏幕中，显示的尺寸大小是大约是一致的（可能不精确），大概是 1 inch * 1 inch </p><p>dpi:         Dots Per Inch（每英寸所打印的点数）</p><p>px: 1920*1080 (px)</p><h3><span id="framework">Framework</span></h3><h4><span id="概念">概念</span></h4><h3><span id="contentprovider">ContentProvider</span></h3><h4><span id="作用">作用</span></h4><h3><span id="okhttp">OkHttp</span></h3><h4><span id="核心类">核心类</span></h4><ol><li><p>OkHttpClient</p><p>newCall(this,request)   return new ReaCall</p><ol><li><p>RealCall</p><p>final class 、implements Call</p><p>持有一个final的OkHttpCall，持有传来的Request  构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback, <span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Already Executed&quot;</span>);</span><br><span class="line">      executed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    client.dispatcher().enqueue(<span class="keyword">new</span> AsyncCall(responseCallback, forWebSocket));</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="comment">//同步为什么还要确保是否执行？</span></span><br><span class="line">      <span class="comment">//可能clone？</span></span><br><span class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Already Executed&quot;</span>);</span><br><span class="line">    executed = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    client.dispatcher().executed(<span class="keyword">this</span>);</span><br><span class="line">      <span class="comment">//dispatcher 返回的是Distpatcher ---OkHttpClient持有</span></span><br><span class="line">    Response result = getResponseWithInterceptorChain(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Canceled&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>Dispatcher</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxRequests = <span class="number">64</span>; <span class="comment">// 最大request数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxRequestsPerHost = <span class="number">5</span>; <span class="comment">// 最大requests/Host数 </span></span><br><span class="line"><span class="comment">/** Executes calls. Created lazily. */</span><span class="comment">//重要！</span></span><br><span class="line"><span class="keyword">private</span> ExecutorService executorService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Ready async calls in the order they&#x27;ll be run. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; readyAsyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Running asynchronous calls. Includes canceled calls that haven&#x27;t finished yet. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Running synchronous calls. Includes canceled calls that haven&#x27;t finished yet. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealCall&gt; runningSyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br></pre></td></tr></table></figure><p>enqueue 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是在runningAsync中添加还是readyAsync中添加 ？？？</span></span><br><span class="line"><span class="comment">//运行队列总数&lt;64 请求所属主机执行的任务数</span></span><br><span class="line"><span class="keyword">if</span> (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">  runningAsyncCalls.add(call);</span><br><span class="line">  <span class="comment">//如果是runningAsyncCall中，则直接执行这个call</span></span><br><span class="line">  <span class="comment">//核心</span></span><br><span class="line">  executorService().execute(call);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  readyAsyncCalls.add(call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>executorService方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> ExecutorService <span class="title">executorService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (executorService == <span class="keyword">null</span>) &#123;</span><br><span class="line">    executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(<span class="string">&quot;OkHttp Dispatcher&quot;</span>, <span class="keyword">false</span>));<span class="comment">//注意这里使用的是SynchronousQueue 同步队列</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//类似单例？</span></span><br><span class="line">  <span class="keyword">return</span> executorService;</span><br></pre></td></tr></table></figure><ol><li><p>ExecutorService</p><p>interface  extends Executor Executor只有一个方法execute</p><p>这里使用的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                            TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                            BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          //注意是Blockqueue</span></span></span><br><span class="line"><span class="function"><span class="params">                            ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">           threadFactory, defaultHandler);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>BlockingQueue  缓存放不下时候的线程</p><ul><li><p>为什么这里用Synchonrous队列？</p></li><li><p>为什么new的ThreadPoolExectuor核心线程数为 0</p><p>线程池概念，减少频繁创建销毁的耗时过程</p></li></ul><ol><li>```java<br>public void execute(Runnable command) {<pre><code>//任务不能为空if (command == null)    throw new NullPointerException();//获取线程状态int c = ctl.get();//1. if (workerCountOf(c) &lt; corePoolSize) &#123;    if (addWorker(command, true))        return;    //添加线程失败    c = ctl.get();&#125;//2.//如果线程池状态是RUNNING 并且任务成功添加到workQueue中if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;    //再次检查    int recheck = ctl.get();    //2.1如果线程池状态线程池是`SHUTDOWN`了，并且能成功的把任务从队列中移除    if (! isRunning(recheck) &amp;&amp; remove(command))        //拒绝任务        reject(command);    //2.2任务加入到队列了，但是当前没有工作线程就添加一个线程    else if (workerCountOf(recheck) == 0)        addWorker(null, false);&#125;//3. else if (!addWorker(command, false))    reject(command);</code></pre>}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">         </span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">3. AsyncCall</span><br><span class="line"></span><br><span class="line">   final class 、 extends NamedRunnable</span><br><span class="line"></span><br><span class="line">   &#96;&#96;&#96;java</span><br><span class="line">   final class AsyncCall extends NamedRunnable &#123;</span><br><span class="line">     private final Callback responseCallback;</span><br><span class="line">     private final boolean forWebSocket;</span><br><span class="line">   </span><br><span class="line">     private AsyncCall(Callback responseCallback, boolean forWebSocket) &#123;</span><br><span class="line">       super(&quot;OkHttp %s&quot;, originalRequest.url().toString());</span><br><span class="line">       this.responseCallback &#x3D; responseCallback;</span><br><span class="line">       this.forWebSocket &#x3D; forWebSocket;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol></li><li><p>NamedRunnable</p><p>abstract class implments Runnable</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> String name;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NamedRunnable</span><span class="params">(String format, Object... args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = String.format(format, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  String oldName = Thread.currentThread().getName();</span><br><span class="line">  Thread.currentThread().setName(name);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    execute();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    Thread.currentThread().setName(oldName);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>Request</p><p>理解Builder的设计思想</p></li><li><p>Call</p><p>基本的回调接口类</p><p>request 、execute、 enqueue、cancel、isExcuted、isCancled</p></li><li><p>Callback</p></li><li><p>Async</p></li></ol><h4><span id="流程分述">流程分述</span></h4><h5><span id="1-如何发送">1. 如何发送</span></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">okHttpClient.newCall(request).enqueue(<span class="keyword">new</span> Callback() &#123;&#125;);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> RealCall(<span class="keyword">this</span>, request);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback, <span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Already Executed&quot;</span>);</span><br><span class="line">      executed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    client.dispatcher().enqueue(<span class="keyword">new</span> AsyncCall(responseCallback, forWebSocket));</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">return</span> dispatcher;</span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">      runningAsyncCalls.add(call);</span><br><span class="line">      executorService().execute(call);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      readyAsyncCalls.add(call);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> ExecutorService <span class="title">executorService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (executorService == <span class="keyword">null</span>) &#123;</span><br><span class="line">      executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">          <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(<span class="string">&quot;OkHttp Dispatcher&quot;</span>, <span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> executorService;</span><br><span class="line">  &#125;</span><br><span class="line">ThreadPoolExecutor.execute();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5><span id="2-被谁处理">2. 被谁处理</span></h5><h5><span id="3-如何维护">3. 如何维护</span></h5><h5><span id="4-建造者模式">4. 建造者模式</span></h5><p>不需要关注细节，定制、默认</p><p>链式编程   —return this</p><h5><span id="5-责任链模式">5. 责任链模式</span></h5><h3><span id="retrofit">Retrofit</span></h3><h4><span id="好处">好处</span></h4><p>Retrofit基于okhttp封装的网络请求框架, 网络请求的工作本质上是 OkHttp 完成，而 retrofit 仅负责网络请求接口的封装。</p><p>Retrofit优势，就是简洁易用,解耦,扩展性强,可搭配多种Json解析框架(例如Gson),另外还支持RxJava.网络请求的工作本质上是 <code>OkHttp</code> 完成，而 Retrofit 仅负责 网络请求接口的封装</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210322153358168.png" alt="image-20210322153358168"></p><p>注解类型</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210322153735717.png" alt="image-20210322153735717"></p><p>Retrofit不做网络请求，他相当于是一个中间人</p><p>通过接口，对接口方法进行注解</p><h4><span id="原理">原理</span></h4><h5><span id="动态代理">动态代理</span></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INetApiService netApiService= retrofit.create(INetApiService.class);</span><br></pre></td></tr></table></figure><p>这里得到的netApiService不是本尊，而只是一个动态代理对象</p><h4><span id="类">类</span></h4><p><strong>Platform</strong></p><p><strong>ServiceMethod</strong>  一个~代表一个请求接口</p><p><strong>CallAdapter</strong></p><p>具体类型不同的adapter  Rxjava Gson Java8 guava rxjava…</p><h4><span id="设计模式">设计模式</span></h4><p>动态代理</p><p>工厂模式</p><p>建造者模式</p><p>外观模式</p><h4><span id="差异">差异</span></h4><p>Retrofit的Call 支持泛型，也就是可以用一个bean类进行包装，然后通过GSON直接返回想得到的对象？</p><h4><span id="问题">问题</span></h4><p>为什么请求在子线程而显示在UI主线程？ 添加了Looper？</p><h3><span id="volley">Volley</span></h3><h3><span id="图片加载框架">图片加载框架</span></h3><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210329094112507.png" alt="image-20210329094112507"></p><h3><span id="glide">Glide</span></h3><p><strong>load</strong></p><p>空白fragment  – 控制生命周期</p><p>为什么Glide不能在子线程中绘制</p><p>子线程中不会添加生命周期机制  主线程才会对空白的fragment监听activiyty  fragment变化</p><p>RequestBuilder</p><p>Retriver</p><p>单例模式</p><p><strong>with</strong></p><p>类型转换</p><p><strong>into</strong></p><p>克隆模式</p><p>享元模式 – SingleRequest.obtain</p><p>Enging层</p><p>运行缓存：   活动缓存（面向用户） – 内存缓存（活动缓存的二级缓存）</p><p>检测有没有正在执行的缓存可用（磁盘缓存）</p><p>网络请求</p><p>高层设计：</p><p>接口 </p><p><strong>生命周期</strong></p><p>LifeCycleListener接口</p><p>空白Fragment附着在activity  监听生命周期</p><p>RequestManager 控制 生命周期 onstart方法中有对targetTracker、 requestTracker的生命周期方法调用</p><p>设计模式</p><h4><span id="from">from</span></h4><h4><span id="load">load</span></h4><h4><span id="into">into</span></h4><h3><span id="面试问题">面试问题</span></h3><h4><span id="为什么子线程不能更新ui">为什么子线程不能更新UI</span></h4><p>原因： ViewRootIml.scheduleTraversals对view进行绘制前，对当前线程进行检查是不是主线程</p><p>，多线程加载Ui使得资源抢占，界面更新混乱</p><p>runOnUiThread的作用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Thread.currentThread() != mUiThread) &#123;</span><br><span class="line">    <span class="comment">//发送消息到主线程的消息队列中</span></span><br><span class="line">    mHandler.post(action);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果是主线程，则直接执行</span></span><br><span class="line">    action.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="viewpost-和-handlerpost的区别">View.post 和 Handler.post的区别</span></h4><p>在Oncreate里直接调用View.getWidth或者View.getMeasuredWidth返回都是0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AttachInfo attachInfo = mAttachInfo;</span><br><span class="line">    <span class="comment">//当前view加入到window中，则直接用ui线程的handler发送消息</span></span><br><span class="line">    <span class="keyword">if</span> (attachInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> attachInfo.mHandler.post(action);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Postpone the runnable until we know on which thread it needs to run.</span></span><br><span class="line">    <span class="comment">// Assume that the runnable will be successfully placed after attach.</span></span><br><span class="line">    <span class="comment">//没有加入到wndow中，放入viewrootimpl的Runqueue中</span></span><br><span class="line">    getRunQueue().post(action);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果View尚未attach到window的话，runnable被放到了ViewRootImpl#RunQueue中，最终也会被处理，但不是通过MessageQueue。</p><p>而是等到ViewRootImpl的下一个performTraversals时候，把RunQueue里的所有runnable都拿出来并执行</p><h4><span id="gradle到底是个啥">Gradle到底是个啥</span></h4><h2><span id="mysql">Mysql</span></h2><h3><span id="引擎">引擎</span></h3><h4><span id="myiasm">MyIAsm</span></h4><h4><span id="inoodb">Inoodb</span></h4><h3><span id="索引">索引</span></h3><h4><span id="myiasm和inoodb的不同">MyIAsm和Inoodb的不同</span></h4><h2><span id="计算机原理">计算机原理</span></h2><h2><span id="面试">面试</span></h2><p><strong>系统按什么规则回收后台的app</strong></p><p><a href="https://blog.csdn.net/u010227042/article/details/108451297?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161715872916780264092268%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=161715872916780264092268&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-1-108451297.pc_search_result_hbase_insert&amp;utm_term=%E7%B3%BB%E7%BB%9F%E6%8C%89%E4%BB%80%E4%B9%88%E8%A7%84%E5%88%99%E5%9B%9E%E6%94%B6%E5%90%8E%E5%8F%B0%E7%9A%84app">https://blog.csdn.net/u010227042/article/details/108451297?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161715872916780264092268%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=161715872916780264092268&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-1-108451297.pc_search_result_hbase_insert&amp;utm_term=%E7%B3%BB%E7%BB%9F%E6%8C%89%E4%BB%80%E4%B9%88%E8%A7%84%E5%88%99%E5%9B%9E%E6%94%B6%E5%90%8E%E5%8F%B0%E7%9A%84app</a></p><p><strong>操作系统的IO模型</strong></p><p><strong>Java IO 设计模式</strong></p><p><strong>Linux Unix 区别</strong></p><p><strong>浏览器输入url发生了肾么事</strong></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="2021/01/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>2021/01/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1><span id="设计模式">设计模式</span></h1><h2><span id="单例模式">单例模式</span></h2><ol><li><p>DCL</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//DCL </span></span><br><span class="line">    <span class="comment">//volatile解决有序性问题</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line">    <span class="comment">//私有化构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="comment">//注意这里的双重判断  避免多线程时已经进入第一层</span></span><br><span class="line">                <span class="keyword">if</span>(singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最简单</p><p>静态  一开始便装载</p></li><li><p>静态内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">//静态内部类不会再一开始就被装载，无内存消耗</span></span><br><span class="line">    <span class="comment">//JVM装载静态内部类是线程安全的？？？</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>枚举Enum</p></li></ol><h3><span id="消费者生产者">消费者生产者</span></h3><p>平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率</p><p>实现 </p><ol><li>wait</li><li>Lock</li><li>BlockingQueue</li></ol><p>为什么用while 不用 if？</p><p>while 自旋锁，防止虚假唤醒</p><h3><span id="虚假唤醒">虚假唤醒</span></h3><p>虚假唤醒就是一些obj.wait()会在除了obj.notify()和obj.notifyAll()的其他情况被唤醒</p><p>举个例子，我们现在有一个生产者-消费者队列和三个线程。</p><p><strong>1）</strong> 1号线程从队列中获取了一个元素，此时队列变为空。</p><p><strong>2）</strong> 2号线程也想从队列中获取一个元素，但此时队列为空，2号线程便只能进入阻塞(cond.wait())，等待队列非空。</p><p><strong>3）</strong> 这时，3号线程将一个元素入队，并调用cond.notify()唤醒条件变量。</p><p><strong>4）</strong> 处于等待状态的2号线程接收到3号线程的唤醒信号，便准备解除阻塞状态，执行接下来的任务(获取队列中的元素)。</p><p><strong>5）</strong> 然而可能出现这样的情况：当2号线程准备获得队列的锁，去获取队列中的元素时，此时1号线程刚好执行完之前的元素操作，返回再去请求队列中的元素，1号线程便获得队列的锁，检查到队列非空，就获取到了3号线程刚刚入队的元素，然后释放队列锁。</p><p><strong>6）</strong> 等到2号线程获得队列锁，判断发现队列仍为空，1号线程“偷走了”这个元素，所以对于2号线程而言，这次唤醒就是“虚假”的，它需要再次等待队列非空。</p><h3><span id="blockingqueue的实现">BlockingQueue的实现</span></h3><h2><span id="责任链模式">责任链模式</span></h2><h2><span id="建造者模式">建造者模式</span></h2><h2><span id="单例模式">单例模式</span></h2><h2><span id="工厂模式">工厂模式</span></h2><h3><span id="简单工厂模式">简单工厂模式</span></h3><h3><span id="抽象工厂模式">抽象工厂模式</span></h3><h2><span id="外观模式">外观模式</span></h2><p><strong>主要解决：</strong>降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用</p><p><strong>何时使用：</strong> 1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个”接待员”即可。 2、定义系统的入口。</p><p>缺点： 不符合开闭原则，如果要改东西很麻烦，继承重写都不合适</p><p><a href="https://www.runoob.com/design-pattern/facade-pattern.html">https://www.runoob.com/design-pattern/facade-pattern.html</a></p><h2><span id="代理模式">代理模式</span></h2><p>结构型模式  一个类代表另一个类的功能</p><p><strong>意图：</strong>为其他对象提供一种代理以控制对这个对象的访问。</p><p><strong>主要解决：</strong>在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），<strong>直接访问会给使用者或者系统结构带来很多麻烦</strong>，我们可以在访问此对象时加上一个对此对象的访问层。</p><h3><span id="静态代理">静态代理</span></h3><p>业务接口 — &gt; 基本实现类  —&gt; 代理类</p><p>缺点： 代码重复 、 为单一类型对象服务</p><h3><span id="动态代理">动态代理</span></h3><p>业务接口 —&gt; 基本实现类 — &gt;动态代理类</p><p>核心 InvocationHandler</p><h2><span id="享元模式">享元模式</span></h2><h2><span id="适配器模式">适配器模式</span></h2><p>两个接口的桥梁 — 电源适配器  </p><p>Target – Adaptee – Adapter</p><p>一个事物本来已经很好了，但是找不到合适的对象去对接，（新老版本更替，老版本/新版本如何适配）</p><p>提高了类的复用，让没有关联的两个类一起运行，无层级关系</p><h3><span id="javaio-适配器模式和装饰者模式的区别">JavaIO 适配器模式和装饰者模式的区别</span></h3><p>InputStreamReader继承了Reader抽象类并实现，且持有了InputStream的引用，这里是通过StreamDecoder类间接持有的，因为从byte到char要经过编码。<br>很显然，适配器就是InputStreamReader，源角色就是InputStream代表的实例对象，目标接口就是Reader类。OutputStreamWriter 也类似。</p><p>InputeStream 类就是以抽象组件存在的：而FileInputStream就是具体组件，它实现了抽象组件的所有接口；FilterInputStream类无疑就是装饰角色，它实现了InputStream类的所有接口，并且持有InputStream的对象实例的引用；<br>BufferedInputStream是具体的装饰器实现者，它给InputStream类附加了功能，这个装饰器类的作用就是使得InputStream读取的数据保存在内存中，而提高读取的性能。与这个装饰器类有类似功能的还有LineNumberInputStream（java 1.8 已经过期）类，它的作用就是提高行按行读取数据的功能，它们都是InputStream类增强了功能，或者提升了性能。</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210331230002191.png" alt="image-20210331230002191"></p><h2><span id="装饰者模式">装饰者模式</span></h2><p>向一个现有的对象添加新的功能，同时不改变其结构，作为现有类的一个包装，动态扩展一个实现类的功能</p><p>component : 抽象组件角色，定义一组抽象的接口，规定这个被装饰组件都有哪些功能<br>concreteComponent：实现这个抽象组件的所有功能。<br>Decorator：装饰器角色，它持有一个component对象实例的引用，定义一个与抽象组件一致的接口<br>ConcreteDecorator：具体的装饰器实现者，负责实现装饰器角色定义的功能</p><h3><span id="mvp到底有什么什么作用怎么解耦的">mvp到底有什么什么作用？怎么解耦的？</span></h3>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安卓数独游戏UI设计</title>
      <link href="2020/12/23/%E5%AE%89%E5%8D%93%E6%95%B0%E7%8B%AC%E6%B8%B8%E6%88%8F%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91/"/>
      <url>2020/12/23/%E5%AE%89%E5%8D%93%E6%95%B0%E7%8B%AC%E6%B8%B8%E6%88%8F%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1><span id="sudoku-game">Sudoku Game</span></h1><!-- toc --><ul><li><a href="#introduce">Introduce</a><ul><li><a href="#preview">Preview</a></li></ul></li><li><a href="#ui-settings">UI Settings</a><ul><li><a href="#previous-thoughtavoid-delay">Previous Thought（avoid delay）</a></li><li><a href="#better-way-improve-user-experience">Better Way (Improve User Experience)</a></li><li><a href="#thoughts-of-afterclass-improvement">Thoughts of Afterclass Improvement</a></li></ul></li><li><a href="#using-of-class">Using of Class</a></li><li><a href="#algorithm-use">Algorithm Use</a><ul><li><a href="#previous-thoughts-and-problem">Previous Thoughts And Problem :</a></li><li><a href="#after-improvement">After Improvement :</a></li></ul></li><li><a href="#things-can-be-better">Things can be better</a></li><li><a href="#thanks">Thanks :</a></li></ul><!-- tocstop --><p>[toc]</p><hr><h2><span id="introduce">Introduce</span></h2><ul><li>A conventional sudoku game with 9*9 blocks using Java and through Android Studio.</li><li>As for the specific operation rule of this game , you need to first press the blocks above the 9*9 matrix blocks, and drug it to the ‘?’ or the block you want to change (not including the original array) .</li><li>click the “SHOWANSWER”  button , the complete correct Sudoku matrix will show on the screen ,with the imgs on the unknown blocks bling twice<span id="more"></span><h3><span id="preview">Preview</span></h3></li></ul><p> <img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/mainScreen.png" alt="hh"> <img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/levelSelect.png" alt="levelSelect"><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/gameScreen.png"><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/answerShow.png" alt="answerShow"><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/records.png" alt="records"><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/record_2.png" alt="record_2"><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/record_3.png" alt="record_3"></p><h2><span id="ui-settings">UI Settings</span></h2><h3><span id="previous-thoughtavoid-delay">Previous  Thought（avoid delay）</span></h3><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20201220105134759.png" alt="image-20201220105134759"></p><ul><li>9*9 Blocks Design  :  It’s certain to abandon statically add ImageView to the parent view. So First I was thinking to use GridLayout, and dynamically generate  81 ImageViews inside it . It worked  , but hearing that recyclerview can save some storage using ..?(not so sure),so I turn my side to Recyclerview.But it proves that in a way it’s actually better ,at least I don’t need to care about the dividing line …  </li><li>Game-Run Rules  :  In the  first , the action that moving finger on screen to dynamically set the block position of choosing number may be a delayed process ( After that , it proves that I was wrong . Delay is just the images is too big…). So I choose to a rule when click a number above  , and click again the blocks below ,to fill the 9x9 blocks . But this method is just a conventional way ,not attractive enough</li></ul><h3><span id="better-way-improve-user-experience">Better Way (Improve User Experience)</span></h3><ul><li>So after I ran through the delayed problem and adjusted the imgs to a much smaller size.(from 800 kb to 4kb per Images….) , I go back to my first strategy, to timely let the block move with your finger. And when your finger get up ,it will be removed from parent views ,and there will be a judge about its position. </li></ul><h3><span id="thoughts-of-afterclass-improvement">Thoughts of Afterclass Improvement</span></h3><ul><li>maybe some ugly button imgs can be changed?</li><li>packages classification</li><li>MVC model </li></ul><h2><span id="using-of-class">Using of Class</span></h2><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20201219223339691.png" alt="image-20201219223339691"></p><ul><li><p>MainActivity:  handling LegacyRequest   , LitePal Connect and some Ui settings</p></li><li><p>AboutActivity: developer information  and Lottie Animation</p></li><li><p>RecordBitmap: a bean class with some necessary data of a complete game record , including view bitmaps, dates ,completion date…..</p></li><li><p>LevelChoosePanel: a Ui class for Level-Choose-Panel Ui layout</p></li><li><p>WrongBorder : a Ui class for a  border view when detecting answer is wrong.</p></li><li><p>RecordShowActivity: handling Records show page , including a recyclerview layout .</p></li><li><p>recycleutil:  Recyclerview Adapter and Decoration for its Ui setting.</p></li><li><p><strong>GamingActivity:</strong>  most important activity in this project. including  handling logically generate 9*9 Sudoku matrix, dynamically generate 9x9Ui Blocks(ImageView actually) and check wrong blocks in real time. Also handling gesture listener including finger DOWN , MOVE and UP .  </p></li><li><p><strong>SudoHelper</strong> : core algorithm handling module class , to generate a 9*9 Sudoku with only one answer ,and detect validity of current 9x9 Matrix</p></li></ul><h2><span id="algorithm-use">Algorithm Use</span></h2><h3><span id="previous-thoughts-and-problem">Previous Thoughts And Problem :</span></h3><ul><li>Previously , I was thinking to use a way of generation method with not-only answer. The method is quite easy. First to choose N (N=30) blocks , each row , column and numbers inside it is random on the condition that it matches the rules of Sudoku. And them use backTrace Method to fill other blocks remaining. And when to judge in the gameActivity , we just need to use the <strong>isValid()</strong> method to detect if this column &amp; row &amp; 3*3 matrix around it fit the rules , if not , that’s wrong. Thus it may provide different answers, due to detecting the 9x9 matrix it provides in the first step.</li></ul><h3><span id="after-improvement">After Improvement :</span></h3><ul><li><p>As seeing more, a standard Sudoku is a 9*9 Matrix with only one answer. So , to improve this , I use two types of buckTrace() method , difference is if it changes the origin matrix it gives. </p></li><li><p>So , first We randomly choose N different block , and under the rules, filling it with random number. Then using the original backTrace()  method (changes params it gives in). We get a correct 9x9 Sudoku Matrix. And then, we dig put specific numbers of blocks . In each digging process ,we detect that besides the original number in the matrix ,if there’s other number that could make current matrix be a standard matrix . If not , we can safely dig out this number ,and go further , else ,we may need to change the position （generate row and column randomly again）,until we dig out enough numbers of blocks . We get a matrix with only one answer.</p></li><li><p>Some optimization thoughts: if some time , the matrix is not good. Maybe we randomly find many blocks ,but it still can’t be dug out .Therefore ,we may need to go back in the first step, generating a new matrix and do the works below. So we can set a number to record the failed dig-out search , if the number is bigger than a certain number , we re-generate it . So ,in some case ,it may avoid time consuming work inside this methods.</p></li></ul><h2><span id="things-can-be-better">Things can be better</span></h2><ul><li>Ui , have to say , the Ui design is really so so…But time is catching up , no time for that . So sometime Ui need to be modified.</li></ul><h2><span id="thanks">Thanks :</span></h2><ul><li><p>Sincerely thanks for watching this. If any details and humble opinion could contribute to your thoughts , I would be content. And if you have any advice or doubts , welcome to put it there.</p></li><li><p>Contact : <a href="mailto:&#x34;&#x30;&#x31;&#x31;&#x37;&#x37;&#x39;&#x32;&#51;&#x40;&#113;&#x71;&#46;&#x63;&#111;&#109;">&#x34;&#x30;&#x31;&#x31;&#x37;&#x37;&#x39;&#x32;&#51;&#x40;&#113;&#x71;&#46;&#x63;&#111;&#109;</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 个人项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OOP复习</title>
      <link href="2020/12/23/OOP%E5%A4%8D%E4%B9%A0/"/>
      <url>2020/12/23/OOP%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1><span id="oop复习-指北">OOP复习 指北</span></h1><ol><li><p>工厂方法               P117</p></li><li><p>静态boolean 为false main方法中的boolean  没有初始值</p></li><li><p>this 在一个构造器中调用另一个构造器方法</p></li><li><p>静态初始化块 运行次序高于初始化块 且随着第一个类对象的创立只运行一次，且调用程序的静态方法，不创建对象时，该static 方法体也会被执行，仅执行一次。初始化块的运行次序 高于 构造器方法,不论放置的次序如何。</p><p>执行顺序: 父类的静态方法—-&gt;子类的静态方法—-&gt; 父类的构造—-&gt;子类的构造..</p><p>单个类：静态初始化块–&gt;成员变量初始化—&gt;块作用域—&gt;构造方法</p><span id="more"></span><p>先 进行属性的初始化  在进行构造方法的初始化</p><p>继承关系时的调用次序：特殊</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=getA();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father static&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father &#123;&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father public &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father propertiyu a&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>  <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20201118083928612.png" alt="image-20201118083928612"></p></li><li><p>类对象属性 有初始值  0 false null</p></li><li><p>静态导入                  P136</p></li><li><p>继承            P162</p></li><li><p>签名和可协变、静态绑定 和动态绑定                              P164</p></li><li><p>final 类中的所有方法自动变为final 方法</p></li><li><p>instanceof 是判断其 是否是 该类或者该类的子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Son() <span class="keyword">instanceof</span> Father</span><br><span class="line">    <span class="comment">//注意使用instance的方式</span></span><br></pre></td></tr></table></figure></li><li><p>类型强转只在继承层次关系进行，否则会报错</p></li><li><p>父类可以有实现的方法和字段，也可以没有抽象方法，但抽象方法必须在子类中实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Man m=<span class="keyword">new</span> Male();</span><br><span class="line"><span class="comment">//定义抽象类的对象变量，但这样是无法调用子类的特殊方法的，这里注意多态性的体现</span></span><br></pre></td></tr></table></figure></li><li><p>除基本类型外，都是对象，数组也是对象</p></li><li><p>ArrayList  set add 方法的区别，以及不用泛型时 返回的是Object对象</p></li><li><p>包装： 一旦构造了包装器就不能改变贮藏在其中的值</p><p>包装类的 自动装箱和自动拆箱</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer a=<span class="number">1000</span>;</span><br><span class="line">        Integer b=<span class="number">1000</span>;</span><br><span class="line">        Integer c=<span class="number">2000</span>;</span><br><span class="line">        b=a;</span><br><span class="line">        a=c;</span><br><span class="line">        System.out.println(b.toString());</span><br><span class="line">        <span class="comment">// b=1000;</span></span><br></pre></td></tr></table></figure></li><li><p>接口 ： 可以有  实例化基本类型  int … 但是实例化接口对象后作为的是static final 常量，不能修改，可以直接通过实现类访问。接口中可以有抽象方法，所有抽象方法必须定义，可以有default 方法，可以有private方法但是private方法必须在接口实现，除private 外 不用加修饰符，默认为public，不允许有块作用域和静态初始化块   default 方法可以在子接口中得到重写，且默认方法可以调用其他方法。</p></li><li><p>内部类中的所有静态字段  必须是final 声明局部内部类时，不能有访问说明符。静态内部类，不会生成引用</p></li><li><p>在try catch 块中catch到异常时， 发生异常处之后的语句都不会执行</p><p>在块中出现没有 catch情况的异常时，会执行 finally 后的语句，但执行完finally后的语句便会返回，不会再try catch-finally块之后的语句了           </p><p>try - with -resources 自动close</p></li><li><p>检查异常和非检查异常</p></li><li><p>String 常量   字符串缓冲池</p><p>[<a href="https://blog.csdn.net/nc_yhy/article/details/78474468?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160561320919724839249458%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=160561320919724839249458&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-78474468.pc_search_result_no_baidu_js&amp;utm_term=String+%E5%B8%B8%E9%87%8F&amp;spm=1018.2118.3001.4449%5D">https://blog.csdn.net/nc_yhy/article/details/78474468?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160561320919724839249458%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=160561320919724839249458&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-78474468.pc_search_result_no_baidu_js&amp;utm_term=String+%E5%B8%B8%E9%87%8F&amp;spm=1018.2118.3001.4449]</a>: </p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20201117194626755.png" alt="image-20201117194626755"></p></li></ol><p>21.嵌套异常详解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> a=<span class="number">3</span>/<span class="number">0</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;after 3/0&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;arit cath&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;inner excption&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;Exception&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;outer exception&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20201117200610606.png" alt="image-20201117200610606"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException();</span><br><span class="line">            <span class="comment">//int a=3/0;</span></span><br><span class="line">            <span class="comment">//System.out.println(&quot;after 3/0&quot;);</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;arit cath&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;inner excption&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Exception&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;outer exception&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20201117201055655.png" alt="image-20201117201055655"></p><p>总结一下： 内层捕获到的excption 在外层不会再捕获，哪怕是父子关系。且不会执行try中之后的语句，而是执行finally的语句</p><ol start="22"><li><p>概念性内容：</p><ol><li>类的特性：</li></ol><ul><li><p>封装：在抽象的基础上把对象的属性和方法组合成一个独立的单位，并尽可能隐藏对象的内部细节。</p></li><li><p>多态：用同一个名字定义不同的方法，这些方法体的语句不同，但实现的功能类似 。即同名的方法可以在不同的类中有不同的行为</p></li><li><p>继承（泛化）：在已有类的基础上派生出新的类，新的类能够继承已有类的属性和方法，并且扩展新的属性和方法。即一个对象从另一个对象获得属性和方法的过程</p></li><li><p>抽象类：一个类中没有包含足够的信息来描绘一个具体的对象</p></li><li><p>类是一组具有相同属性和行为的对象的抽象</p></li></ul><ol start="2"><li><p>对象基本特征</p><p>唯一性   分类性   继承性   多态性</p><p>三大基本特征是 ： 封装继承多态</p></li><li><p>对象要素</p><p>抽象   封装  共享  强调对象结构</p></li><li><p><strong>对象的基本特点</strong>：标识唯一性、分类性、多态性、封装行、模块独立性好；</p></li><li><p>运行过程：</p><p>编辑</p><p>编译：java编译器</p><p>加载：java类加载器  加载到内存</p><p>验证：java验证器</p><p>执行：java类解释器      翻译字节码为可执行的机器代码</p></li><li><p>对象具有 标识符  属性  行为</p></li><li><p>面向对象： 新的软件开发和程序设计技术，认为客观事物都是由对象组成的，对象是在原事物基础上抽象的结果</p></li><li><p>服务：通常被称为 方法 或 结果‘</p></li><li><p>包是java提供的一种区别类的名字控件的极值，是类的组织方式，是一种相关类和接口的集合，提供了访问权限和命名的管理机制。</p></li></ol></li><li><p>接口和继承的不同  接口和抽象类的比较   P149</p><ul><li>继承修改旧的功能，接口实现新的功能</li></ul></li><li><p>使用多态的好处  P138</p><p>可重用性</p><p>可扩充性、可维护性、动态绑定</p></li><li><p>数据库 JDBC用到的四大类</p></li><li><p>UML：</p><ol><li><p>组成：事务 关系  图</p></li><li><p>分类：</p><ol><li><p>用例图：</p><p>简要说明 主事件流和其他事件流  前提条件  事后条件</p></li><li><p>类图：（重要）</p><p>显示了静态结构</p></li><li><p>序列图</p></li><li><p>活动图  P16</p><p>分叉 分支   汇合 合并的区别</p><p>[choice]表示条件</p><p>如何画一个具体的活动图</p></li></ol></li><li><p>三层程序设计模式</p><p>表示层       —-业务逻辑层       —–数据访问层</p><p>GUI                 PD                           DA       class</p><p>分层结构的优势   P25</p></li><li><p>程序设计风格</p><p>可重用性   内 外</p><p>可扩展性</p><p>健壮性</p></li></ol></li><li><p>数组初始化的方式</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20201118151442152.png" alt="image-20201118151442152"></p></li><li><p>三层设计 的好处 目的  区分三层设计和MVC P25 P272</p><p>分层设计： 分散关注 松散耦合  逻辑复用   标准定义</p></li><li><p>HashMap  可以有 不同的键 其值可都为null ，但null的键只能有一个 hashmap中也是无序的</p><p>ArrayList、Vector可以有多个null值 </p><p>HashSet中只有有一个null值</p><p>HashMap的遍历方式  四种</p><p><a href="https://blog.csdn.net/scgyus/article/details/79105211?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160570417819724835825778%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=160570417819724835825778&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-79105211.pc_search_result_no_baidu_js&amp;utm_term=hashmap%E7%9A%84%E9%81%8D%E5%8E%86&amp;spm=1018.2118.3001.4449">https://blog.csdn.net/scgyus/article/details/79105211?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160570417819724835825778%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=160570417819724835825778&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-79105211.pc_search_result_no_baidu_js&amp;utm_term=hashmap%E7%9A%84%E9%81%8D%E5%8E%86&amp;spm=1018.2118.3001.4449</a></p></li><li><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20201119193356887.png" alt="image-20201119193356887"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java表达式是变量、常量、运算符、方法调用的序列，它执行指定的计算并返回某个确定的值。</span></span><br></pre></td></tr></table></figure></li><li><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20201119211925090.png" alt="image-20201119211925090"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安卓数独游戏课设</title>
      <link href="2020/12/22/%E5%AE%89%E5%8D%93%E6%95%B0%E7%8B%AC%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/"/>
      <url>2020/12/22/%E5%AE%89%E5%8D%93%E6%95%B0%E7%8B%AC%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1><span id="数独游戏-回溯算法数据结构课程设计实验报告">数独游戏 (回溯算法)—数据结构课程设计实验报告</span></h1><p>[toc]</p><!-- toc --><ul><li><a href="#%E6%B8%B8%E6%88%8F%E4%BB%8B%E7%BB%8D">游戏介绍</a><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E5%AE%9E%E7%8E%B0%E5%8A%9F%E8%83%BD">实现功能：</a></li><li><a href="#%E6%B8%B8%E6%88%8F%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8E">游戏操作说明：</a></li><li><a href="#%E9%A1%B9%E7%9B%AE%E8%BF%90%E8%A1%8C%E8%AF%B4%E6%98%8E-%E5%A6%82%E6%9E%9C%E9%9C%80%E8%A6%81">项目运行说明 (如果需要)：</a></li></ul></li><li><a href="#%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E6%A0%B8%E5%BF%83%E9%83%A8%E5%88%86">游戏设计理念(回溯算法核心部分)</a><ul><li><a href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3">核心思想：</a></li><li><a href="#isvalid%E6%96%B9%E6%B3%95"><strong>isValid()方法</strong>：</a></li><li><a href="#isonlyone%E6%96%B9%E6%B3%95">isOnlyOne()方法</a></li><li><a href="#generatesudowithlevel%E6%96%B9%E6%B3%95">generateSudoWithLevel()方法</a></li><li><a href="#%E6%B5%81%E7%A8%8B%E6%A6%82%E6%8B%AC">流程概括</a></li><li><a href="#%E5%AE%9E%E9%AA%8C%E6%B5%8B%E8%AF%95-%E5%85%B7%E4%BD%93%E8%80%97%E6%97%B6">实验测试—具体耗时</a></li><li><a href="#%E5%AE%9E%E9%AA%8C%E5%88%86%E6%9E%90">实验分析</a></li></ul></li><li><a href="#%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%85%B6%E4%BB%96%E6%83%B3%E6%B3%95%E5%92%8C%E9%97%AE%E9%A2%98">游戏开发中的其他想法和问题</a></li><li><a href="#%E8%AF%BE%E8%AE%BE%E6%80%BB%E7%BB%93">课设总结</a></li><li><a href="#%E6%84%9F%E8%B0%A2">感谢</a></li></ul><!-- tocstop --><hr><h2><span id="游戏介绍">游戏介绍</span></h2><h3><span id="简介">简介</span></h3><ul><li>传统的数独游戏，采用 9x9 方格，通过填入数字 1-9 ，确保<strong>每行、每列、以及该格所在的 3x3 的方格区域</strong>中 不出现相同的数字。</li><li><strong>每个生成的数独只有一个解</strong></li><li>使用 AndroidStudio 平台开发 ，基于Java语言 <span id="more"></span></li></ul><h3><span id="实现功能">实现功能：</span></h3><ol><li>UI 基本游戏界面的 UI 布局，数独生成与 UI 动态生成的异步处理 ，功能按钮</li><li>AutoDetect 游戏内实时检错并自动删除错误数字</li><li>Show Answer 显示答案功能，动态提示答案</li><li>Reset 重置数独功能，重新生成新的数独</li><li>Timer 计时功能</li><li>Record 记录功能，通过数据库记录每次成功完成数独的题目、答案图像，完成日期，完成时间，以及数独的难度</li></ol><h3><span id="游戏操作说明">游戏操作说明：</span></h3><ul><li>有安卓手机（版本不低于17)：<ol><li>将apk文件  (app-release.apk) 安装至手机，直接启动即可</li><li>进入游戏后，请<strong>先允许该程序访问手机内存</strong>(因为记录保存时要进行数据的存取)，否则程序会自动退出。通过”START”按钮开始游戏，选择难度，进入游戏界面，通过拖动上方较大的1-9的图像，将想要放置的数组拖动到想放置的位置即可。（注：如果是拖动至已生成的原始数独位置，则不会替换为放置的数组，会弹出“The block is origin”提示）。成功完成，则会在中部显示”Congratulation！”的动画提示。</li><li>可通过”RESET”重置该难度下的数独，通过”BACK”返回到游戏主界面，通过“SHOWANSWER”查看答案</li><li>在主界面的Records按钮点击后，可查看已有的记录，通过左右滑动可查看。如果没有记录，则不会显示。</li></ol></li><li>没有安卓手机：<ol><li>麻烦老师在PC端下载安卓模拟器，然后将该apk安装至电脑的安卓模拟器中运行（由于兼容问题可能会出现一些异常)。</li><li>游戏内操作步骤同上2-4步。</li></ol></li></ul><p><strong>我自己的测试视频放在了主目录下，如果以上两种情况下都不能运行，可以看我的演示视频。</strong></p><h3><span id="项目运行说明-如果需要">项目运行说明 (如果需要)：</span></h3><ul><li><p><strong>JDK :1.8         API :Android 30 Platform</strong></p></li><li><p>下载Android Studio (3.6版本及以上) 官网地址<a href="https://developer.android.google.cn/studio/(%E5%AE%89%E8%A3%85%E5%8C%85800M%EF%BC%8C%E8%BF%99%E9%87%8C%E4%B8%8D%E7%BB%99%E5%87%BA)">https://developer.android.google.cn/studio/(安装包800M，这里不给出)</a></p></li><li><p>左上角 ”File“ –”Open“–选择项目文件夹   可以连接安卓手机(需要打开调试模式)，也可以下载Android Studio平台下的安卓手机模拟器(AVD manager —Create New Virtual Device)</p></li><li><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20201222225942614.png" alt="image-20201222225942614"></p></li></ul><h2><span id="游戏设计理念回溯算法核心部分">游戏设计理念(回溯算法核心部分)</span></h2><p><strong>核心算法区域： “\app\src\main\java\com\example\sudoku”下的SudoHelper.java文件中</strong></p><h3><span id="核心思想">核心思想：</span></h3><pre><code>1. 先通过随机数，生成有n个元素的（n=30）残缺的数组2. 通过solveSudoku()将残缺数组生成完整的数独3. 将完整的数独进行挖取，每挖一个元素都要确保该位置上的元素不能由其他元素替换</code></pre><h3><span id="isvalid方法"><strong>isValid()方法</strong>：</span></h3><ul><li><p>说明： 该方法用于判断数组中该行该列 填入数字c 时，是否在该行所有元素、该列所有元素或者该3*3区域中有与c相同的元素，如果有，则说明违反了规则，返回false;</p></li><li><p>```java<br> /**</p><pre><code> * 判断该二维数组中 row行 col列中填入数字c是否违反规则 * @param board 原始的二维数组 * @param row   该数字c的行数 * @param col   数字c的列数 * @param c     数字c * @return */public static boolean isValid(int[][] board, int row, int col, int c) &#123;    for (int i = 0; i &lt; 9; i++) &#123;        //当前列有没有和数字c重复的        if (board[i][col] == c)            return false;        //当前行有没有和数字c重复的        if (board[row][i] == c)            return false;        //当前的3*3单元格内是否有和数字c重复的        if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)            return false;    &#125;    //否则说明没有重复数字，符合规则    return true;&#125;</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### **backTrace()方法**</span><br><span class="line"></span><br><span class="line">* 说明：通过迭代进行数独的判断，由不完整的数独生成完整的数独</span><br><span class="line"></span><br><span class="line">* &#96;&#96;&#96;java</span><br><span class="line">  public static boolean backTrace(int[][] board, int row, int col,int num,int spr,int spc) &#123;</span><br><span class="line">          &#x2F;&#x2F;当row等于board.length的时候表示数独的最后一行全部读遍历完了，说明数独中的值是有效的，直接返回true</span><br><span class="line">          if (row &#x3D;&#x3D; board.length)</span><br><span class="line">              return true;</span><br><span class="line">          &#x2F;&#x2F;如果当前行的最后一列也遍历完了，就从下一行的第一列开始。这里的遍历</span><br><span class="line">          &#x2F;&#x2F;顺序是从第1行的第1列一直到最后一列，然后第二行的第一列一直到最后</span><br><span class="line">          if (col &#x3D;&#x3D; board.length)</span><br><span class="line">              return backTrace(board, row + 1, 0,num,spr,spc);</span><br><span class="line">          &#x2F;&#x2F;如果当前位置已经有数字了，就不能再填了，直接到这一行的下一列</span><br><span class="line">          if (board[row][col] !&#x3D; 0)</span><br><span class="line">              return backTrace(board, row, col + 1,num,spr,spc);</span><br><span class="line">          &#x2F;&#x2F;如果上面条件都不满足，就从1到9种选择一个合适的数字填入到数独中</span><br><span class="line">          for (int i &#x3D; 1; i &lt;&#x3D; 9; i++) &#123;</span><br><span class="line">              &#x2F;&#x2F;判断当前位置[row，col]是否可以放数字i，如果不能放再判断下一个能不能放</span><br><span class="line">              &#x2F;&#x2F;r行c列已经不能再填入num了，用于isOnlyOne方法</span><br><span class="line">              if(i&#x3D;&#x3D;num&amp;&amp;spr&#x3D;&#x3D;row&amp;&amp;spc&#x3D;&#x3D;col)</span><br><span class="line">                  continue;</span><br><span class="line">              if (!isValid(board, row, col, i))</span><br><span class="line">                  continue;</span><br><span class="line">              &#x2F;&#x2F;如果能放数字i，就把数字i放进去</span><br><span class="line">              board[row][col] &#x3D; i;</span><br><span class="line">              &#x2F;&#x2F;如果成功就直接返回，不需要再尝试了</span><br><span class="line">              if (backTrace(board, row, col,num,spr,spc))</span><br><span class="line">                  return true;</span><br><span class="line">              &#x2F;&#x2F;否则就撤销重新选择</span><br><span class="line">              board[row][col] &#x3D; 0;</span><br><span class="line">          &#125;</span><br><span class="line">          &#x2F;&#x2F;如果当前位置[row，col]不能放任何数字，直接返回false</span><br><span class="line">          return false;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li></ul><h3><span id="isonlyone方法">isOnlyOne()方法</span></h3><ul><li><p>说明：判断该行该列上的数字，是否能被其他1-9的数字替代，且不违反规则</p></li><li><p>```java<br> /**</p><pre><code> * 判断该行该列上的数字，是否能被其他1-9的数字替代，且不违反规则 * @param i 行数 * @param j 列数 * @param b 二维数组 * @return */public static boolean isOnlyOne(int i,int j,int[][] b)&#123;  //判断在i,j挖去数字后是否有唯一解    int k=b[i][j];  //保存待挖洞的原始数字    for(int num=1;num&lt;10;num++)&#123;        b[i][j]=0;        if(num!=k&amp;&amp;solveSudoku_noChange(b,k))&#123;     //除待挖的数字之外，还有其他的解，则返回false            b[i][j]=k;            return false;        &#125;    &#125;    return true;     //只有唯一解则返回true&#125;</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### solveSudoku方法()</span><br><span class="line"></span><br><span class="line">* 说明： 用于判断不完整的board数组能否生成为二维数独，如果能，则返回true，且会更改board的元素值，num作为isOnlyOne()方法中的特殊判断条件，检验除了num数字，其他数字是否能填入数组使之构成数独。</span><br><span class="line"></span><br><span class="line">* solveSudoku_noChange() 功能与solveSudoku()方法一致，区别是不更改参数board二维数组的值，仅给出是否能生成数独的结果。</span><br><span class="line"></span><br><span class="line">* &#96;&#96;&#96;java</span><br><span class="line">   &#x2F;&#x2F;num 用做isOnlyOne()的特殊判断标志</span><br><span class="line">      &#x2F;&#x2F;spr spc表示表示该位置上的元素不能填入num值</span><br><span class="line">      public static boolean solveSudoku(int[][] board,int num,int spr,int spc) &#123;</span><br><span class="line">          return backTrace(board, 0, 0,num,spr,spc);</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      public static boolean solveSudoku_noChange(int[][] board,int num,int spr,int spc) &#123;</span><br><span class="line">          int temp[][]&#x3D;new int[9][9];</span><br><span class="line">          for(int i&#x3D;0;i&lt;9;i++)&#123;</span><br><span class="line">              System.arraycopy(board[i],0,temp[i],0,9);</span><br><span class="line">          &#125;</span><br><span class="line">          return backTrace(temp, 0, 0,num,spr,spc);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li></ul><h3><span id="generatesudowithlevel方法">generateSudoWithLevel()方法</span></h3><ul><li>说明：通过传入参数 int level，生成解法唯一的残缺数独</li><li>流程图：完整图片文件在源文件中</li><li><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="算法流程图"></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] generateSudoWithLevel(<span class="keyword">int</span> level)&#123;</span><br><span class="line">     <span class="keyword">int</span> temp[][]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">     Random rand=<span class="keyword">new</span> Random();</span><br><span class="line">     <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">     <span class="comment">//对不同难度进行挖取个数count的选择</span></span><br><span class="line">     <span class="keyword">switch</span> (level)&#123;</span><br><span class="line">         <span class="keyword">case</span> LEVEL_NORMAL:</span><br><span class="line">             count = <span class="number">25</span>;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> LEVLE_EASY:</span><br><span class="line">             count = <span class="number">20</span>;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> LEVLE_DIF:</span><br><span class="line">             count = <span class="number">35</span>;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> calloc_num = <span class="number">30</span>;    <span class="comment">//最初挖取的次数</span></span><br><span class="line">     <span class="keyword">int</span> count_fresh = <span class="number">0</span>;    <span class="comment">//重新寻找次数</span></span><br><span class="line">     <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">     <span class="keyword">do</span> &#123;</span><br><span class="line">         <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">             <span class="keyword">while</span> (calloc_num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                 <span class="keyword">int</span> i = rand.nextInt(<span class="number">9</span>);</span><br><span class="line">                 <span class="keyword">int</span> j = rand.nextInt(<span class="number">9</span>);</span><br><span class="line">                 <span class="keyword">if</span> (temp[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                     <span class="keyword">int</span> num = rand.nextInt(<span class="number">9</span>) + <span class="number">1</span>;</span><br><span class="line">                     <span class="keyword">if</span> (isValid(temp, i, j, num)) &#123;</span><br><span class="line">                         temp[i][j] = num;</span><br><span class="line">                         calloc_num--;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//如果能生成完整的数独 则退出循环进行下一步</span></span><br><span class="line">             <span class="keyword">if</span> (solveSudoku(temp, <span class="number">0</span>,-<span class="number">1</span>,-<span class="number">1</span>)) <span class="keyword">break</span>;</span><br><span class="line">             <span class="comment">//否则重新开始</span></span><br><span class="line">             calloc_num = <span class="number">30</span>;</span><br><span class="line">             temp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//对完整的数独进行挖取，并确保每一次挖取的元素不能被其他数字替代</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count + <span class="number">1</span>; i++) &#123;</span><br><span class="line">             <span class="keyword">int</span> r = rand.nextInt(<span class="number">9</span>);</span><br><span class="line">             <span class="keyword">int</span> c = rand.nextInt(<span class="number">9</span>);</span><br><span class="line">             <span class="comment">//如果已经挖取了count个元素，且更新次数&lt;20</span></span><br><span class="line">             <span class="keyword">if</span> (i == count &amp;&amp; count_fresh &lt;= <span class="number">20</span>) &#123;</span><br><span class="line">                 <span class="keyword">return</span> temp;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//该位置有值，且能不能被其他值替换，则挖取这个位置的值</span></span><br><span class="line">             <span class="keyword">if</span> (temp[r][c] != <span class="number">0</span> &amp;&amp; isOnlyOne(r, c, temp))</span><br><span class="line">                 <span class="keyword">continue</span>;</span><br><span class="line">             <span class="comment">//如果能被其他元素取代，则重新寻找次数+1</span></span><br><span class="line">             count_fresh++;</span><br><span class="line">             <span class="comment">//如果寻找次数过多，说明有这是个不太理想的数独，继续寻找可能耗时</span></span><br><span class="line">             <span class="comment">//则重新生成新的数独</span></span><br><span class="line">             <span class="keyword">if</span> (count_fresh &gt; <span class="number">20</span>) &#123;</span><br><span class="line">                 flag = <span class="keyword">true</span>;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             i--;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//进行数据的重置以便重新生成数独</span></span><br><span class="line">         count_fresh = <span class="number">0</span>;</span><br><span class="line">         calloc_num = <span class="number">30</span>;</span><br><span class="line">         temp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">     &#125;<span class="keyword">while</span> (flag) ;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="流程概括">流程概括</span></h3><ol><li>构建一个不完整的矩阵，其中矩阵中N个元素被填写1-9的数字，且均符合数独的规则 (isValid()==true)</li><li>通过不完整的矩阵，又solveSudo(方法生成一个完整的数独矩阵</li><li>将生成的完整数独矩阵进行元素挖取，每挖一个元素都要保证被挖取的元素不能被其他数字替代(数独解的唯一性)(isOnlyOne())</li><li>3步骤中如果该元素不满足时 重新搜索记录+1,当重新搜索记录大于一定值时，说明这个数独不是一个好的数独，则重新进入步骤一，构建新的数独；反之，则就得到了解唯一的数独，输出即可。</li></ol><h3><span id="实验测试具体耗时">实验测试—具体耗时</span></h3><ul><li>使用generateSudoWithLevel(int level)函数在IDEA平台上进行数独生成 N次实验，记录每N次的耗时，多次测量并取平均值，画出表格如下</li><li><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20201222111013713.png" alt="image-20201222111013713"></li><li><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20201222110639573.png" alt="image-20201222110639573"></li></ul><h3><span id="实验分析">实验分析</span></h3><ul><li>随着难度增加， count 增加，生成完整数独后挖取的元素个数也增加，所以耗时必然是一个递增的过程。但在算法中因为涉及到calloc_fresh ，统计过量寻找可删除元素的判断，所以在遇到不太理想的数独时会进行重新生成操作，使得不同难度下单次生成数独的时间可能有差异。实验中的空间复杂度 : O(c)  (用到一个9x9的二维数组和常数个变量),  渐进复杂度上界  &gt;=O(9^{9x9})  (原因：加入判断calloc_fresh大于一定值时会重新生成数独重新挖取）</li></ul><h2><span id="游戏开发中的其他想法和问题">游戏开发中的其他想法和问题</span></h2><p>开发中还涉及到一些控件动态生成，UI布局选择和游戏模式的思考。如果老师对这部分有兴趣，请移步主目录中的 README.md 或者 README.pdf 文件</p><p>我把开发过程中的想法和解决方法写在了上述文档中</p><p>Github上项目不定时更新  <a href="https://github.com/Yunlong626/SudokuGame">https://github.com/Yunlong626/SudokuGame</a></p><p>邮箱 <a href="mailto:&#x34;&#48;&#x31;&#49;&#55;&#55;&#x39;&#x32;&#x33;&#x40;&#x71;&#113;&#x2e;&#x63;&#x6f;&#x6d;">&#x34;&#48;&#x31;&#49;&#55;&#55;&#x39;&#x32;&#x33;&#x40;&#x71;&#113;&#x2e;&#x63;&#x6f;&#x6d;</a></p><h2><span id="课设总结">课设总结</span></h2><p>​    这次课设让我学习了回溯算法，重新认识了数独游戏的定义，让我对求解N皇后和解数独等较为复杂的问题时有了新的思路，解决数独问题还可以通过位运算、舞蹈链等算法，回溯算法只是入门，数据结构和算法对我们来说，课程结束了但是还有很多很多需要今后深入学习。 通过这次课设也让我回顾了之前所学习的java语言和 Android开发的一些基础，发现自己的基础还是不是很牢固，在课设后还需要多巩固多总结。</p><h2><span id="感谢">感谢</span></h2><p>​    感谢老师的阅读，如果在测试中发现了任何的异常或者UI不兼容问题，麻烦老师指出。我会及时对项目进行更新</p>]]></content>
      
      
      <categories>
          
          <category> 个人项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人项目总结学习</title>
      <link href="2020/10/22/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
      <url>2020/10/22/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1><span id="个人项目总结">个人项目总结</span></h1><h2><span id="jdbc-html-mysql-间通信">JDBC \ HTML \ MYSQL 间通信</span></h2><h3><span id="简介">简介</span></h3><p>实现html 界面输入用户名密码，能够通过mysql 查询到相应的其他值，并且再输出到html界面上</p><!-- toc --><ul><li><a href="#%E9%87%87%E5%9D%91%E7%82%B9">采坑点</a></li></ul><ul><li><a href="#responsehtml-%E5%AE%9E%E7%8E%B0%E9%AA%8C%E8%AF%81%E7%A0%81-%E7%9A%84%E9%AA%8C%E8%AF%81%E5%92%8C%E6%9B%B4%E6%8D%A2">Response/HTML 实现验证码 的验证和更换</a></li><li><a href="#response-servletcontext-fileinputstream%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD">Response /ServletContext/ FileInputStream实现文件下载</a></li><li><a href="#gui-bufferedreader-regex-%E8%AF%BB%E5%8F%96%E6%96%87%E6%A1%A3%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%BF%A1%E6%81%AF%E5%B9%B6%E5%AD%98%E5%85%A5%E4%B8%BA%E5%85%B7%E4%BD%93%E5%AF%B9%E8%B1%A1%E8%BF%9B%E5%85%A5%E5%85%B7%E4%BD%93%E6%95%B0%E7%BB%84%E4%B8%AD">GUI / BufferedReader /  Regex 读取文档类对象信息并存入为具体对象进入具体数组中</a></li></ul><!-- tocstop --><span id="more"></span><h3><span id="采坑点">采坑点</span></h3><ol><li><p>Servlet下的getParameter() 获取的是html 中name的值</p></li><li><p>JDBCTemplate  、 JDBCDruidUtils 的使用尚不熟悉</p></li><li><p>@Test  导入包  —-org.junit 要和hram..1.3 一起导入</p></li><li><p>jar包 最好都导入到web 下的WEB-INF中的lib中，注意别忘记添加依赖</p></li><li><p>各种jar包的寻找和导入</p></li><li><p> JDBCTemplate.query() 中的new BeanPropertyRowMapper&lt;&gt;(x.class,?1,?2….)  是通过 x.class中的 标准的java bean类来实现的</p></li></ol><p>   即， 各种变量名不一定要与数据库中的一致</p><p>   但： <strong>setter getter方法后的名字必须一致</strong>，比如：</p><p>   数据库username —setUsername（）—name 是能够访问到的</p><ol start="7"><li><p>template 中查找数据 为 空，但会报错， 这个时候直接找到这个异常， 捕获，选择处理办法，避免导致服务器异常</p></li><li><p>出现 ？？？？的html显示可能是 编码选择不正常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">resp.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">req.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>网站404  ： 可能是继承Httpservlet类中方法没有@Override重写</p></li><li><p>Mysql 中 char类型 是定长的，会自动补齐</p><p>而varchar是变长的，即使指定25个字节，也会根据输出的不同而删除，这一点很重要！！！！</p></li></ol><hr><h2><span id="responsehtml-实现验证码-的验证和更换">Response/HTML 实现验证码 的验证和更换</span></h2><ol><li><p>各种src的指定路径</p></li><li><p>还未想到解决方法： 参数的传递 （我用的是类的静态变量）</p></li><li><p>现在 想到的解决办法：this.getServletContext() </p><p> 传入 setattribute   作为类似的全局变量</p></li></ol><hr><h2><span id="response-servletcontext-fileinputstream实现文件下载">Response /ServletContext/ FileInputStream实现文件下载</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//获取 html参数名</span></span><br><span class="line">String fileName=req.getParameter(<span class="string">&quot;filename&quot;</span>);</span><br><span class="line"><span class="comment">//得到ServletContext对象</span></span><br><span class="line">ServletContext servletContext=<span class="keyword">this</span>.getServletContext();</span><br><span class="line"><span class="comment">//得到服务器包下的资源的绝对路径</span></span><br><span class="line">String realPath=servletContext.getRealPath(<span class="string">&quot;/Sources/&quot;</span>+fileName);</span><br><span class="line"><span class="comment">//创建输入流实体</span></span><br><span class="line">FileInputStream fileInputStream=<span class="keyword">new</span> FileInputStream(realPath);</span><br><span class="line"><span class="comment">//更改响应头信息 设置为手动选择下载位置</span></span><br><span class="line">resp.setHeader(<span class="string">&quot;content-type&quot;</span>,servletContext.getMimeType(fileName));</span><br><span class="line">resp.setHeader(<span class="string">&quot;content-disposition&quot;</span>,<span class="string">&quot;attachment;filename=&quot;</span>+fileName);</span><br><span class="line"><span class="comment">//得到输出流</span></span><br><span class="line">ServletOutputStream outputStream = resp.getOutputStream();</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] readbyte=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((len=fileInputStream.read(readbyte))!=-<span class="number">1</span>)&#123;</span><br><span class="line">    outputStream.write(readbyte,<span class="number">0</span>,len);</span><br><span class="line">&#125;</span><br><span class="line">fileInputStream.close();</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/Tomcat_2_war_exploded/downLoadServlet?filename=image_1.jpg&quot;</span>&gt;</span> 图片<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/Tomcat_2_war_exploded/downLoadServlet?filename=audio.mp3&quot;</span>&gt;</span> 音乐<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意这里的   ? 的参数传递！！</p><hr><p>##JDBC / HTML/ Mysql /JSP 实现 登录 、注册 并查询 用户信息</p><ol><li> 解决 从浏览器上获取 输入的中文字符  乱码问题  核心解决方案：</li></ol>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">   req.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);<span class="comment">//解决乱码的核心问题</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>对 Mysql中 Unique  / Null 问题的解决 ！！：</p><p>注意 异常捕获问题！ 先捕获子类，再捕 超类 ，利用返回值 ，返给调用类，这是很经典的做法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String sql = <span class="string">&quot;insert into users values(null,?,?,?,?,?,?)&quot;</span>;</span><br><span class="line">   </span><br><span class="line">        template.update(sql, user.getAccount(), user.getPassword(), user.getUsername(), user.getSex(), user.getAge(), user.getProperty());</span><br><span class="line">   </span><br><span class="line">    &#125;<span class="comment">//用户重名：   DuplicateKeyException 是DataIntegrityViolationException的子类</span></span><br><span class="line">    <span class="keyword">catch</span> (DuplicateKeyException e)&#123;</span><br><span class="line">        i=-<span class="number">2</span>;</span><br><span class="line">   </span><br><span class="line">    &#125; <span class="keyword">catch</span> (DataIntegrityViolationException e) &#123;</span><br><span class="line">        i = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对 html页面输入框，不输入时， 得到的结果 并不为NULL 而是为”” 的情况</p><ul><li><p>**尽可能的将int、double….类型换成包装类  ** 这样方便直接赋值null</p></li><li><p>在捕获端的处理</p></li><li><p>```java</p><pre><code>    String s1=req.getParameter(&quot;age&quot;);    Integer age=null;    if(!s1.equals(&quot;&quot;))  age=Integer.valueOf(req.getParameter(&quot;age&quot;));</code></pre><p>//或者用三元 判别式也可以 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. 判断 注册信息 错误时， 错误提示的传递</span><br><span class="line"></span><br><span class="line">   req 存储信息 并将转发到 新的页面  ，forward 重要</span><br><span class="line"></span><br><span class="line">   &#96;&#96;&#96;java</span><br><span class="line">           if(judge&#x3D;&#x3D;-1)&#123;</span><br><span class="line">               req.setAttribute(&quot;register_error&quot;,&quot;用户名或密码必须不为空！&quot;);</span><br><span class="line">               req.getRequestDispatcher(&quot;&#x2F;register.jsp&quot;).forward(req,resp);</span><br><span class="line">           &#125;</span><br><span class="line">           else if(judge&#x3D;&#x3D;-2)&#123;</span><br><span class="line">               req.setAttribute(&quot;register_error&quot;,&quot;用户名重名啦！&quot;);</span><br><span class="line">               req.getRequestDispatcher(&quot;&#x2F;register.jsp&quot;).forward(req,resp);</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>html页面上的接收以及显示处理  JSP原理</p><p>先判断 是否为空， 赋值为“”,否则页面会显示 为null</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&lt;% <span class="keyword">if</span>(request.getAttribute(<span class="string">&quot;login_error&quot;</span>)==<span class="keyword">null</span>)&#123;</span><br><span class="line">        request.setAttribute(<span class="string">&quot;login_error&quot;</span>,<span class="string">&quot;&quot;</span>);&#125; %&gt;</span><br><span class="line">    &lt;%= request.getAttribute(&quot;login_error&quot;)%&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>重定向</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">req.getSession().setAttribute(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line">         resp.sendRedirect(req.getContextPath()+<span class="string">&quot;/success.jsp&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>还是对于html  获取的 account 和 password  为“” 而不为null ，异常是捕获不到的,注意一下这种现象</p><p>解决办法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String account&#x3D;req.getParameter(&quot;account&quot;);</span><br><span class="line">    if(account.equals(&quot;&quot;)) account&#x3D;null;</span><br><span class="line">    </span><br><span class="line">    String password&#x3D;req.getParameter(&quot;password&quot;);</span><br><span class="line">    if(password.equals(&quot;&quot;)) password&#x3D;null;</span><br><span class="line">   </span><br></pre></td></tr></table></figure></li><li><p>发现的问题：</p></li><li><p>对JDBC Druid 的使用和建立还不熟悉</p></li><li><p>对jsp 页面的使用 还不能适应</p></li><li><p>对Cookie Session 很不理解</p></li></ol><hr><h2><span id="gui-bufferedreader-regex-读取文档类对象信息并存入为具体对象进入具体数组中">GUI  / BufferedReader /  Regex 读取文档类对象信息并存入为具体对象进入具体数组中</span></h2><ol><li><p>```java<br> String Reg_1 = “(?&lt;=\n)[^\n]*(?=\s)”;</p><pre><code>    String Reg_2 = &quot;(?&lt;=\\t)[^\\t]*(?=\\t)&quot;;    String Reg_3 = &quot;([0-9]+)&quot;;    Pattern pattern = Pattern.compile(Reg_1);    Matcher matcher = pattern.matcher(allInfo);</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   利用正则表达式筛选数据，Pattern  &amp; Matcher 进行匹配，得到的是mather 的对象</span><br><span class="line"></span><br><span class="line">   **踩坑：  matcher.group()是得不到对象的，必须要先使用m.find()才会进行查找，之后才能group方法得到下一个对象！并且每次都要这样，类似于 next() **</span><br><span class="line"></span><br><span class="line">2. 对对象进行添加时判断是否重复， 要先进行 存储数组是否为 Null的问题   (size()!&#x3D;0)</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">3. &#96;&#96;&#96;java</span><br><span class="line">   StringBuilder s&#x3D;new StringBuilder(&quot;&quot;);&#x2F;&#x2F; 不报错</span><br><span class="line">   StringBuilder s&#x3D;null;&#x2F;&#x2F; 报错！ </span><br></pre></td></tr></table></figure><p>创建StringBuilder的空对象时发生的问题</p></li><li><p>HashMap 排序的实现 很不明确</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ranklist = <span class="keyword">new</span> ArrayList&lt;&gt;(rankTime.entrySet());</span><br><span class="line">     Collections.sort(ranklist, <span class="keyword">new</span> Comparator&lt;Map.Entry&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Map.Entry&lt;String, Integer&gt; o1, Map.Entry&lt;String, Integer&gt; o2)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> o2.getValue() - o1.getValue();</span><br><span class="line">             &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li><li><p>好习惯：在类中 创建 static 的 静态变量数组或者是静态常量字段 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ArrayList&lt;Singer&gt; singers=<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">static</span> ArrayList&lt;Song&gt; songsOfYear=<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">static</span> List&lt;Map.Entry&lt;String,Integer&gt;&gt; ranklist=<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">static</span> HashMap&lt;String,Integer&gt; rankTime=<span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>​                在类的构造方法中创建具体数组或者对象的实例化 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">xxx</span><span class="params">()</span></span>&#123;</span><br><span class="line">singers=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">scan =<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="comment">//.........</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="2020/05/23/%E6%8E%92%E5%BA%8F/"/>
      <url>2020/05/23/%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1><span id="排序">排序</span></h1><p>[TOC]</p><hr><span id="more"></span><h2><span id="冒泡排序">冒泡排序</span></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line"><span class="comment">//设置了中断位，判断是否已经是排好序的数组了</span></span><br><span class="line"><span class="comment">//能够实现O（n）的最优时间复杂度</span></span><br><span class="line"><span class="keyword">int</span> isSwap = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n - i<span class="number">-1</span>;j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = a[j];</span><br><span class="line">a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">a[j+<span class="number">1</span>] = temp;</span><br><span class="line">isSwap = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; %d &quot;</span>, a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (isSwap == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="选择排序">选择排序</span></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> min; </span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line"><span class="comment">//最小的排在前面</span></span><br><span class="line">min = a[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i;j &lt; n;j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[j] &lt; min) &#123;</span><br><span class="line">min = a[j];</span><br><span class="line">k = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (min != a[i]) &#123;</span><br><span class="line">a[k] = a[i];</span><br><span class="line">a[i] = min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; %d &quot;</span>, a[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="希尔排序">希尔排序</span></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SortByShell</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i, j, increment;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">for</span> (increment = len / <span class="number">2</span>;increment &gt; <span class="number">0</span>;increment /= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (i = increment;i &lt; len;i++) &#123;</span><br><span class="line">temp = arr[i];</span><br><span class="line"><span class="keyword">for</span> (j = i;j &gt;= increment;j -= increment) &#123;</span><br><span class="line"><span class="keyword">if</span> (temp &lt; arr[j - increment])</span><br><span class="line">arr[j] = arr[j - increment];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//9,8,7,6,5,4,3,2,1,10 </span></span><br><span class="line">arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printArr(arr, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="插入排序">插入排序</span></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++) &#123;</span><br><span class="line"><span class="comment">//插入排序前提是之前的数组都是排好序的了</span></span><br><span class="line"><span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> x = a[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;j &gt;= <span class="number">0</span> &amp;&amp; a[j] &gt;x;--j)</span><br><span class="line">a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">a[j + <span class="number">1</span>] = x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; n;k++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a[k]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="桶式排序">桶式排序</span></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//桶式排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BucketSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> MAX = findMax(arr, num)+<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 为bucket分配空间，max尽可能的减少多余的空间</span></span><br><span class="line"><span class="keyword">int</span> *bucket=(<span class="keyword">int</span>*)<span class="built_in">calloc</span>(MAX,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="comment">//为每一个arr的数设置标记为 1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; num;i++) &#123;</span><br><span class="line">bucket[arr[i]]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; MAX;i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (bucket[i] == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="基数排序">基数排序</span></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基数排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RadixSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> num,<span class="keyword">int</span> base)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> *count;</span><br><span class="line"><span class="comment">//开辟有基数base个元素的数组</span></span><br><span class="line">count = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*base);</span><br><span class="line"><span class="comment">// 开辟 base行 num列的数组</span></span><br><span class="line"><span class="keyword">int</span> **temp;</span><br><span class="line"><span class="keyword">int</span> maxCount = findMaxCount(arr, num);</span><br><span class="line"><span class="keyword">int</span> countNum = <span class="number">1</span>;</span><br><span class="line">temp = (<span class="keyword">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*) * base);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; base;i++)</span><br><span class="line">temp[i] = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(num*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>;a &lt; maxCount;a++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对count 和 temp进行 初始化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; base;j++) &#123;</span><br><span class="line">count[j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; num;k++)</span><br><span class="line">temp[j][k] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对arr数组中每一个数 该位数上进行判断入桶</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; num;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> cNum = arr[i] / countNum;</span><br><span class="line"><span class="keyword">int</span> leaveNum = cNum % base;</span><br><span class="line"><span class="comment">// 进行标记</span></span><br><span class="line">count[leaveNum]++;</span><br><span class="line"><span class="comment">//保存</span></span><br><span class="line">temp[leaveNum][count[leaveNum] - <span class="number">1</span>]=arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; base;i++) &#123;</span><br><span class="line"><span class="comment">//寻找该位上是否有数（有标记）</span></span><br><span class="line"><span class="keyword">if</span> (count[i] != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; count[i];k++) &#123;</span><br><span class="line">arr[j] = temp[i][k];</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//每一个位数操作后对countNum*10 以便得到下一个位数</span></span><br><span class="line">countNum*= base;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*for (int i = 0;i &lt; num;i++)</span></span><br><span class="line"><span class="comment">printf(&quot;%d &quot;, arr[i]);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="快速排序">快速排序</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> l ,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = getIndex(nums,l,r);</span><br><span class="line">        quickSort(nums,l,index-<span class="number">1</span>);</span><br><span class="line">        quickSort(nums,index+<span class="number">1</span>,r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[l];</span><br><span class="line">        <span class="keyword">int</span> i = l;</span><br><span class="line">        <span class="keyword">int</span> j = r;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; temp &lt;= nums[j]) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; temp &gt; nums[i]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[i] = temp;</span><br><span class="line">        <span class="keyword">return</span> i ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC 学习</title>
      <link href="2019/12/22/JDBC%E5%AD%A6%E4%B9%A0/"/>
      <url>2019/12/22/JDBC%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1><span id="jdbc-学习">JDBC 学习</span></h1><hr><h2><span id="jdbc">JDBC</span></h2><p>** JAVA DATABASE CONNECTIVITY    **</p><ul><li>定义了 操作所有关系型数据库的规则（接口） —SUN公司定义<br>各个数据库厂商实现接口 ，提供驱动jar包 <strong>真正执行的代码是jar包中的实现类</strong></li></ul><hr><span id="more"></span><h3><span id="导入驱动jar包">导入驱动jar包</span></h3><h3><span id="注册驱动">–注册驱动 –</span></h3><h3><span id="获取数据库连接对象-connection">获取数据库连接对象 Connection –</span></h3><h3><span id="定义sql">定义sql –</span></h3><h3><span id="获取执行sql语句对象statement">获取执行sql语句对象statement –</span></h3><h3><span id="执行sql-接受结果-">执行sql 接受结果-</span></h3><h3><span id="处理结果">处理结果</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册驱动 ，加载进内存  （内含静态代码快 其中便是DriverManager的注册方法）！！</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line"><span class="comment">//获取数据库连接对象</span></span><br><span class="line">Connection conn=DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/test_db?serverTimezone=UTC&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;Zyl2000215&quot;</span>);</span><br><span class="line"><span class="comment">/*DriverManager  驱动管理对象（注册驱动 --获取连接）</span></span><br><span class="line"><span class="comment">    getConnection (url,user,password)</span></span><br><span class="line"><span class="comment">    url :jdbc:mssql//ip :端口 /数据库名称</span></span><br><span class="line"><span class="comment">    细节：若是本机的mysql服务器且端口为3306 可以不写ip：端口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Connection</span></span><br><span class="line"><span class="comment">    1.获取执行sql对象</span></span><br><span class="line"><span class="comment">    createStatement</span></span><br><span class="line"><span class="comment">    2.管理事务：</span></span><br><span class="line"><span class="comment">    开启事务 setAutoCommit()</span></span><br><span class="line"><span class="comment">    提交事务 commit（）</span></span><br><span class="line"><span class="comment">    回滚事务 rollback()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String sql1=<span class="string">&quot;update account set salary =3000&quot;</span>;</span><br><span class="line">Statement stat=conn.createStatement();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     Statement :</span></span><br><span class="line"><span class="comment">     1. 执行sql</span></span><br><span class="line"><span class="comment">     int executeupdate（string sql）： 执行 DML DDL  返回值：影响的行数</span></span><br><span class="line"><span class="comment">     ResultSet executeQuery 执行DQL 语句</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> count =stat.executeUpdate(sql1);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    ResultSet :</span></span><br><span class="line"><span class="comment">    1. next():游标向下移动一行 注意，最开始的从第一行之前开始</span></span><br><span class="line"><span class="comment">       getXXX（数据类型）(参数):获取数据</span></span><br><span class="line"><span class="comment">       while(rs.next())实现循环</span></span><br><span class="line"><span class="comment">       1， 参数为 int ：列的编号  从  -1- 开始</span></span><br><span class="line"><span class="comment">       2.  参数为String ， 列的名称</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">System.out.println(count);</span><br><span class="line">stat.close();</span><br><span class="line">conn.close();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="抽取jdbc-工具类for-简化书写">抽取JDBC 工具类（for 简化书写）</span></h2><p>1.注册驱动也抽取<br>2.抽取一个方法获取连接对象</p><ul><li><pre><code>** 使用配置文件---使用静态代码块 ** </code></pre></li></ul><p>3.抽取一个方法释放资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String url;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> String user;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> String password;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> String driver;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">         静态代码块，文件加载时执行一次</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Properties pro=<span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">           <span class="comment">//类加载器  避免直接输入绝对路径造成路径转移时问题</span></span><br><span class="line">           ClassLoader classLoader=JDBCUtils.class.getClassLoader();</span><br><span class="line">           URL res=classLoader.getResource(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">           String path=res.getPath();</span><br><span class="line"></span><br><span class="line">           pro.load(<span class="keyword">new</span> FileReader(path));</span><br><span class="line"></span><br><span class="line">           url=pro.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">           user=pro.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">           password=pro.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">           driver=pro.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">           Class.forName(driver);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> DriverManager.getConnection(url,user,password);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeAll</span><span class="params">(Statement stmt, Connection conn, ResultSet rs)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(rs!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               rs.close();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">               throwables.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(stmt!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               stmt.close();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">               throwables.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(conn!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               conn.close();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">               throwables.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2><span id="preparedstatement-执行sql-的对象">PreparedStatement :执行sql 的对象</span></h2><ol><li>sql注入问题<ol><li>目的： 用户输入的一些sql的特殊关键字参与拼接，造成安全性问题</li><li>预编译sql： 参数使用 ？ 作为占位符</li><li>步骤麻烦 但安全：<ol><li>Connection.preparedSatement（sql）</li><li>给？赋值： setXXX(参数1，参数2)<br> 参数1： ？的位置编号，从1开始<br> 参数2： ？的值</li><li>resultset 传参时，不需要再传参sql<br>相当于preparedSatement代替了父类statement</li></ol></li></ol></li></ol><p>** 后期都会使用到preparedStatement！！！**</p><hr><h2><span id="jdbc-控制事务">JDBC 控制事务</span></h2><p> conn.setAutoCommit.(false);<br> 抓异常回滚时，是在异常catch中抓 conn.rollback();</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 学习</title>
      <link href="2019/12/22/JVM%E5%AD%A6%E4%B9%A0/"/>
      <url>2019/12/22/JVM%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1><span id="jvm-学习日志">JVM 学习日志</span></h1><p>[toc]</p><!-- toc --><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a><ul><li><a href="#jre-%E5%92%8C-jdk%E7%9A%84%E5%85%B3%E7%B3%BB">JRE 和 JDK的关系</a></li><li><a href="#jvm%E8%B7%A8%E8%AF%AD%E8%A8%80%E7%9A%84%E5%B9%B3%E5%8F%B0">JVM跨语言的平台</a></li><li><a href="#jvm%E7%9A%84%E8%AF%AD%E8%A8%80%E6%97%A0%E5%85%B3%E6%80%A7">JVM的语言无关性</a></li><li><a href="#jvm-%E5%AD%97%E8%8A%82%E7%A0%81">(JVM) 字节码</a><ul><li><a href="#%E5%A4%9A%E8%AF%AD%E8%A8%80%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B">多语言混合编程</a></li></ul></li><li><a href="#%E8%99%9A%E6%8B%9F%E6%9C%BA">虚拟机</a><ul><li><a href="#%E7%89%B9%E7%82%B9">特点：</a></li><li><a href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE">虚拟机在计算机中的位置</a></li></ul></li><li><a href="#%E5%85%B6%E4%BB%96">其他</a></li></ul></li><li><a href="#%E6%AD%A3%E5%BC%8F%E8%BF%9B%E5%85%A5">正式进入</a><ul><li><a href="#java%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B">Java代码的执行流程</a></li><li><a href="#jvm%E7%9A%84%E6%9E%B6%E6%9E%84">JVM的架构</a></li><li><a href="#jvm%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">JVM的生命周期</a></li></ul></li><li><a href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD">类加载</a><ul><li><a href="#classloader">ClassLoader</a></li><li><a href="#%E5%8A%A0%E8%BD%BDloading">加载Loading：</a></li><li><a href="#%E9%93%BE%E6%8E%A5linking%E9%98%B6%E6%AE%B5">链接Linking阶段：</a><ul><li><a href="#%E9%AA%8C%E8%AF%81-verify">验证 Verify</a></li><li><a href="#%E5%87%86%E5%A4%87-prepare">准备 Prepare</a></li><li><a href="#%E8%A7%A3%E6%9E%90-resolve">解析 Resolve</a></li></ul></li><li><a href="#%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">类的初始化</a><ul><li><a href="#%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B">变量初始化过程</a></li></ul></li><li><a href="#%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB">加载器的分类</a><ul><li><a href="#bootstapclassload">BootStapClassLoad</a></li><li><a href="#appclassloader">AppClassLoader</a></li><li><a href="#extensionloader">ExtensionLoader</a></li><li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8">自定义类加载器</a></li></ul></li></ul></li><li><a href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6">双亲委派机制</a><ul><li><a href="#%E4%BC%98%E7%82%B9">优点</a></li></ul></li><li><a href="#%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6">沙箱安全机制</a></li><li><a href="#%E5%85%B6%E4%BB%96-1">其他</a><ul><li><a href="#%E7%B1%BB%E7%9A%84%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8%E5%92%8C%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8">类的主动使用和被动使用</a></li></ul></li><li><a href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA">运行时数据区</a><ul><li><a href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88">虚拟机栈</a><ul><li><a href="#%E6%A6%82%E5%BF%B5">概念</a></li><li><a href="#%E5%BC%82%E5%B8%B8">异常</a></li><li><a href="#%E6%A0%88%E5%B8%A7">栈帧</a><ul><li><a href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8">局部变量表</a></li><li><a href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88">操作数栈</a></li><li><a href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5">动态链接</a></li><li><a href="#%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80">方法返回地址</a></li><li><a href="#%E9%99%84%E5%8A%A0%E4%BF%A1%E6%81%AF">附加信息</a></li></ul></li></ul></li><li><a href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88">本地方法栈</a><ul><li><a href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%BA%93">本地方法接口和库</a></li></ul></li><li><a href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8">程序计数器</a><ul><li><a href="#pc%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E5%A5%BD%E5%A4%84">PC寄存器的好处</a></li><li><a href="#cpu%E6%97%B6%E9%97%B4%E7%89%87">CPU时间片</a></li></ul></li><li><a href="#%E5%A0%86">堆</a><ul><li><a href="#%E5%A0%86%E7%A9%BA%E9%97%B4%E7%BB%86%E5%88%86%E9%80%BB%E8%BE%91%E4%B8%8A">堆空间细分（逻辑上）</a></li><li><a href="#%E8%AE%BE%E7%BD%AE%E5%A0%86%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F">设置堆空间大小</a></li><li><a href="#%E5%A0%86%E7%A9%BA%E9%97%B4%E7%9A%84oom">堆空间的OOM</a></li><li><a href="#%E5%B9%B4%E8%BD%BB%E4%BB%A3%E4%B8%8E%E8%80%81%E5%B9%B4%E4%BB%A3">年轻代与老年代</a></li><li><a href="#%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B">对象分配过程</a></li><li><a href="#minor-gc-major-gc-full-gc">Minor GC、Major GC 、Full GC</a></li><li><a href="#tlab">TLAB</a></li><li><a href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90">逃逸分析</a><ul><li><a href="#%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8D">栈上分配</a></li><li><a href="#%E5%90%8C%E6%AD%A5%E7%9C%81%E7%95%A5">同步省略</a></li><li><a href="#%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96">代码优化</a></li></ul></li></ul></li><li><a href="#%E5%85%83%E7%A9%BA%E9%97%B4">元空间</a><ul><li><a href="#%E6%96%B9%E6%B3%95%E5%8C%BA-%E5%A0%86-%E6%A0%88%E7%9A%84%E4%BA%A4%E4%BA%92%E5%85%B3%E7%B3%BB">方法区 堆  栈的交互关系</a></li><li><a href="#%E8%AE%BE%E7%BD%AE%E5%85%83%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F">设置元空间大小</a></li><li><a href="#%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84">内部结构</a><ul><li><a href="#%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF">类型信息</a></li><li><a href="#%E6%96%B9%E6%B3%95%E4%BF%A1%E6%81%AF">方法信息</a></li><li><a href="#%E5%9F%9F%E4%BF%A1%E6%81%AF">域信息</a></li><li><a href="#non-final%E7%B1%BB%E5%8F%98%E9%87%8F">non-final类变量</a></li><li><a href="#%E5%85%A8%E5%B1%80%E5%B8%B8%E9%87%8F">全局常量</a></li></ul></li><li><a href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0">运行时常量池</a><ul><li><a href="#%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%B8%B8%E9%87%8F%E6%B1%A0">字节码的常量池</a></li><li><a href="#%E5%8A%A8%E6%80%81%E6%80%A7">动态性</a></li><li><a href="#jdk16-17-18%E7%9A%84%E8%B0%83%E6%95%B4">JDK1.6–1.7–1.8的调整</a></li><li><a href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6">垃圾回收</a></li></ul></li></ul></li></ul></li><li><a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E9%9D%A2%E8%AF%95">对象的实例化(面试)</a><ul><li><a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96">对象的实例化</a></li><li><a href="#%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%AD%A5%E9%AA%A4">对象创建步骤</a></li><li><a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80">对象的内存布局</a><ul><li><a href="#%E5%AF%B9%E8%B1%A1%E5%A4%B4">对象头</a></li><li><a href="#%E5%AE%9E%E4%BE%8B%E6%95%B0%E6%8D%AE">实例数据</a></li><li><a href="#instance-data">Instance Data</a></li><li><a href="#%E5%AF%B9%E9%BD%90%E5%A1%AB%E5%85%85">对齐填充</a></li><li><a href="#%E6%80%BB%E7%BB%93%E5%9B%BE%E7%A4%BA">总结图示</a></li></ul></li><li><a href="#%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D">对象访问定位</a><ul><li><a href="#%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F">访问方式</a></li></ul></li></ul></li><li><a href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98">直接内存</a></li><li><a href="#%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E">执行引擎</a><ul><li><a href="#%E6%A6%82%E8%BF%B0">概述</a></li><li><a href="#java%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91-%E6%89%A7%E8%A1%8C%E7%9A%84%E8%BF%87%E7%A8%8B">Java代码编译、执行的过程</a></li><li><a href="#%E8%A7%A3%E9%87%8A%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8">解释器的使用</a></li><li><a href="#%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91-jit%E7%BC%96%E8%AF%91%E5%99%A8">即时编译 JIT编译器</a><ul><li><a href="#%E7%83%AD%E7%82%B9%E4%BB%A3%E7%A0%81%E5%92%8C%E6%8E%A2%E6%B5%8B%E6%96%B9%E5%BC%8F">热点代码和探测方式</a></li></ul></li><li><a href="#graal%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8Caot%E7%BC%96%E8%AF%91%E5%99%A8">Graal编译器和AOT编译器</a></li></ul></li><li><a href="#stringtable">StringTable</a><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7">基本特性</a></li><li><a href="#string%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D">String的内存分配</a></li><li><a href="#intern">intern()</a></li></ul></li><li><a href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-1">垃圾回收</a><ul><li><a href="#%E5%9E%83%E5%9C%BE%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95">垃圾标记算法</a><ul><li><a href="#%E5%AF%B9%E8%B1%A1%E5%AD%98%E6%B4%BB%E5%88%A4%E6%96%AD">对象存活判断</a><ul><li><a href="#1-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95">1. 引用计数法</a></li><li><a href="#2-%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95">2. 可达性分析算法</a></li></ul></li><li><a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84finaliztion%E6%9C%BA%E5%88%B6">对象的finaliztion机制</a></li></ul></li><li><a href="#%E5%9E%83%E5%9C%BE%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95">垃圾清除算法</a><ul><li><a href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4-%E7%AE%97%E6%B3%95">标记 - 清除 算法</a></li><li><a href="#%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95">复制算法</a></li><li><a href="#%E6%A0%87%E8%AE%B0-%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95">标记 - 压缩算法</a></li><li><a href="#%E5%AF%B9%E6%AF%94">对比</a></li><li><a href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95">分代收集算法</a></li><li><a href="#%E5%A2%9E%E9%87%8F%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95">增量收集算法</a></li><li><a href="#%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95">分区算法</a></li></ul></li><li><a href="#%E6%A6%82%E5%BF%B5-1">概念</a><ul><li><a href="#systemgy">System,gy()</a></li><li><a href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA">内存溢出</a></li><li><a href="#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2">内存泄露</a></li><li><a href="#stw">STW</a></li><li><a href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91">垃圾回收的并行和并发</a></li><li><a href="#%E5%AE%89%E5%85%A8%E7%82%B9%E5%92%8C%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F">安全点和安全区域</a><ul><li><a href="#%E5%AE%89%E5%85%A8%E7%82%B9">安全点</a></li><li><a href="#%E5%AE%89%E5%85%A8%E5%8C%BA">安全区</a></li></ul></li></ul></li><li><a href="#%E5%BC%95%E7%94%A8">引用</a><ul><li><a href="#%E5%BC%BA%E5%BC%95%E7%94%A8">强引用</a></li><li><a href="#%E8%BD%AF%E5%BC%95%E7%94%A8soft">软引用Soft</a></li><li><a href="#%E5%BC%B1%E5%BC%95%E7%94%A8weak">弱引用Weak</a><ul><li><a href="#weakhashmap">WeakHashMap</a></li></ul></li><li><a href="#%E8%99%9A%E5%BC%95%E7%94%A8phantomreference">虚引用PhantomReference</a></li></ul></li></ul></li><li><a href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%9F">垃圾回收期</a><ul><li><a href="#%E6%8C%87%E6%A0%87">指标</a></li><li><a href="#serial">Serial</a></li><li><a href="#parnew">ParNew</a></li><li><a href="#parallel">Parallel</a></li><li><a href="#cms">CMS</a></li><li><a href="#g1">G1</a><ul><li><a href="#remeberedset-%E8%AE%B0%E5%BF%86%E9%9B%86">RemeberedSet 记忆集</a></li><li><a href="#%E5%9B%9E%E6%94%B6%E5%85%B7%E4%BD%93%E8%BF%87%E7%A8%8B">回收具体过程</a></li></ul></li></ul></li></ul><ul><li><a href="#%E6%B7%B1%E5%85%A5%E7%AF%87">深入篇</a><ul><li><a href="#%E5%AD%97%E8%8A%82%E7%A0%81">字节码</a><ul><li><a href="#%E7%BC%96%E8%AF%91">编译</a></li><li><a href="#%E6%A6%82%E5%BF%B5-2">概念</a><ul><li><a href="#class%E6%96%87%E4%BB%B6">Class文件</a></li></ul></li><li><a href="#class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84">Class文件结构</a><ul><li><a href="#%E9%AD%94%E6%95%B0">魔数</a></li><li><a href="#class%E6%96%87%E4%BB%B6%E7%89%88%E6%9C%AC">Class文件版本</a></li><li><a href="#%E5%B8%B8%E9%87%8F%E6%B1%A0">常量池</a></li><li><a href="#%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97">访问标志</a></li><li><a href="#%E7%B1%BB%E7%B4%A2%E5%BC%95-%E7%88%B6%E7%B1%BB%E7%B4%A2%E5%BC%95-%E6%8E%A5%E5%8F%A3%E7%B4%A2%E5%BC%95%E9%9B%86%E5%90%88">类索引、父类索引、接口索引集合</a></li><li><a href="#%E5%AD%97%E6%AE%B5%E8%A1%A8%E9%9B%86%E5%90%88">字段表集合</a></li><li><a href="#%E6%96%B9%E6%B3%95%E8%A1%A8%E9%9B%86%E5%90%88">方法表集合</a></li><li><a href="#%E5%B1%9E%E6%80%A7%E8%A1%A8%E9%9B%86%E5%90%88">属性表集合</a></li></ul></li></ul></li><li><a href="#%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E7%AF%87">查漏补缺篇</a><ul><li><a href="#%E6%8B%85%E4%BF%9D%E6%9C%BA%E5%88%B6">担保机制</a></li><li><a href="#%E6%99%8B%E5%8D%87%E5%8E%9F%E7%90%86">晋升原理</a></li><li><a href="#string">String</a></li><li><a href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6">类加载机制</a><ul><li><a href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD-1">类加载</a></li><li><a href="#%E9%93%BE%E6%8E%A5">链接</a><ul><li><a href="#%E9%AA%8C%E8%AF%81">验证</a></li><li><a href="#%E5%87%86%E5%A4%87">准备</a></li><li><a href="#%E8%A7%A3%E6%9E%90">解析</a></li></ul></li><li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a></li><li><a href="#clinit%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7">clinit的线程安全性</a></li><li><a href="#%E7%B1%BB%E7%9A%84%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8%E5%92%8C%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8-1">类的主动使用和被动使用</a><ul><li><a href="#%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8">主动使用</a></li><li><a href="#%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8">被动使用</a></li></ul></li><li><a href="#%E7%B1%BB%E5%8D%B8%E8%BD%BD-unloading">类卸载 Unloading</a></li></ul></li><li><a href="#%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E4%B8%8E%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A">动态绑定与静态绑定</a></li><li><a href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6-1">双亲委派机制</a></li></ul></li></ul></li></ul><!-- tocstop --><hr><h2><span id="简介">简介</span></h2><p>JVM :       Java HotSoit Virtual Machine</p><p>   Write once,  run anywhere    </p><p>​    TIOBE 语言热度排行</p><p>Java 程序  —–&gt;编译为字节码文件(本身具有跨平台性)    —-&gt;不同操作系统上JVM</p><h3><span id="jre-和-jdk的关系">JRE 和 JDK的关系</span></h3><p>JDK：它是Java开发运行环境，在程序员的电脑上当然要安装JDK；<br>JRE：Java Runtime Environment它是Java运行环境，如果你不需要开发只需要运行Java程序，那么你可以安装JRE。例如程序员开发出的程序最终卖给了用户，用户不用开发，只需要运行程序，所以用户在电脑上安装JRE即可。<br>JDK包含了JRE。<br>JRE中包含虚拟机JVM</p><h3><span id="jvm跨语言的平台">JVM跨语言的平台</span></h3><p>JVM起始 从<strong>字节码</strong>开始   </p><p>字节码文件可以由不同的编程语言提供 在java平台<strong>解释</strong>运行</p><p>由不同的编程语言提供不同的<strong>编译器</strong></p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210224091832738.png" alt="image-20210224091832738"></p><h3><span id="jvm的语言无关性">JVM的语言无关性</span></h3><p>Java虚拟机不关心在内部运行的程序是用何种编程语言写的</p><p>只关心字节码文件  </p><p>只要其他编程语言的编译结果满足并包含Java虚拟机的内部指令集，符号表以及请他信息，他就可以被装载和运行</p><h3><span id="jvm-字节码">(JVM) 字节码</span></h3><p>通过编译器编译能在JVM上运行的二进制文件格式</p><p>不同的编译器可以编译出相同的字节码文件  字节码文件可以在不同的JVM上运行</p><h4><span id="多语言混合编程">多语言混合编程</span></h4><p>JDK 1.5 —&gt; Java SE 5.0 </p><h3><span id="虚拟机">虚拟机</span></h3><p>软件：执行一系列虚拟计算机指令     </p><p>分类  ：</p><ul><li>系统虚拟机: 提供可运行完整操作系统的软件平台，是对物理计算机的仿真</li><li>程序虚拟机:专门为<strong>执行单个计算机程序</strong>设计的   Java虚拟机中执行的指令 — 字节码指令</li></ul><h4><span id="特点">特点：</span></h4><ol><li>一次编译到处运行</li><li>自动内存管理</li><li>自动垃圾回收机制</li></ol><h4><span id="虚拟机在计算机中的位置">虚拟机在计算机中的位置</span></h4><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210224094303154.png" alt="image-20210224094303154"></p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210224094516957.png" alt="image-20210224094516957"></p><h3><span id="其他">其他</span></h3><p>OpenJDK  半年更新一次  维护半年  之后不再维护 免费开源</p><p>OracleJDK  维护期三年  付费 内容稍微少一些</p><p>两者在代码的实质上基本一致</p><h2><span id="正式进入">正式进入</span></h2><h3><span id="java代码的执行流程">Java代码的执行流程</span></h3><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210224095237677.png" alt="image-20210224095237677"></p><h3><span id="jvm的架构">JVM的架构</span></h3><p>Java编译器输入的指令流是 一种<strong>基于栈的指令集架构</strong>   不是基于寄存器的指令集架构</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210224095537650.png" alt="image-20210224095537650"></p><h3><span id="jvm的生命周期">JVM的生命周期</span></h3><ol><li>启动： bootstapclass loader引导类加载器创建的初始类 initial class 完成的 (加载父类？？)</li><li>执行：一个虚拟机对应着执行一个Java程序</li><li>退出：异常 、 正常执行完毕、操作系统错误、exit方法</li></ol><h2><span id="类加载">类加载</span></h2><h3><span id="classloader">ClassLoader</span></h3><p>只负责class 文件的加载，至于是否能运行，由Execution Engine决定</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210224152835665.png" alt="image-20210224152835665"></p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210224153411382.png" alt="image-20210224153411382"></p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210224163801377.png" alt="image-20210224163801377"></p><h3><span id="加载loading">加载Loading：</span></h3><ol><li>通过类的全限定名获取定义此类的二进制字节流</li><li>将该字节流代表的静态存储结构转化为方法的运行时数据</li><li>内存中生成一个代表此类的 java.lang.Class对象，作为方法区这个类的各个数据的访问入口</li></ol><h3><span id="链接linking阶段">链接Linking阶段：</span></h3><h4><span id="验证-verify">验证 Verify</span></h4><p>确保Class文件的字节流一中包含信息符号当前的虚拟机要求，保证<strong>加载类的正确性</strong>，不危害虚拟机自身安全。</p><p>文件格式验证 元数据验证  字节码验证 符号引用验证</p><h4><span id="准备-prepare">准备 Prepare</span></h4><p>为类变量分配内存并且设置该内变量的默认初始值，哪怕是a = 1 最开始也是  a=0</p><p>不包含用final修饰的static  final在编译阶段就会分配了</p><h4><span id="解析-resolve">解析 Resolve</span></h4><p>将常量池内的符号引用转换为直接引用的过程</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210228145418046.png" alt="image-20210228145418046"></p><h3><span id="类的初始化">类的初始化</span></h3><p>执行类构造器方法 clinit  的过程</p><p>javac 编译器自动收集类中的所有<span style="color:red;">类变量</span>的<strong>赋值动作</strong>和<strong>静态代码块中语句</strong>合并而来</p><p>有静态语句 或者 静态变量 就会有 clinit 方法      不包含主方法</p><p>clinit 方法一定是先执行父类的 clinit 在进行子类的clinit</p><p>虚拟机必须保证一个雷的clinit 方法咋多线程下被同步加锁</p><p>static 代码块 和 static变量的赋值 有顺序的关系，那个在后 那个后执行，但是可以在static语句块中赋值再定义 ——有一个注意点  非法的前向引用（可以赋值但不能调用）</p><h5><span id="变量初始化过程">变量初始化过程</span></h5><p>默认初始化–显示初始化- -构造器初始化–对象.属性的初始化</p><h3><span id="加载器的分类">加载器的分类</span></h3><h4><span id="bootstapclassload">BootStapClassLoad</span></h4><ul><li>用c/c++实现 嵌套在JVM内部</li><li>不继承ClassLoader </li></ul><p>系统的核心类库都是用引导类加载器加载的</p><p>不能直接通过getClassLoader获取</p><h4><span id="appclassloader">AppClassLoader</span></h4><p>加载环境变量classpath和系统属性 java.class.path  是程序中的<strong>默认类加载器</strong> </p><h4><span id="extensionloader">ExtensionLoader</span></h4><p>从java.ext.dirs系统属性指定的目录中加载类库</p><h4><span id="自定义类加载器">自定义类加载器</span></h4><p>目的：</p><ul><li>隔离加载类</li><li>修改类加载的方式</li><li>扩展加载源</li><li>防止源码泄露</li></ul><h2><span id="双亲委派机制">双亲委派机制</span></h2><p>问题引入：</p><p>自己创建 的 java.lang.String 和原生的冲突 会先加载原来的</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210224173500988.png" alt="image-20210224173500988"></p><ol><li>一个雷加载器收到了类加载请求，他并不会自己先加载，而是把这个请求委托给父类的加载器执行。</li><li>一次递归请求最终到达顶层的启动类加载器</li><li>如果父类的加载器无法加载（引导类加载器和拓展类加载器只加载指定目录的class），才会委派给子类的加载器加载</li></ol><h3><span id="优点">优点</span></h3><ol><li>保护程序安全，避免核心API被更改</li><li>避免类的重复加载 </li></ol><h2><span id="沙箱安全机制">沙箱安全机制</span></h2><p>沙箱安全机制是由基于双亲委派机制上 采取的一种JVM的自我保护机制,假设你要写一个java.lang.String 的类,由于双亲委派机制的原理,此请求会先交给Bootstrap试图进行加载,但是Bootstrap在加载类时首先通过包和类名查找rt.jar中有没有该类,有则优先加载rt.jar包中的类,因此就保证了java的运行机制不会被破坏.</p><p>虚拟机会把所有代码加载到不同的系统域和应用域，系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域 (Protected Domain)，对应不一样的权限 (Permission)</p><h2><span id="其他">其他</span></h2><p>JVM中判断两个class对象是否是同一个类存在的两个条件</p><ol><li>类的完整名称必须一致</li><li>加载这个类的加载器必须相同</li></ol><h3><span id="类的主动使用和被动使用">类的主动使用和被动使用</span></h3><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210224184726345.png" alt="image-20210224184726345"></p><h2><span id="运行时数据区">运行时数据区</span></h2><p>RunTime Data Area        桥梁: CPU  — 内存 —- 硬盘 </p><p>不同的JVM对内存的划分方式和管理机制存在差异</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210225201740198.png" alt="image-20210225201740198"></p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210225201756298.png" alt="image-20210225201756298"></p><p><strong><span style="color:red;">红色 </span> 一个进程一份</strong></p><p><strong>灰色  一个线程一份</strong></p><p><span style="color:red;"> 一个JVM实例对应一个RunTime实例</span></p><p>HotSpot JVM每个线程对应操作胸膛的本地线程直接映射</p><h3><span id="虚拟机栈">虚拟机栈</span></h3><h4><span id="概念">概念</span></h4><p>内部保存一个个的栈帧，对应着一次次的java方法调用（线程私有）</p><ul><li><p>生命周期和线程一致</p></li><li><p>栈是运行时单位，堆是存储单位</p></li></ul><p>作用：主管java程序的运行，保存方法的局部变量，部分结果，参与方法的调用和返回</p><p>优点： 访问速度快  <strong>不存在垃圾回收问题</strong> <strong>GC</strong>   (只有进栈出栈操作) 但可能存在OOM</p><p>设置栈大小 VMOptions: -Xss256k</p><h4><span id="异常">异常</span></h4><ul><li>JVM允许java栈大小是动态或者固定的</li><li>栈溢出异常： 线程的请求分配的栈容量超过JAVA虚拟机允许的最大容量，将抛出Stack Overflow异常</li><li>OOM： 动态扩展时没有足够的内存去申请或者创建，则跑出OutofMemoryError异常</li></ul><h4><span id="栈帧">栈帧</span></h4><p>栈中的数据都是以栈帧方式存在的，每个方法都对应一个栈帧</p><p>当前栈帧：当前执行方法。</p><p> 不同线程的栈帧是不允许相互引用的，不能在一个线程的方法里去调用另一个线程中的方法                                                    </p><p>包含：</p><h5><span id="局部变量表">局部变量表</span></h5><p>(基本决定栈帧的大小)</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210228084320963.png" alt="image-20210228084320963"></p><ul><li><p>数字数组，存储方法参数和定义在方法体内的局部变量。包含基本数据类型，对象引用  （<strong>byte short boolean char 被转换为int</strong>），返回值类型</p></li><li><p><span style="color:red;font-size:24px">垃圾回收的重点内容</span></p></li><li><p>所需大小是编译器确定下来的。未被赋值的声明是不会列入局部变量表的slot，但会列入locals(maximum local variables)中</p></li><li><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210228090243915.png" alt="image-20210228090243915"></p></li><li><p>Slot  槽：局部变量表的基本单位</p><ul><li>32位以内的类型只占用一个slot <strong>64位占用两个slot，在locals中看得出来</strong><ul><li>在外部方法中引用该类中对象或者方法时（不引用也会有） slot index0 位置会保存类的对象引用this</li><li>slot中的变量存在<strong>重复利用</strong>，内部域变量过期后的slot位置将由外部遍历替代        </li><li>局部变量初始化后再使用时必须赋值，否则编译不通过                                     </li></ul></li></ul></li></ul><h5><span id="操作数栈">操作数栈</span></h5><p>数组、链表实现 FILO</p><p>作用：根据字节码指令，在栈中写入数据，入栈和出栈，保存计算过程的中间结果</p><ul><li>a + b = c实例</li></ul><h6><span id="代码解析">代码解析</span></h6><p>bipush: 这里的 bi 代表byte 的整型，与代码中定义的int byte类型无关，他只与结果的具体数值有关，转换成最接近的类型]</p><p>istore:将push的byte值转换为java中类型对应的int值</p><p>注意这里istore_0和istore_1的区别，如果是主方法或者普通方法时，要么保存的是对象的引用this 要么就是args参数在index 为0位置。如果是类的静态方法中时，则就不存在其他的数据，一个数据都保存在index0处</p><p>iconst：当int取值**-1~5<strong>时，JVM采用</strong>iconst**指令将常量压入栈中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0: bipush        10</span><br><span class="line">     2: istore_1</span><br><span class="line">     3: bipush        20</span><br><span class="line">     5: istore_2</span><br><span class="line">     6: iload_1</span><br><span class="line">     7: iload_2</span><br><span class="line">     8: iadd</span><br><span class="line">     9: istore_3</span><br><span class="line">    10: return</span><br></pre></td></tr></table></figure><ul><li>每个操作数栈都拥有一个明确的栈深度存储数值，编译器就定义好</li></ul><p>Code — max_stack中 </p><ul><li>栈占用单位同slot</li><li>操作数栈中存在复用 </li><li>如果被调用的方法中带有返回值的话，其返回值将会被压入当前栈帧操作数栈中，并更新pc寄存器中的指令</li></ul><h6><span id="栈顶缓存技术">栈顶缓存技术</span></h6><p>出发点：栈结构，频繁执行内存读写（出栈入栈）</p><p>栈顶元素全部缓存在cpu寄存器中，提升执行引擎的效率</p><h5><span id="动态链接">动态链接</span></h5><p>——运行时常量池的方法引用</p><p>每一个栈帧内部都包含一个指向<strong>运行时常量池</strong>中该栈帧所属方法的引用</p><p>目的：支持当前方法的代码能够实现动态链接，将保存变量和方法引用的符号引用转换为调用方法的直接引用</p><h6><span id="方法的调用">方法的调用</span></h6><p>静态链接和动态链接</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210228141739834.png" alt="image-20210228141739834"></p><p>静态链接：目标方法在编译期间可知且运行期保持不变，这种情况下降调用方法的符号应用转换为直接引用的过程称为静态链接</p><p>动态链接：编译时无法确定</p><p>方法的绑定机制：早期绑定和晚期绑定</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210228142033732.png" alt="image-20210228142033732"></p><p>晚期绑定：</p><p>多态、继承，无法确定  —-invokeVirtual</p><p>早期绑定：</p><p>invokeSpecial</p><p>虚方法：</p><p>非虚方法：</p><ul><li><p>编译期间确定版本，运行时不可变</p></li><li><p>静态方法、私有方法、final方法、示例构造器、父类方法</p></li></ul><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210228143133793.png" alt="image-20210228143115307"></p><p>在子类中未显示的调用父类方法是虚方法（可能子类进行了重写）</p><p><span style="font-size:24px;color:orange">动态类型和静态类型语言的区别</span></p><p>对类型的检查是在编译期间还是在运行期间</p><ul><li><p>前者判断变量自身的类型信息  </p></li><li><p>后者判断变量值的类型信息，变量是没有类型信息的（JavaScript）</p></li></ul><p><span style="font-size:24px;color:orange">虚方法表</span></p><p>目的： 避免自下而上频繁的使用动态分配</p><p>创建阶段： linking</p><p>每个类中都有一个虚方法表</p><h5><span id="方法返回地址">方法返回地址</span></h5><p>方法正常退出的定义（异常退出时由异常表决定）</p><p>存放调用该方法的<strong>pc寄存器</strong>的值 类似ret？？？</p><p><span style="font-size:18px;color:cyan">异常处理表</span></p><p>class文件中   from  to  target</p><p>异常完成出口不会给上层调用者任何返回的信息</p><h5><span id="附加信息">附加信息</span></h5><h3><span id="本地方法栈">本地方法栈</span></h3><ul><li>线程私有</li><li>内存 固定或者动态扩展</li><li>本地方法用C语言实现</li><li>实现：虚拟机栈中登记本地方法</li></ul><p>当线程调用本地方法时，就进入了一个全新的不受虚拟机限制的 世界，和虚拟机有相同的权限</p><p>本地方法通过本地方法接口访问虚拟机内部运行时数据区</p><h4><span id="本地方法接口和库">本地方法接口和库</span></h4><p>Native Method : Java 调用非Java代码</p><h3><span id="程序计数器">程序计数器</span></h3><p>用来存储指向下一条指令的的<strong>字节码</strong>地址( ProgramCounter Register)</p><ul><li><p>很小的内存空间，运行速度最快</p></li><li><p>线程私有，生命周期和线程的生命周期保持一致</p></li><li><p>存储当前线程正在执行方法的JVM指令地址 如果执行native方法则是未指定值</p></li><li><p>唯一一个在JVM规范中没有规定任何OOM情况的区域</p></li><li><p>线程分支循环跳转异常处理、恢复等基础功能都需要依赖他</p></li></ul><h4><span id="pc寄存器的好处">PC寄存器的好处</span></h4><p>CPU会不停切换线程，切换回来以后不知道从那开始执行</p><p>指明当前执行代码的字节码指令</p><h4><span id="cpu时间片">CPU时间片</span></h4><ul><li><p>CPU分配给各个程序的时间</p></li><li><p><strong>CPU主频高，不断的切换，感觉像是在并行（不是并发）的执行</strong>——-这就叫并发</p></li><li><p>一个内核一时刻只能执行一条指令</p></li></ul><h3><span id="堆">堆</span></h3><p>一个JVM只存在一个堆内存      一个进程对应一个堆，JVM启动时 堆被创建  其空间大小就确定了   ，但堆内存的大小是可以调节的</p><p>堆可以处于物理上不连续的空间，但逻辑上他是连续的</p><p>所有的线程共享JAVA堆，还可以划分线程私有的华冲去   TLAB  THREAD LOCAL ALLOCATION BUFFER</p><p><strong>所有的对象实例及数组都应在运行时分配到堆上</strong></p><ul><li>方法结束后，堆的对象不会马上被移除，仅仅在垃圾收集时才会被移除（判断是否有引用）</li><li>堆是 GC 执行垃圾回收的重点区域</li></ul><h4><span id="堆空间细分逻辑上">堆空间细分（逻辑上）</span></h4><ul><li>Java 7 新生区  养老区  永久区</li></ul><ul><li>Java 8  包括以后   新生区  养老区  元空间</li></ul><h4><span id="设置堆空间大小">设置堆空间大小</span></h4><p>-Xms   堆区（新生代+老年代）的起始内存</p><p>-Xmx    堆区最大内存</p><p>-X JVM运行参数    -ms memory start</p><p>JVM 参数地址</p><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a></p><p>初始大小   电脑内存 / 64     默认大小  电脑内存 / 4</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().totalMemory()</span><br></pre></td></tr></table></figure><p><span style="color:red;font-size:18sp">问题： 设置Xms为10m  为什么得到的内存&lt;10</span></p><ul><li>Eden 区 只能和Survivor 1 或 2区 进行存储  而不是两个Survivor区都可以存储</li></ul><h4><span id="堆空间的oom">堆空间的OOM</span></h4><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210302163155472.png" alt="image-20210302163155472"></p><h4><span id="年轻代与老年代">年轻代与老年代</span></h4><p>YoungGen</p><p>占比1 / 3</p><ul><li>Survivor 0 ： from区</li><li>Survivor 1 ：to区</li></ul><p>OldGen</p><p>​    占比2 / 3</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210302163141130.png" alt="image-20210302163141130"></p><p>默认比例</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210302163437852.png" alt="image-20210302163437852"></p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210302163456336.png" alt="image-20210302163456336"></p><p><span style="color:red;font-size:18sp">问题： Eden和Survivor比例是 8:1  但实际是 6:1？</span></p><ul><li>自适应机制   -XX:-UseAdaptiveSizePolicy 关闭自适应的内存分配</li><li>可通过 -XX:SurvivorRatio 调整</li></ul><p><span style="color:orange;font-size:24px">几乎所有的Java对象都是Eden区 中new出来的</span></p><h4><span id="对象分配过程">对象分配过程</span></h4><p><span style="color:#00CD66;font-size:18px">YoungGC     Minor GC</span></p><ol><li>new的对象先到Eden区</li><li>Eden区被填满后  JVm GC器对 Eden区进行垃圾回收 MinorGC  销毁没有引用的对象 </li><li>将Eden的剩余对象移动到Survivor 0 区 并加上age 1</li><li>再次触发GC时  上次放到Seurvivor 0 区的就会 进入 1 区 age ++</li><li>阈值 age &gt;15 时 到 Old Gen 区  <span style="color:red;font-size:18sp">也有可能破格晋升</span></li></ol><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210303084331819.png"></p><p><strong>注意点</strong></p><ul><li><p>Eden区满 会将 Eden 和Survivor 区一起进行回收</p></li><li><p>Survivor区满不会进行回收！Survivor放不下，直接晋升老年代</p></li><li><p>0区 和1区复制之后有交换，谁空谁是to区</p></li><li><p>动态对象年龄判断</p><p>如果Survivor 中相同年龄的所有对象大小的总合大于 该区空间的一半，则年龄大于或等于该年龄的对象直接进入老年代(优化)</p></li><li><p>大对象直接放入老年代 (优化)</p></li></ul><h4><span id="minor-gc-major-gc-full-gc">Minor GC、Major GC 、Full GC</span></h4><p>STW  ： stop the world</p><ul><li><p>部分收集  Partial GC:</p><ul><li><p>Minor GC :</p><ul><li>执行频率高，速度快触发 STW 暂停用户线程  </li></ul></li><li><p>Major GC:</p><ul><li>执行速度比minor GC慢10倍以上  STW时间更长</li><li>老年代空间不足，先尝试minor GC如果还不足，就触发Major GC</li></ul></li><li><p>Mixed GC: 收集整个新生代和部分老年代的垃圾</p></li></ul></li><li><p>整堆收集 Full GC： 收集整个java堆和方法区的垃圾</p><ul><li>调优中尽量避免</li><li>触发条件：<ol><li>老年代空间不足</li><li>方法区空间不足</li><li>System.gc()但不一定执行</li><li>MinorGC进入老年代的平均大小大于老年代的可用内存</li><li>Survivor区转存到老年代时可用内存小于该对象大小</li></ol></li></ul></li></ul><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210303160142447.png" alt="image-20210303160142447"></p><p><span style="color:red;font-size:18px">为什么要分代</span></p><ul><li>优化GC性能   缩小对堆的扫描范围</li></ul><h4><span id="tlab">TLAB</span></h4><p>问题：堆区是线程共享区域    并发环境下从堆区划分内存空间是线程不安全的</p><p>定义： 每个线程中独有一份TLAB  即私有缓存区域</p><p>目的：</p><ul><li>多线程分配内存，能避免一系列的非线程安全问题</li><li>提升内存分配的吞吐量（快速分配策略）</li></ul><p>JVM将TLAV作为内存分配的首选</p><p>TLAB空间小  仅仅占整个Eden的1% ,  也可以设置</p><p>一旦对象在TLAB空间分配内存失败，JVM尝试使用加锁机制确保数据操作的原子性，进而在Eden空间分配内存</p><h4><span id="逃逸分析">逃逸分析</span></h4><p>将堆上的对象分配到栈    </p><ul><li>对象在<strong>方法内部中定义</strong>后  只 在内部使用， 则没有逃逸   ——&gt;使用栈上分配</li><li>对象在<strong>方法内部定义</strong>后  被外部方法所引用 。则发生了逃逸</li></ul><p><span style="color:red;font-size:18px">如何判断是否发生逃逸</span></p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210303161641422.png" alt="image-20210303161641422"></p><p>优化  前提 未发生逃逸</p><h5><span id="栈上分配">栈上分配</span></h5><p>原理 ？？</p><p>实例n个对象时，开启栈上分配， 速度大幅提高，实例数降低。</p><h5><span id="同步省略">同步省略</span></h5><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210303162647795.png" alt="image-20210303162647795"></p><p>去除了同步操作</p><h5><span id="代码优化">代码优化</span></h5><p>分离对象或者标量替换   肢解</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210303163208358.png" alt="image-20210303163208358"></p><h3><span id="元空间">元空间</span></h3><p>永久代 —&gt;方法区 —–&gt;元空间</p><p>固定大小或者动态变化   自动收缩   逻辑上连续 物理上不连续</p><p>逻辑上属于堆的一部分</p><p><span style="color:#018531;font-size:30px">方法区用于存储已被虚拟机加载的类型信息、常量、静态常量、即时编译器（JIT）编译后的代码缓存….</span></p><p><span style="color:orange;font-size:18px">方法区看做是一块独立于Java堆的内存空间</span></p><p><span style="color:orange;font-size:18px">方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，方法区会溢出 抛出OOM</span></p><p><span style="color:#4169E1;font-size:18px">元空间和永久代最大的区别</span></p><p>元空间不在虚拟机的内存中，而是在本地内存 ，内部结构也发生改变</p><h4><span id="方法区-堆-栈的交互关系">方法区 堆  栈的交互关系</span></h4><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210303164007274.png" alt="image-20210303164007274"></p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210303164100411.png" alt="image-20210303164100411"></p><h4><span id="设置元空间大小">设置元空间大小</span></h4><p>-XX: MataSpaceSize=     设置初始分配空间 默认20.75M    </p><p>-XX：MaxMataSpaceSize  设定最大可分配控件   32位默认64M  64位默认82M    设置为-1则没有限制</p><p>JDK1.7以前    -PermSize</p><p>常用指令  jps  jinfo -flag   xxxxx aaaa</p><p>触及21M  FULL GC 释放没用的类，水位线重置，如果释放空间过多，则降低该值</p><p><span style="color:orange;font-size:18px">内存泄露和内存溢出</span></p><p>内存泄露   病人康复 但是占着床位</p><p>内存溢出  病人太多，床位不够</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210303171142462.png" alt="image-20210303171142462"></p><h4><span id="内部结构">内部结构</span></h4><h5><span id="类型信息">类型信息</span></h5><p>完整有效名称    直接父类的完整有效名称    修饰符     直接接口的有序列表</p><h5><span id="方法信息">方法信息</span></h5><h5><span id="域信息">域信息</span></h5><p>域名称、域类型、域修饰符   </p><p><strong>注意：如果是private类型的话，是看不到域信息的</strong></p><h5><span id="non-final类变量">non-final类变量</span></h5><p>静态变量 在实例对象为null的情况下依然可以访问对象中的静态方法或者字段</p><h5><span id="全局常量">全局常量</span></h5><p>编译时分配   (准备阶段)</p><p><span style="color:orange;font-size:18px">与静态变量比较</span></p><p>静态变量在准备阶段初始化  在initial阶段赋值   也就是在静态语句中 clinit类构造器方法中赋值。而全局变量则不会再这个阶段赋值</p><h4><span id="运行时常量池">运行时常量池</span></h4><h5><span id="字节码的常量池">字节码的常量池</span></h5><p>存储各种字面量和对类型、方法和域的符号引用</p><p>类引用、字段引用、方法引用、数量值、字符串值</p><p>将在类加载后存放到方法区的运行时常量池中，这时符号地址就转换为了真实地址</p><h5><span id="动态性">动态性</span></h5><p>与常量池的差别</p><h5><span id="jdk161718的调整">JDK1.6–1.7–1.8的调整</span></h5><p><span style="color:red;font-size:24px">为什么要用元空间替代永久代？</span></p><ol><li>为永久代设置空间大小是很难确定的</li><li>对永久代的调优很困难</li></ol><p>静态变量的位置  </p><p>1.6–1.7 对象的引用名放在Old Gen中  1.8 在堆中  ？</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210304150244295.png" alt="image-20210304150244295"></p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210304150705423.png" alt="image-20210304150705423"></p><p>只要是实例对象 必然会在Java堆中分配</p><h5><span id="垃圾回收">垃圾回收</span></h5><p>回收内容：</p><p>常量池中废弃的常量和不再使用的类型</p><p>苛刻条件： 判断一个类已经被废弃</p><p><strong>总结</strong></p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210304145524447.png" alt="image-20210304145524447"></p><h2><span id="对象的实例化面试">对象的实例化(面试)</span></h2><h3><span id="对象的实例化">对象的实例化</span></h3><ol><li>new</li><li>class.newInstance / constructor.new Instance  反射的方式<ul><li>只能调用空参的构造器，权限必须是public</li><li>constructor的newInstance 调用空参或者带参数的构造器，权限没有要求</li></ul></li><li>clone()<ul><li>需要实现Cloneable接口</li></ul></li><li>反序列化<ul><li>网络中获取对象的二进制流</li></ul></li><li>第三方库Objenesis</li></ol><h3><span id="对象创建步骤">对象创建步骤</span></h3><p>字节码中</p><p>new #x</p><p>分配内存、初始化值</p><p>dup ：Duplicate the top value on the operand stack and push the duplicated value onto the operand stack.  复制操作数堆栈上的顶值，并将复制的值推送到操作数堆栈上。</p><p>invokespecial #a</p><p>调用init构造器    </p><p><span style="color: #DAA520;font-size:24px">流程</span></p><ol><li>判断对象对应的类是否加载、连接、初始化，（是否有符号引用）</li></ol><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210307084406633.png" alt="image-20210307084406633"></p><ol start="2"><li>为对象分配内存</li></ol><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210307084458998.png" alt="image-20210307084458998"></p><ul><li><p>如果内存规整  ——&gt; 指针碰撞</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210307084643494.png" alt="image-20210307084643494"></p></li><li><p>内存不规整  —–&gt;虚拟机需要维护一个列表    空闲列表分配</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210307084721903.png" alt="image-20210307084721903"></p></li></ul><ol start="3"><li><p>处理并发问题</p><p>CAS 失败重试  区域加锁保证更新的原子性</p><p>每个线程预先分配一个TLAB   </p></li><li><p>初始化分配空间</p><p>所有属性值默认值，保证对象实例字段在不赋值时可以直接使用</p></li><li><p>设置对象的对象头</p></li><li><p>init方法进行初始化  —-&gt;赋值</p></li></ol><h3><span id="对象的内存布局">对象的内存布局</span></h3><p>大厂面试</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210307090815341.png" alt="image-20210307090815341"></p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210307090828271.png" alt="image-20210307090828271"></p><h4><span id="对象头">对象头</span></h4><ol><li>运行时源数据 Mark Work<ol><li>哈希值</li><li>GC分代年龄</li><li>锁状态标志</li><li>线程持有的锁</li><li>偏向线程ID</li><li>偏向时间戳</li></ol></li><li>类型指针  指向类元数据，确定该对象的所属属性</li></ol><h4><span id="实例数据">实例数据</span></h4><h4><span id="instance-data">Instance Data</span></h4><p>对象真正存储的有效信息，包括程序代码定义的各种类型的字段</p><p>规则： 入少年宫图</p><h4><span id="对齐填充">对齐填充</span></h4><p>占位符作用</p><p>64位 JVM   实际对象必须是8的整数位   只有1byte属性也要给你整到 16 bytes</p><p>一个空的对象</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210405171441583.png" alt="image-20210405171441583"></p><p>两个String属性的对象</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210405171535161.png" alt="image-20210405171535161"></p><p>网上说的  32bit  4 byte</p><p>故  对象头字节固定 为 12 字节</p><p><strong>对象头由什么组成</strong>？</p><ol><li><p>MarkWord   64 bit</p><p>存储对象的hashCode、锁信息或分代年龄或GC标志等信息</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210405190427725.png" alt="image-20210405190427725"></p></li><li><p>Class Meta Address  32/64  bit(开启指针压缩</p><p>类型指针指向对象的类元数据，JVM通过这个指针确定该对象是哪个类的实例</p></li></ol><p>小端存储 / 大端存储   </p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210405184732813.png" alt="image-20210405184732813"></p><p><strong>对象状态</strong>：</p><ol><li>无状态  new时</li><li>偏向锁</li><li>轻量</li><li>重量锁</li><li>gc标记（无引用）</li></ol><h4><span id="总结图示">总结图示</span></h4><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210307091320160.png" alt="image-20210307091320160"></p><h3><span id="对象访问定位">对象访问定位</span></h3><p>JVM通过栈帧中的对象引用访问到内部的对象实例</p><h4><span id="访问方式">访问方式</span></h4><ol><li><p>句柄访问</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210307091748884.png" alt="image-20210307091748884"></p><ul><li>空间浪费</li><li>稳定  发生移动时外部指向不需要修改</li></ul></li><li><p>直接指针 HotSpot使用</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210307091828272.png" alt="image-20210307091828272"></p><ul><li>发生移动时 外部reference需要修改指向的地址</li></ul></li></ol><h2><span id="直接内存">直接内存</span></h2><p>基于元空间</p><p>Java堆外，向系统申请的内存空间</p><p>来源于NIO，世界使用DirectByteBuffer</p><p>NIO ：Non-Blocking IO  免去中间商</p><p>访问直接内存的速度，优于Java堆</p><p>缺点：</p><ul><li>分配回收成本高</li><li>不受JVM内存回收管理</li></ul><p>OOM  设置： MaxDirectMemorySize</p><p>不知道，则与堆的最大值 -Xmx参数值一致</p><h2><span id="执行引擎">执行引擎</span></h2><h3><span id="概述">概述</span></h3><p>物理机的执行引擎：</p><p>直接建立在处理器、缓存、指令集和操作系统层面上</p><p>JVM的执行引擎：</p><p>虚拟机的执行引擎，由软件自行实现，不受物理条件制约定值指令集和执行引擎的结构体系，能执行不受硬件直接支持的指令集格式</p><p><span style="color:orange;font-size:24px">JVM主要任务</span></p><p>字节码文件加载到内存中并<strong>解释执行</strong>， 解释/编译为对应平台上的本地机器指令</p><ul><li>执行引擎的执行的字节码指令完全依赖于PC寄存器</li></ul><h3><span id="java代码编译-执行的过程">Java代码编译、执行的过程</span></h3><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210307094756146.png" alt="image-20210307094756146"></p><p><span style="color:orange;font-size:24px">橙色与java虚拟机无关</span></p><p><span style="color:#FA8072;font-size:24px">解释器 Interpreter</span></p><p>根据预定义的规范对字节码采用逐行解释的方式执行</p><p><span style="color:#FA8072;font-size:24px">编译器 Just In Time Compiler编译器</span></p><p>JVM将原码编译成和本地机器平台相关的机器指令</p><p><span style="color:red;font-size:24px">为什么Java是半编译半解释语言</span></p><p><span style="color: #00BFFF;font-size:18px">JVM执行代码时将解释执行和编译执行两者结合起来进行</span></p><p><span style="color:#3CB371;font-size:24px">字节码是一种中间状态的二进制代码，比机器码抽象，需要直译器转译后才能成为机器码</span></p><p>为了实现特定软件运行和软件环境，和硬件环境无关</p><p>编译器将源码编译成字节码， 虚拟机器将字节码转译可以直接执行的指令</p><h3><span id="解释器的使用">解释器的使用</span></h3><p>为什么要加入字节码？</p><p>为什么不直接搞成JVM？   分割工作</p><p>解释器发展历史：</p><p>字节码解释器  效率低下，逐行翻译 </p><p>模板解释器  每条字节码和模板函数相关，模板函数直接产生这条字节码执行的机器码  提高性能</p><p>基于解释器执行： 低效</p><h3><span id="即时编译-jit编译器">即时编译  JIT编译器</span></h3><p>避免数被解释执行，将整个函数体编译成机器码    速度快</p><p><span style="color:#FA8072;font-size:24px">HotSpot采用的是解释器与即时编译器并存的架构，互相协作取长补短，选择最合适的方式去权衡编译本地代码</span></p><p>JVM启动时，解释器首先发挥作用，随着程序时间推移，JIT编译器逐渐发挥作用，热点探测，将有价值的字节码编译为本地机器指令，以换取更高的执行效率</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210307215507412.png" alt="image-20210307215507412"></p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210307220023296.png" alt="image-20210307220023296"></p><h4><span id="热点代码和探测方式">热点代码和探测方式</span></h4><p>何时使用JIT 编译器？ </p><p>针对运行时频繁调用的热点代码进行深度优化，直接编译为对应平台的本地机器指令   —–栈上替换 OSR</p><p>热点探测功能</p><p>基于计数器</p><p>JVM为每个方法建立2个不同的计数器  </p><ul><li><p>方法调用计数器   </p><p>统计方法的调用次数</p><p>阈值 1500 / 10000 次</p><p>-XX: CompileThreshold</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210307220456220.png"></p><p><span style="color: #DA70D6;font-size:24px">热度衰减</span></p><p>方法调用计数器统计的部署绝对次数，而是相对的执行效率，超过一定时间线度，如果调用次数仍然不足则会减少一半   ，半衰周期</p><p>-XX: UseCounterDecay  关闭热度衰减</p><p>-XX： CounterHalfLifeTime 设置半衰期时间   s</p></li><li><p>回边计数器   统计循环体执行的循环次数</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210307220949310.png" alt="image-20210307220949310"></p></li></ul><p>修改HotSpot的编译模式,会发生实质的时间变化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> s = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> e = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;==========&quot;</span> + (e-s));</span><br></pre></td></tr></table></figure><p>-Xcomp    即时编译 3759</p><p>-Xint     解释编译  9802</p><p>-Xmixed    3847  </p><p>可以看出，使用混合编译 和 即时编译模式下，相差不大，但解释编译时很慢且相差很大</p><p>HotSpot有 两个Jit 编译器  C1 和  C2  </p><ul><li><p>64位版本  JVM 默认 是-server模式  使用C2  耗时较长的优化，激进优化，优化的代码执行效率更高</p></li><li><p>-client 模式，C1编译器，  对字节码进行简单和可靠的优化，耗时短， 更快的编译速度</p></li></ul><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210307222415561.png" alt="image-20210307222415561"></p><p>分层编译策略</p><h3><span id="graal编译器和aot编译器">Graal编译器和AOT编译器</span></h3><p>AOT Ahead Of Time Compiler  程序运行之前，将字节码转换为机器吗  与JIT 编译器对比</p><h2><span id="stringtable">StringTable</span></h2><h3><span id="基本特性">基本特性</span></h3><p>不可变性  实现Serializebale接口 之处序列化   实现Comparable接口 可比较大小</p><p>JDK 8 后用的是char[]数组存储， JDK9之后使用byte[] + 编码标识存储</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210308080434960.png" alt="image-20210308080434960"></p><ul><li>在方法内部通过形参传递String对象， 内部改变，外部不会改变</li><li>底层是固定大小的HashTable  默认长度是1009，String 多时，Hash冲突，链表很长，影响String.intern</li><li>-XX:tringTableSize 调整长度</li><li>jdk 7 中默认长度是 60013</li><li>jdk8 长度要求最小值是1009</li><li>提高map长度，能够在一定程度提高String存储的效率</li></ul><h3><span id="string的内存分配">String的内存分配</span></h3><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210308082215487.png" alt="image-20210308082215487"></p><p><span style="color:red;font-size:24px">为什么Stringtable要调整</span></p><p>permsize默认比较小</p><p>永久代垃圾回收频率低</p><p><strong>编译期优化</strong></p><p><span style="color:orange;font-size:24px">如果拼接的符号前后出现了变量(不是常量)，则相当于在对空间中new String 地址就不一样了</span></p><p>String s2= s1+”123” != String s3 = s1 +s4;</p><p>String s3 = s1 +s2  字节码原理</p><p>new StringBuilder   调用的是append方法 append(s1)—&gt; append(s2) —&gt;StringBuilder. toStrihg方法</p><p>例如：</p><p>在循环体中 使用 string s = s +”123” 是很耗时的，因为每次拼接都new 一个StringBuilder 以及String    调用append方法，十分耗时！</p><p>StringBuilder 扩容优化  直接指定长度  个人测试后发现这里并不明显？？</p><h3><span id="intern">intern()</span></h3><p>确保字符串在内存中只有一份</p><p><span style="color:red;font-size:24px">面试题</span></p><ol><li><p>new String(“ab”) 会构建几个对象？</p><p>两个   </p><p>一个对象是new关键字在堆控件创建的</p><p>一个对象是字符串常量池中的对象，  ldc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> 0 new #4 &lt;java&#x2F;lang&#x2F;String&gt;</span><br><span class="line"> 3 dup</span><br><span class="line"> 4 ldc #5 &lt;123&gt;</span><br><span class="line"> 6 invokespecial #6 &lt;java&#x2F;lang&#x2F;String.&lt;init&gt;&gt;</span><br><span class="line"> 9 astore_1</span><br><span class="line">10 return</span><br></pre></td></tr></table></figure></li><li><p>new Sting(“a”) + new String(“b”)呢？</p><p>new String 创建在堆控件中</p><p>String a = “a”如果已经有a ，则是常量池中的对象</p><p><strong>6个</strong>  注意 + 的拼接操作是Stringbuilder  StringBuilder的toString 会再new 一个String </p><p><span style="color:orange;font-size:24px">toString方法在字符串常量池中没有该String！</span>验证后确实没有</p></li><li><p>在jdk 6 和 jdk7/8的区别</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210308162129529.png" alt="image-20210308162129529"></p><p> <img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210308165709630.png" alt="image-20210308165709630"></p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210308161926144.png" alt="image-20210308161926144"></p><p>如果变换string s4=”11”和s3.intern的位置后结果如何？</p></li></ol><p>​    jdk6 中 s3.intern 创建了新的对象“11”，也就是有新的地址   常量池在永久代中‘</p><p>如果常量池中没有，则复制一份，放入常量池中</p><p>​    jdk7 中 由于常量池放入堆空间中，他就直接拿堆空间的地址。 常量池记录的是堆空间“11”地址  只占四个字节</p><p>​    JDK 1.7后，intern方法还是会先去查询常量池中是否有已经存在，如果存在，则返回常量池中的引用，这一点与之前没有区别，区别在于，如果在常量池找不到对应的字符串，<strong>则不会再将字符串拷贝到常量池</strong>，而<strong>只是在常量池中生成一个对原字符串的引用</strong>。简单的说，就是往常量池放的东西变了：原来在常量池中找不到时，复制一个副本放到常量池，1.7后则是将在堆上的地址引用复制到常量池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>)+<span class="keyword">new</span> String(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">s1.intern();</span><br><span class="line">String s2 =<span class="string">&quot;12&quot;</span>;</span><br><span class="line">System.out.println(s1==s2);</span><br></pre></td></tr></table></figure><p><span style="color: #DA70D6;font-size:24px">疑问：为什么intern后再string s = “123”相同的字符串，这时java堆既有123在堆中引用，又有在常量池的对象，为什么比较还是一样的？</span></p><p>解答：创建s会直接去常量池中创建，但发现有这个对象了，创建的是指向原来堆中对象的一个引用     没看native层源码，不是非常清楚</p><p><span style="color:#FA8072;font-size:24px">易错例题</span></p><blockquote><p>Q：下列程序的输出结果：<br>String s1 = “abc”;<br>String s2 = “a”;<br>String s3 = “bc”;<br>String s4 = s2 + s3;<br>System.out.println(s1 == s4);<br>A：false，因为s2+s3实际上是使用StringBuilder.append来完成，会生成不同的对象。</p></blockquote><blockquote><p>Q：下列程序的输出结果：<br>String s1 = “abc”;<br>final String s2 = “a”;<br>final String s3 = “bc”;<br>String s4 = s2 + s3;<br>System.out.println(s1 == s4);<br>A：true，因为final变量在编译后会直接替换成对应的值，所以实际上等于s4=”a”+”bc”，而这种情况下，编译器会直接合并为s4=”abc”，所以最终s1==s4。</p></blockquote><p>​    <strong>实际操作中 添加多个相同的new String对象， intern成倍的影响速度</strong></p><h2><span id="垃圾回收">垃圾回收</span></h2><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210309154809269.png" alt="image-20210309154809269"></p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210309155016450.png" alt="image-20210309155016450"></p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210309155037374.png" alt="image-20210309155037374"></p><ul><li>垃圾： 运行程序中没有任何指针指向的对象</li></ul><p>GC的主要作用域 ： 方法区 和 堆</p><h3><span id="垃圾标记算法">垃圾标记算法</span></h3><h4><span id="对象存活判断">对象存活判断</span></h4><h5><span id="1-引用计数法">1. 引用计数法</span></h5><p>​    每个对象保留整型的引用计数器属性  记录对象被引用的情况 </p><p>​    引用时 +1 引用失效 -1</p><p>​    引用为 0 进行回收</p><p>​    优点： 简单，便于标识，判断效率高，回收无延迟</p><p>​    缺点： 单独的空间存储开销；每次加减 ，时间开销；<strong>无法处理循环引用的情况***</strong>（致命）**{相互引用，永不为0， 1–&gt;</p><p>​                2—&gt;3—&gt;2   放弃1时， 还存在 2–&gt;3–&gt;2的循环引用}  内存泄露</p><p>​    <img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210309161215885.png" alt="image-20210309161215885"></p><h5><span id="2-可达性分析算法">2. 可达性分析算法</span></h5><p>​    JVM 选用</p><p>​    有效解决了循环引用问题，防止内存泄漏发生、简单高效</p><ul><li><p>GC Roots ：一组必须活跃的引用</p><ol><li><p>按照<strong>GC Roots</strong> 为起始点，从上至下 搜索被根对象集合所连接的目标对象是否可达】</p></li><li><p>使用可达性分析算法后，内存中存活的对象都会被根对象集合 直接或间接连接，搜索所走过的路径称为<strong>引用链</strong></p></li><li><p>如果目标对象没有和任何引用链相连，则不可达，标记为垃圾对象</p></li></ol></li><li><p>GC Roots 可以是什么：</p><ul><li>JVM栈中对象  方法中的参数、局部变量……</li><li>JNI引用的对象</li><li>类静态属性引用的对象</li><li>常量引用的对象 （StringTable 中）</li><li>被synch持有的对象</li><li>JVM内部的引用 Class对象，系统内加载器</li><li>一个指针，保存了root堆内存的对象，但他自己又没有在堆里边，他就是一个root</li></ul></li></ul><h4><span id="对象的finaliztion机制">对象的finaliztion机制</span></h4><p>对象销毁之前可以自定义处理逻辑</p><p>对象回收之前会执行 finalize()方法 ，可以在子类重写该方法</p><p><span style="color:red;font-size:24px">永远不要主动的调用对象的finalize方法</span></p><ul><li>finalize可能导致对象复活</li><li>执行时间没有保障，由GC线程决定</li><li>可能影响GC性能</li></ul><p>虚拟机中对象的三种状态：</p><ol><li>可触及的</li><li>可复活的  所有引用被释放，但可能在finalize中复活</li><li>不可触及的  调用finalize 且没有复活</li></ol><p>判断一个对象是否可回收   至少两次标记</p><p><span style="color: #00BFFF;font-size:20px">理解finalize方法 — 一生只能使用一次的免死金牌</span></p><ol><li>到GC Roots没有引用连</li><li>筛选，判断是否有必要执行finalize<ol><li>没有重写 finalize方法 —-没必要    finalize方法被调用 —-没必要执行</li><li>重写了且未被执行   被插入F-Queue队列中   由优先级较低的Finalizer线程执行</li><li>finalize调用是对象唯一能复活的机会，稍后GC会对F-Queue的对象进行二次标记，如果在finalize中该对象和引用链任何一个对象建立了联系，则第二次标记，该对象会被移除“即将回收”集合， 如果伺候，对象再次出现没有引用存在的情况，这个时候由于一个对象的finalize方法只会执行一次，对象直接变成不可触及状态</li></ol></li></ol><p>finalize用法的最好实践</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Obj obj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        obj = <span class="keyword">new</span> Obj();</span><br><span class="line">        <span class="keyword">if</span>(obj != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;obj is alive&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        obj = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();<span class="comment">//一定要调用gc </span></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);<span class="comment">//注意点</span></span><br><span class="line">        System.out.println(obj == <span class="keyword">null</span>?<span class="string">&quot;null&quot;</span>:<span class="string">&quot;alive&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;xdm我要被回收了 救我&quot;</span>);</span><br><span class="line">        obj = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        obj is alive</span></span><br><span class="line"><span class="comment">        xdm我要被回收了 救我</span></span><br><span class="line"><span class="comment">        -----2s</span></span><br><span class="line"><span class="comment">        alive</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>​    注意点，这里为什么要休眠2s？ </p><p>​    Finalizer是低优先级的线程， 并发时 可能会有耗时 ，直接不休眠的话，会显示为null</p><p>​    </p><p>使用mat 和 JVisualVM 查看dump堆</p><p>JProfiler 进行GC溯源</p><h3><span id="垃圾清除算法">垃圾清除算法</span></h3><p>成功判断死活对象后，就是执行垃圾回收操作了，释放无用对象所占的空间</p><p>JVM常见的三种垃圾收集算法</p><ul><li>标记-清除算法</li><li>复制算法</li><li>标记-压缩算法</li></ul><h4><span id="标记-清除-算法">标记 - 清除 算法</span></h4><p>Mark - Sweep</p><p>堆中有效内存耗尽  — 停止整个程序 STW —标记 / 清除</p><ul><li>标记：Collector 从引用根节点开始遍历，标记所有<strong>被引用的对象</strong>  ，在对象头中记录为可达对象</li><li>清除：Collector对堆内存从头到尾遍历（所有），如果发现对象的对象头中没有标记为可达，则回收</li></ul><p>缺点：</p><ol><li>效率不高  两次遍历</li><li>GC时会STW</li><li>清理出的内存空间是不连续的，需要维护一个列表</li></ol><p>清除？</p><p><strong>清除不是置空，是把要清除的对象地址，保存在空间的地址列表中，下次有新对象要加载时，判断垃圾的位置空间是不是够，如果够就覆盖</strong></p><h4><span id="复制算法">复制算法</span></h4><p>解决 标记清除算法在垃圾收集效率的缺陷</p><p>将活着的内存分为两块，每次只使用一块，垃圾回收时，将使用的内存的存活对象复制（复制后的就是连续的空间了）到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换角色  (类比Survivor区)</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210309181613653.png" alt="image-20210309181613653"></p><p>优点：</p><ul><li>没有清除标记的过程，实现简单</li><li>复制后的空间是连续的，不需要空闲列表  ，使用指针碰撞</li></ul><p>缺点：</p><ul><li>始终可用的内存空间为1/2</li><li>G1 分拆成大量region的GC，复制需要维护region之间对象的引用关系，也有时间开销 （Java对象的访问方式）</li><li>系统中垃圾很多 —导致复制算法很慢   适用于Survivor区 （回收性价比高）</li></ul><h4><span id="标记-压缩算法">标记 - 压缩算法</span></h4><p>Mark - Compat</p><p>标记： 与 标记清除算法相同</p><p>压缩：所有存活的对象压缩到内存的一段，<strong>按照顺序排放</strong>，之后清理边界外的所有空间 </p><p> 差异： 移动式的 </p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210309183437564.png" alt="image-20210309183437564"></p><p>压缩 后内存规整  可以用指针碰撞</p><p>优点：</p><ul><li><p>消除了标记清除算法中内存区域分散的缺点、</p></li><li><p>消除了赋值算法中内存减半的高额代价</p></li></ul><p>缺点：</p><ul><li>效率 低于复制算法</li><li>移动对象时，如果对象被其他对象引用，还需要调整引用的地址</li><li>移动过程中 ，触发STW</li></ul><h4><span id="对比">对比</span></h4><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210309184113952.png" alt="image-20210309184113952"></p><h4><span id="分代收集算法">分代收集算法</span></h4><p>不同生命周期的对象采用不同的收集方式，提高回收效率 </p><p>几乎所有的GC都采用</p><ol><li><p>Young Gen 回收频繁、生命周期短    Coping</p></li><li><p>Old Gen 生命周期长、存活率高    Sweep 和 Compat 整合</p><p>Mark 阶段开销与<strong>存活对象</strong>正比</p><p>Sweep 与管理区域的大小成正相关（堆的遍历）</p><p>Compat 与存活对象的数据正比</p></li></ol><h4><span id="增量收集算法">增量收集算法</span></h4><p>基本思想：GC线程和主线程  交替进行并发清理垃圾，让用户感受不到STW</p><p>基础： Sweep 和 Compat</p><p>缺点：</p><p>线程切换和上下文转换有消耗，使得垃圾回收总成本上升，系统吞吐量下降</p><p>（同时做两件事，结果都做的不是很好）</p><h4><span id="分区算法">分区算法</span></h4><p>堆空间越大 GC时间越长</p><p>分割内存区域为多个小块 region ，减少目标停顿时间，每次合理地回收若干个小空间 而不是整个堆空间</p><h3><span id="概念">概念</span></h3><h4><span id="systemgy">System,gy()</span></h4><p>Runtijme.getRunTime().gc() 显示触发 Full GC </p><p>但是附带<strong>免责声明</strong>，无法保证对垃圾收集器的调用</p><p>调用System.runFinalization  强制调用使用引用对象的finalize方法</p><ul><li>主动gc的几种情况</li></ul><h4><span id="内存溢出">内存溢出</span></h4><p>定义： 没有空闲内存且垃圾收集器也无法提供更多内存（OOM前会进行一次Full GC）</p><h4><span id="内存泄露">内存泄露</span></h4><p>没有引用 ， 但GC不能进行回收</p><p>例如： 单例模式、未调用close方法</p><h4><span id="stw">STW</span></h4><p>可达性分析算法中枚举根节点 GC Roots导致所有的Java线程停顿</p><ul><li>确保分析工作在一个一致性的<strong>快照</strong>中进行，例如JVisualVm生成 堆dump 不同时间是不同的</li><li>一致性指整个分析期间 整个执行系统 像被冻结在某个时间点上</li><li>如果分析过程中对象的引用关系还在不断变化，则分析结果的准确性也无法保证</li></ul><p>JVM后台自动发起STW 开发中不要用STW</p><p>理解代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4><span id="垃圾回收的并行和并发">垃圾回收的并行和并发</span></h4><p>并发</p><p>几个程序处于启动状态且都在同一个处理器上完成，时间片</p><p>（在同一时间段发生）</p><p>垃圾回收的并行：  多条垃圾收集线程并行工作，仍在 STW</p><p><span style="color:red;font-size:24px">多核中并发是怎样的</span></p><p>并行</p><p>系统多个CPU或者多核时，一个CPU一个核执行一个进程与另一个CPU或者另一个核同时执行一个线程，就是并行 </p><p>（在同一时间点发生）</p><p>垃圾回收的并发 ：用户线程和垃圾收集线程同时进行（交替），不会引起STW</p><p>垃圾收集程序在一个核  用户程序在另一个核</p><h4><span id="安全点和安全区域">安全点和安全区域</span></h4><h5><span id="安全点">安全点</span></h5><p>并不是所有的地方都可以立马停下来 GC   必须在特定的地方停下来 即 Safe Point</p><p>安全点太少 —-  GC等待时间过长</p><p> 太多 —- 性能问题</p><ul><li><p>抢先式中断（未采用）</p><p>暂停所有线程，如果有线程不在安全点上，就回复线程，让线程跑到安全点上</p></li><li><p>主动式中断</p><p>设置中断标志，各个线程跑到Safe point去看这个 标志，如果是真的，则挂起</p></li></ul><h5><span id="安全区">安全区</span></h5><p>程序block时无法响应 JVM中断   — Safe region 解决</p><p>一段代码片段， 对象的引用关系不变， 任何位置开始GC都是安全的（二维的safe point）</p><p>实际执行</p><ol><li>线程跑到safe region时，标识进入了safe region 如果发生GC， 则JVM忽略标识为Safe Region的线程</li><li>准备离开Safe region时，会检查JVM是否完成 GC，如果完成了则继续运行，如果没完成GC，则线程必须等待，知道收到了GC完成的命令 才会离开Safe region</li></ol><h3><span id="引用">引用</span></h3><p>希望有这么一群对象，内存空间够，就在这，不够，就把他抛弃</p><p><span style="color:red;font-size:24px">强引用、软引用、弱引用、虚引用有什么区别，具体使用场景是什么？</span></p><h4><span id="强引用">强引用</span></h4><p>new Object  无论任何情况，只要强引用关系还在，垃圾收集器就永远不会回收掉被引用的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Student s1 = <span class="keyword">new</span> Student();</span><br><span class="line">Student s2 = s1;</span><br><span class="line">s1 = <span class="keyword">null</span>;</span><br><span class="line">System.gc();</span><br><span class="line"><span class="comment">//sleep</span></span><br><span class="line">syso s2.name;</span><br></pre></td></tr></table></figure><p>上述结果能输出s2的名字，因为由于是强引用，s1虽然没有引用了，但s2仍然持有堆空间中对象的引用，所以full gc时没有被清理</p><h4><span id="软引用soft">软引用Soft</span></h4><p>OOM前 或者 内存<strong>快要满了</strong>，将会把这些对象放入回收范围中进行二次回收，如果回收内存不够，才会报OOM</p><p>注意软引用的使用方式  –  使用后要把强引用给置空，使得强引用无效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   Teacher1 teacher = <span class="keyword">new</span> Teacher1();</span><br><span class="line">   SoftReference&lt;Teacher1&gt; softReference = <span class="keyword">new</span> SoftReference&lt;Teacher1&gt;(teacher);</span><br><span class="line">   teacher = <span class="keyword">null</span>;</span><br><span class="line">   softReference.get().setName(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">   <span class="comment">//System.out.println(teacher.getName()); Null pointer</span></span><br><span class="line"><span class="comment">//-Xms10m -Xmx10m</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>];</span><br><span class="line">   &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">   &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">       System.out.println(softReference.get().getName());</span><br><span class="line">       <span class="comment">// nullpointer</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4><span id="弱引用weak">弱引用Weak</span></h4><p>只能生存到下一次垃圾收集之前</p><h5><span id="weakhashmap">WeakHashMap</span></h5><p>存储图片信息，内存不足，自动清理   内部Entry继承了WeakReference</p><h4><span id="虚引用phantomreference">虚引用PhantomReference</span></h4><p>唯一目的，对象被收集器回收前收到系统的通知，记录回收时间</p><p>需要指定引用队列</p><p>get拿不到对象</p><h2><span id="垃圾回收期">垃圾回收期</span></h2><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210322141038714.png" alt="image-20210322141038714"></p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210322141151403.png" alt="image-20210322141151403"></p><p>-XX PrintCommandlineflags 查看默认垃圾收集器</p><h3><span id="指标">指标</span></h3><p><strong>吞吐量</strong>： 运行用户代码时间占总运行时间的比例</p><p>垃圾收集开销： 吞吐量的补数，垃圾收集所用时间与总运行时间比例</p><p><strong>暂停时间</strong>：一个时间段内应用程序线程暂停让GC线程执行</p><p>内存占用：Java堆区所占的内寸大小</p><p> 吞吐量优先 与 注重暂停时间：</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210322150414860.png" alt="image-20210322150414860"></p><ul><li>高吞吐量：用户感觉只应用线程在做工作，运行快</li><li>低暂停时间：交互更好</li><li>两者相互矛盾</li></ul><p><strong>现在的标准： 在最大吞吐量优先情况下，降低暂停时间</strong></p><h3><span id="serial">Serial</span></h3><p>串行收集器： 单线程 只使用一个CPU或一条收集线程完成垃圾收集工作  还会触发 STW</p><p> 年代久远Client 模式下默认  、 复制算法 、STW、串行回收</p><p><strong>Old</strong></p><p>标记-压缩</p><p>Client模式默认</p><p>Server模式 与新生代ParallelScavenge配合  、 CMS后备垃圾收集方案</p><p>串行收集器采用单线程stop-the-world的方式进行收集。当内存不足时，串行GC设置停顿标识，待所有线程都进入安全点(Safepoint)时，应用线程暂停，串行GC开始工作，采用单线程方式回收空间并整理内存。单线程也意味着复杂度更低、占用内存更少，但同时也意味着不能有效利用多核优势。事实上，串行收集器特别适合堆内存不高、单核甚至双核CPU的场合。</p><p><strong>优点</strong></p><p>简单高效   没有线程交互的开销 </p><p>适用单核 、 嵌入式</p><p>-XX ：+UserSerialGC</p><h3><span id="parnew">ParNew</span></h3><p>Parllel New 对新生代并行回收</p><p>新生代回收次数频繁，用并行高效</p><p>复制算法 – STW</p><p><strong>是否ParNew的并行收集就一定比Serial串行快？</strong></p><p>​    单CPU环境下，ParNew就没有Serial收集器高，因为这时CPU不需要频繁地做任务切换，因此可以有效避免线程交互过程中不必要开销</p><p>-XXL ParallelGCThreadss num     限制线程数量 default 和CPU数据相同的线程</p><h3><span id="parallel">Parallel</span></h3><p>复制、并行、STW</p><p>年轻代采用复制算法，老年代采用标记-整理，在回收的同时还会对内存进行压缩</p><p>与ParNew不同点：</p><ul><li><p>吞吐量优先，目的为到达可控制的吞吐量</p></li><li><p>自适应调节策略</p></li></ul><p>高吞吐量 高效利用CPU时间 适合在后台运算不需要太多交互、服务器中</p><p>JDK1.6 用Parallel Old 替代了 老年代的Serial Old</p><p>-XX +UseParallel(Old)GC  互相激活</p><p>-XX：ParallelGCThreads num 设置年轻代并行收集器线程数</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210322145201261.png" alt="image-20210322145201261"></p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210322145313728.png" alt="image-20210322145313728"></p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210322145728931.png" alt="image-20210322145728931"></p><h3><span id="cms">CMS</span></h3><p>Concurrent Mark Sweep  针对老年代 —ParNew</p><p>低延迟，第一次实现了让垃圾收集线程和用户线程同时工作</p><p>尽可能缩短垃圾收集时用户线程的停顿时间</p><p>G1 整体上采用标记-整理算法，局部是通过复制算法，不会产生内存碎片。</p><p>垃圾收集算法采用标记-清除算法</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210324080947878.png" alt="image-20210324080947878"></p><ul><li>初始标记 ：STW 标记GC Roots <strong>直接</strong>关联到的对象</li><li>并发标记：从直接关联对象开始遍历整个对象图的过程，释放内存空间，与用户线程同时运行</li><li>重新标记：STW 修整并发标记期间，标记产生变动的对象。时间稍短</li><li>并发清除：清理删掉标记阶段判断的已经死亡的对象，释放内存空间、</li></ul><p>并发时期，要确保程序用户线程有足够的内存可以用。因此CMS收集器不能像其他收集器那样等到老虎年代几乎被填满再回收。当堆内存使用率达到一定阈值，便开始回收，确保应用程序在CMS工作过程中，依然有足够的控件支持应用程序运行。如果CMS运行期间预留的内存无法满足程序需要，就会出现一次Concurrent Mode Failure失败，JVM启动后备方案，用Serial Old收集器重新进行老年代的垃圾收集，停顿时间长</p><p>缺点： </p><ul><li>标记清除算法，产生碎片，只能选择空闲列表执行内存分配，不能放入大对象</li><li>对CPU资源敏感，并发时占用一部分线程，总吞吐量降低</li><li>无法处理<strong>浮动垃圾</strong>：用户线程产生新的垃圾，并发标记时产生的垃圾无法被标记（注意 重新标记是修成并发标记已标记的对象，即已经是垃圾的可能又不是垃圾了[保险操作]）</li></ul><p><strong>为什么不换成Mark Compact？</strong></p><p>压缩时会对内存进行整理，但是清理的时候是并发执行的，不能改变使用对象的地址</p><p>JDK9 废弃   JDK14 已经把CMS移除了</p><p>-XX：+UseConcMarkSweepGC 手动指定使用CMS</p><p>-XX: CMSlinitialtingOccupanyFraction  设置堆内存使用率阈值  默认 92   </p><h3><span id="g1">G1</span></h3><p>区域化分代式</p><p>JDK 9 开始采用，面向服务端应用</p><p>适应不断扩大的内存和不断增加的处理器数量  降低暂停时间且兼顾良好的吞吐量</p><p><strong>为什么 叫G1?</strong></p><p>​    并行收集器，划分堆内存  ，使用不同Region表示Eden Survivorws Old Gen等</p><p>垃圾优先：</p><p>​    G1 GC 有计 划避免了这个堆中进行全区域的垃圾回收，跟踪不同的Region垃圾堆积的价值大小，回收所获得的空间大小与回收所需时间的经验值。  维护一个优先列表，根据允许的收集时间，优先回收价值最大的Region</p><p><strong>特点：</strong></p><ol><li><p>并行并发兼具：</p><p>有多个GC线程工作，利用多核  STW</p><p>能够与应用程序交替执行，不会STW</p></li><li><p>分代收集：</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210324084815558.png" alt="image-20210324084815558"></p><p>堆空间分成若干Region，可以不连续而且每个小区域的角色是可以变换的？？？？</p><p>G1同时兼顾老年代和年轻代。</p></li><li><p>空间整合：</p><p>内存回收以region为基本单位，region之间是复制算法，但整体可以看成是Mark Compact算法（因为分region）。有利于程序长时间运行</p></li><li><p>可预测的停顿时间模型(软实时 Soft Real-Time)</p><p>让使用者明确指定在长度为M ms时间段内，消耗在垃圾收集上的时间不得超过N ms  – 尽可能</p><p>根据允许的收集时间，优先回收价值高的region    收集效率高  </p></li></ol><p>JVM GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程</p><p><strong>适用场景：</strong></p><p>服务端，大内存，多处理器</p><p>50%Java堆活动数据占用、对象分配频率或年代提升频率变化大、GC停顿时间长</p><p><strong>分区Region</strong></p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210324091225275.png" alt="image-20210324091225275"></p><p>划分整个堆为2048个大小相同的独立Region 每个region控制在1 - 32 M 之间，每个region大小相同，在JVM生命周期内不会被改变。新生代和老年代通过region的动态分配实现逻辑上的连续</p><p>G1还增加了新的内存区域  Humonogous 存储大对象。因为将一个短期存在的大对象放入老年代，会对垃圾收集器造成影响。如果单个H区装不下一个大对象，会找一个连续的H区存储，如果还找不到就Full GC了  ，可将H区看做老年代但不完全相等</p><p>对单个Region  分配规则类似指针碰撞，也可以在region中给单个线程分配TLAB</p><p>内存占用、额外执行负载 比CMS高      （记忆集）</p><p>小内存应用上 CMS优于 G1  大内存G1更优</p><p><strong>参数：</strong></p><p>-XX:+UseG1GC</p><p>-XX:G1HeapRegionSize region  num   大小，2的 num 次方，范围是1m — 32m</p><p>–XX:MaxGCPauseMills 设置期望的最大GC停顿时间   默认 200ms</p><p>-XX ParallelGCThread  STW工作线程数，最多 8 </p><p>-XX ConcGCThreads 设置并发标记的线程数   n设置为并行垃圾收集线程数的1/4左右</p><p>-XX InitiaingHeapOccupancyPercent  触发并发GC周期的Java堆占用阈值，超过此值 触发 GC，默认45</p><p>​    <strong>垃圾回收过程</strong></p><ol><li><p>YoungGC</p></li><li><p>老年代并发标记过程concurrent Marking</p></li><li><p>Mixed GC</p></li><li><p>如果需要，Full GC还是存在的，提供一种失败保护机制，强力回收  — 单线程、独占式、高强度</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210326155145913.png" alt="image-20210326155145913"></p></li></ol><h4><span id="remeberedset-记忆集">RemeberedSet 记忆集</span></h4><ul><li>一个对象可能被不同区域的对象引用  Old区 引用了 Eden区 。判断对象是否存活，是否要扫喵整个堆？  </li><li>回收新生代，不得不扫描老年代 ， 降低Minor GC效率</li></ul><p>解决</p><ul><li>使用RemberedSet进行全局扫描</li><li><strong>每个Region都有一个Remebered Set</strong></li><li>每次引用类型数据进行写操作时，都会有一个Write Barrier  （写屏障） 中断 ， 检查要写入的引用指向的对象是否和该引用类型数据在不同的region</li><li>如果不同，通过CardTable把相关引用信息记录到引用指向对象所在region对应的RS 中(本体)</li><li>进行垃圾收集时，在GC根节点的枚举范围加入RS，保证不进行全局扫描也不会有遗漏</li></ul><h4><span id="回收具体过程">回收具体过程</span></h4><p><strong>YoungGC</strong></p><p>Eden空间，G1触发YoungGC  只回收Eden Survivor区 </p><p>YoungGC 首先G1停止STW ，G1创建回收集 CS ，即需要背回收的内存分段集合，YoungGC 的 CS包含Eden区和Survivor、区的所有内存分段</p><p> <img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210326161642195.png" alt="image-20210326161642195"></p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210326162531425.png" alt="image-20210326162531425"></p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210326162602055.png" alt="image-20210326162602055"></p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210326164133102.png" alt="image-20210326164133102"></p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210326164237342.png" alt="image-20210326164237342"></p><p><a href="https://blog.csdn.net/coderlius/article/details/79272773">https://blog.csdn.net/coderlius/article/details/79272773</a></p><h1><span id="深入篇">深入篇</span></h1><h2><span id="字节码">字节码</span></h2><h3><span id="编译">编译</span></h3><p>javac编译器</p><p>将java源码编译成字节码的前端编译器   IDEA 默认</p><p>类似的  ECJ (Eclipse Compiler for Java) 编译效率高，编译时并非全量编译，只编译为编译部分的源码进行编译</p><p>Eclipse 和 Tomcat默认使用</p><h4><span id></span></h4><p><span style="color:red;font-size:24px">Integer的自动装箱</span></p><p>内置的IntegerCache</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer a = <span class="number">127</span>;</span><br><span class="line">Integer b = <span class="number">127</span>;</span><br><span class="line">System.out.println(a == b);</span><br><span class="line"><span class="comment">//false </span></span><br><span class="line"><span class="comment">//字节码 比较时涉及到intValue方法</span></span><br><span class="line"><span class="comment">//new时涉及valueOf方法 </span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">        <span class="comment">//可以自行设置max的最大值</span></span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>涉及到的静态内部类的知识</p><p>静态内部类只会在使用到该内部类时才会加载，否则是不会加载的，也就是只有使用到new Integer的valueOf方法时，才会加载该内部类</p><h3><span id="概念">概念</span></h3><p>字节码指令是一个一个字节长度，代表某种特定含义的操作码，以及跟随其后的参数—操作数构成的。</p><h4><span id="class文件">Class文件</span></h4><p>不一定以磁盘文件形式存在，是一组以8字节为基础单位的二进制流</p><p>存储格式   无符号数 + 表</p><p>无法包含注释信息</p><ul><li><p>无符号数： 基本数据类型   用u1、u2、u4.、u8.. 表示多少个字节的无符号数</p></li><li><p>表： 由多个无符号数或者其他表作为数据项构成的复合数据类型  </p><p>表又_info 结尾    整个class文件就是一张表</p></li></ul><h3><span id="class文件结构">Class文件结构</span></h3><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210313171015628.png" alt="image-20210313171015628"></p><h4><span id="魔数">魔数</span></h4><p>cafebabe  识别字节码文件  4个字节的无符号整数</p><h4><span id="class文件版本">Class文件版本</span></h4><p>主版本、副版本  — 依据JDK</p><p>向下兼容： 高版本JVM可运行低版本JDK编译器生成的class文件</p><p>UnsupportedClassVersionError</p><h4><span id="常量池">常量池</span></h4><p>字面量从1开始而不是从0 开始  但是计数器从0开始计数</p><p>存放字面量和符号引用 — 类加载时放在方法区的运行时常量池中</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210315163802015.png" alt="image-20210315163802015"></p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210315162456278.png" alt="image-20210315162456278"></p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210315162921696.png" alt="image-20210315162921696"></p><p>解析</p><p>第一个字节指出是什么类型（Constant-utf8_info之类的），然后在看对应类型 有什么样的字节，具体会不一样</p><h4><span id="访问标志">访问标志</span></h4><h4><span id="类索引-父类索引-接口索引集合">类索引、父类索引、接口索引集合</span></h4><h4><span id="字段表集合">字段表集合</span></h4><h4><span id="方法表集合">方法表集合</span></h4><h4><span id="属性表集合">属性表集合</span></h4><h2><span id="查漏补缺篇">查漏补缺篇</span></h2><h3><span id="担保机制">担保机制</span></h3><p>survivor区装不下了怎么办</p><h3><span id="晋升原理">晋升原理</span></h3><p>大对象是如何分配的</p><h3><span id="string">String</span></h3><p>String 作为参数在方法内部改变为什么不会改变实际的值</p><h3><span id="类加载机制">类加载机制</span></h3><h4><span id="类加载">类加载</span></h4><p>将Java类的字节码文件加载到内存中  并在内存中构建出java类的原型，类模板对象</p><ul><li><p>通过类的全名，获取类的二进制数据流</p><p>获取方式：</p><ul><li>class文件</li><li>jar zip文件</li><li>数据库中的二进制</li><li>http网络协议</li><li>运行时动态生成Class的二进制信息</li></ul></li><li><p>解析类的二进制数据流为方法区的数据结构  Java类模型</p></li><li><p>创建java.lang.Class 类的实例，表示该类型，作为方法区这个类的各种数据的访问入口</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210320150701121.png"></p><p>数组类型的加载，数组类本身并不由类加载器负责创建。由JVM运行时根据需要直接创建的，数组的元素类型仍然需要依靠类加载器创建 ，如果数组的元素类型是引用类型，则数组类的可访问性就由元素类型的可访问性决定，缺省定义为public</p></li></ul><h4><span id="链接">链接</span></h4><h5><span id="验证">验证</span></h5><p>保证加载的字节码合法 规范</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210320151441865.png" alt="image-20210320151441865"></p><p><strong>格式验证</strong></p><p>和加载过程一起进行，验证通过后，类加载器才会成功将该类的二进制数据信息加载到方法区中，格式验证之外的操作在方法区中运行</p><p><strong>语义验证</strong></p><p>是否素有的类都有父类的存在</p><p>是否一些定义为final的方法或者类被重写或者继承了</p><p>非抽象类是否实现了所有抽象方法 或者接口方法</p><p>是否存在不兼容的方法  方法的签名除了返回值都一样的情况</p><p><strong>字节码验证</strong></p><p>较为复杂的过程</p><p>字节码执行过程中，是否会跳转到一条不存在的指令、</p><p>函数调用是否传递了正确类型的参数</p><p>变量</p><p>赋值是不是给了正确的数据类型</p><p>栈映射帧  – StackMapTable用于检测在特定的字节码出，局部变量表和操作数栈是否有正确的数据信息</p><p><strong>符号引用</strong></p><p>检查 自己要使用其他类 或者方法 是否存在    （在字符串常量池中）</p><h5><span id="准备">准备</span></h5><p>为类的静态变量分配内存</p><p>注意点：java并不支持boolean  对于boolean 内部实现是int，默认值是0，故boolean的默认值就是false    </p><ul><li>不包含基本数据类型用static final修饰的情况，因为final在编译时分配，且在准备阶段会显示赋值</li><li>非final修饰的变量，解析阶段进行默认初始化赋值，final修饰后，在解析环节直接显示赋值</li><li>final类变量不能声明 但不复制</li><li>如果以非自变量的形式 初始化static final String ，不会像有具体的代码执行</li></ul><h5><span id="解析">解析</span></h5><p>将常量池中类、接口、字段、方法的 符号引用转换为直接引用  （真实内存中的地址）</p><p>例如 JVM为每个类准备了方法表， 调用一个类的方法时，只要知道这个方法在方法表中的偏移量就可以直接调用该方法。通过解析操作，符号引用就转变为目标方法在<strong>类中方法表的位置</strong></p><h4><span id="初始化">初始化</span></h4><p>显示赋值  装载的最后一个阶段</p><p>方法的调用 、 构造器的支持  则在clinit中调用</p><p>重要工作 ： 执行类的初始化方法 clinit </p><ul><li><p>该方法只能由Java编译器 生成并由JVM调用</p></li><li><p>由类静态成员的赋值语句以及static语句块合并产生的</p></li><li><p>静态的类变量，如果没有显示赋值，则不会调用clinit方法</p></li><li><p>显示赋值的static final 常量 – 在准备阶段已经显示赋值了，不会调用clinit方法</p></li><li><p>引用数据类型显示赋值都是在初始化阶段，基本类型 通过库方法赋值 也会在初始化阶段 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> num = <span class="keyword">new</span> Random().nextInt(<span class="number">199</span>);</span><br></pre></td></tr></table></figure></li></ul><h4><span id="clinit的线程安全性">clinit的线程安全性</span></h4><p>多线程环境被正确的加锁、同步 。多线程中尝试加载一个类，没抢到锁的会阻塞，若clnit中有耗时很长的操作，可能引发死锁    </p><p>clnit中方法 Access flags访问标识  无synchronized  隐式锁</p><h4><span id="类的主动使用和被动使用">类的主动使用和被动使用</span></h4><p>区别： 是否会调用clinit方法</p><p>注意点： <strong>没有初始化的类 不一定没有加载</strong></p><h5><span id="主动使用">主动使用</span></h5><ol><li>new 、反射、克隆、反序列化</li><li>调用类的静态方法  inovokestatic</li><li>使用类、接口的静态字段时 <ul><li>如果不是final，则就是主动使用</li><li>如果是final 类型， 则如果是字面量形式，则不是主动使用，如果是函数形式 比如 a = new Random().nextInt类型，当尝试调用a时，则是主动使用（因为函数形式的赋值都在clinit中执行）</li></ul></li><li>Class.forName()   </li><li>子类构造时会先进行父类的初始化 -XX traceClassLoad 输出所有类加载顺序<ul><li>初始化类时，不会先初始化他锁实现的接口，但会加载这个接口Load</li><li>初始化接口时，不会初始化他的父接口，但是也会加载Load</li></ul></li><li>接口定义了default方法，直接、间接实现该方法接口的类初始化（只要使用到了这个接口的字段或者方法的） 都会导致这个接口在这之前初始化</li><li>初始化main所在类</li><li>MethodHandle</li></ol><h5><span id="被动使用">被动使用</span></h5><ol><li>访问静态字段，只有真正声明这个字段的类才会被初始化<ul><li>通过子类引用父类的静态变量，不会导致子类初始化，但子类会加载</li></ul></li><li>声明对象数组，不复制，不会引起初始化</li><li>引用常量不会的触发类或者接口的初始化  （链接阶段已经赋值）</li><li>ClassLoader的loadClass方法加载一个类，不是对类的主动使用，注意与forName区分开</li></ol><h4><span id="类卸载-unloading">类卸载 Unloading</span></h4><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210322092551016.png" alt="image-20210322092551016"></p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210322092757484.png" alt="image-20210322092757484"></p><p>一个类结束生命周期，关键在于其Class对象 结束生命周期</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210322093200611.png" alt="image-20210322093200611"></p><p>不太可能</p><h3><span id="动态绑定与静态绑定">动态绑定与静态绑定</span></h3><p>Java对对象属性 是静态绑定 ，方法是动态绑定</p><p><strong>根据father在堆中实际创建的对象类型Son来确定f1方法所在的位置</strong></p><p>调用虚方法时，Java采用的是<strong>延迟绑定 / 动态分派</strong>的语义，根据被调用对象（receiver）的实际类型来决定选择哪个版本的虚方法。</p><p>重载的方法在编译时根据参数的<strong>声明类型</strong>静态绑定到具体方法上，与运行时该参数的实际类型无关</p><p>方法的重载是静态编译</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     Father f = <span class="keyword">new</span> Son();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">new</span> Test1().get(f);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">get</span><span class="params">(Father father)</span></span>&#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;fatherfather&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span> <span class="params">(Son son)</span></span>&#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;sonso3n&quot;</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3><span id="双亲委派机制">双亲委派机制</span></h3><p>JDK  1.2</p><p><strong>优点</strong></p><ol><li>避免类重复加载，确保类的全局唯一性 — GC 有关？</li><li>安全，避免构造同包的恶意代码 </li></ol><p>沙箱安全机制</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210404170719177.png" alt="image-20210404170719177"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web学习</title>
      <link href="2019/08/22/Web%E5%AD%A6%E4%B9%A0/"/>
      <url>2019/08/22/Web%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1><span id="java-web-知识">JAVA WEB 知识</span></h1><!-- toc --><ul><li><a href="#%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE">知识回顾</a></li><li><a href="#web%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BD%AF%E4%BB%B6">Web服务器软件</a></li><li><a href="#tomcat">Tomcat</a><ul><li><a href="#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84">目录结构</a></li><li><a href="#%E8%BF%90%E8%A1%8C">运行</a></li><li><a href="#%E9%9D%99%E6%80%81%E9%A1%B9%E7%9B%AE%E4%B8%8E%E5%8A%A8%E6%80%81%E9%A1%B9%E7%9B%AE">静态项目与动态项目</a></li><li><a href="#%E7%94%A8ieda-%E9%85%8D%E7%BD%AEtomcat">用IEDA 配置TOMCAT</a></li></ul></li><li><a href="#servlet">Servlet</a></li></ul><!-- tocstop --><hr><h2><span id="知识回顾">知识回顾</span></h2><pre><code>1. IP： 计算机在网络中的唯一标识2. 端口号： 应用程序在计算机中的唯一标识 0~655363. 传输协议： 规定数据传输的规则 1. 基础协议：    1. Tcp： 安全协议，三次握手，速度稍慢    2. Udp：不完全，速度快</code></pre><h2><span id="web服务器软件">Web服务器软件</span></h2><ul><li>服务器：安装了服务器软件的计算机</li><li>服务器软件：接受用户请求，处理请求，做出响应</li><li>Web服务器软件：结束后用户请求，处理请求，作出响应<ul><li>web服务器软件，可以部署web项目，用户通过浏览器来访问项目</li><li>web容器</li></ul></li></ul><span id="more"></span><h2><span id="tomcat">Tomcat</span></h2><h3><span id="目录结构">目录结构</span></h3><ol><li>bin ： 可执行文件</li><li>conf：配置文件</li><li>lib：启动依赖的jar包</li><li>logs： 日志文件</li><li>temp：临时文件</li><li><strong>webapps</strong>：放入web项目文件</li><li>work：存放运行时数据</li></ol><h3><span id="运行">运行</span></h3><ol><li><p>启动方式： bin–startup.bat</p></li><li><p>查找： </p><ol><li>127.0.0.1:8080</li><li>localhost:8080</li><li>自己的ip:8080</li></ol></li><li><p>修改端口号： conf–server.xml—-“port”</p></li><li><p>关闭：</p><ol><li>正常关闭： <ul><li>shutdown.bat</li><li>ctrl+c(命令行中)</li></ul></li><li>强制关闭：<ul><li>直接关闭.bat窗口，可能造成文件损失、未保存</li></ul></li></ol></li><li><p>部署：</p><ol><li><p>直接放项目进入webapps （/项目文件夹/html）</p></li><li><p>简单部署：</p><ol><li>直接将html用war打包软件成.war格式</li><li>直接复制到webapps 中</li><li>war包自动解压缩</li></ol></li><li><p>配置conf/server文件</p><ul><li><p>&lt;HOST </p><p>&lt;Context docbase=”xxx” path=”/xxxx “即替换为xxxx</p></li></ul></li><li><p>conf-Catalina-Localhost -创建xml文件，复制3中的代码</p><p>​    <context docbase="xxx ">即可</context></p><p>虚拟目录： xml文件的名称  (推荐)（不需要重启服务器）</p></li></ol></li></ol><h3><span id="静态项目与动态项目">静态项目与动态项目</span></h3><p>动态项目：</p><ul><li>web-inf  <ul><li>web.xml 项目的核心配置文件</li><li>calsses目录：字节码文件</li><li>lib：依赖的jar包</li></ul></li></ul><h3><span id="用ieda-配置tomcat">用IEDA 配置TOMCAT</span></h3><h2><span id="servlet">Servlet</span></h2><ul><li><p>概念：运行在服务器端的小程序</p><ul><li>其实就是一个借口，定义了 java类被浏览器访问到的规则</li></ul></li><li><p>实际操作：</p><ol><li>创建java EE项目</li><li>写入servlet包</li><li>创建类 实现 servlet接口 </li><li>配置servlet —于 web.xml中配置servlet</li></ol></li><li><pre><code class="xml"> &lt;servlet&gt;        &lt;servlet-name&gt;demo_1&lt;/servlet-name&gt;        &lt;servlet-class&gt;Servelet.Myservlet_1&lt;/servlet-class&gt;    &lt;/servlet&gt;      &lt;servlet-mapping&gt;        &lt;servlet-name&gt;demo_1&lt;/servlet-name&gt;        &lt;url-pattern&gt;/urldemo_1&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  1. 先通过urlpattern 判断 地址是否和输入相等</span><br><span class="line">  2. 相等则上移，找到servelet-name</span><br><span class="line">  3. servlet-name 再找到servlet</span><br><span class="line">  4. servlet再下移到servet-class</span><br><span class="line">  5. 加载类进入内存 Class.forname....</span><br><span class="line">  6. 创造类对象   getInstance()</span><br><span class="line">  7. 实现方法</span><br><span class="line"></span><br><span class="line">### Servlet 生命周期</span><br><span class="line"></span><br><span class="line">1. init() Servlet被创建时执行 一次</span><br><span class="line">   * 可以通过在&lt;servlet&gt;标签下配置改变 servlet的创建时机</span><br><span class="line">   * &lt;load -on-startup&gt; x&lt;&#x2F;load -on-startup&gt;</span><br><span class="line">   * x: 负数  ： 第一次被访问时</span><br><span class="line">   * x: 0或正整数   ：服务器启动时</span><br><span class="line">2. service() 每一次Servlet被访问时执行（页面的刷新） 多次</span><br><span class="line">3. destroy() Servlet被关闭时执行  一次</span><br><span class="line">   * 条件： 服务器**正常关闭** (临终遗言)</span><br><span class="line"></span><br><span class="line">### Servlet 3.0</span><br><span class="line"></span><br><span class="line">1. 好处： 支持注解配置，不用xml</span><br><span class="line">2. 关键步骤： **类上使用@Servlet注解**，可以不用web.xml</span><br><span class="line"></span><br><span class="line">### Servlet 体系结构</span><br><span class="line"></span><br><span class="line">1. Servlet </span><br><span class="line"></span><br><span class="line">2. GenericServlet</span><br><span class="line"></span><br><span class="line">   * 抽象类 不用将Servlet接口类的方法完全实现。其他方法为空实现，更简洁 一点， 一般还是不用</span><br><span class="line"></span><br><span class="line">3. HttpServlet</span><br><span class="line"></span><br><span class="line">   * 封装类，比较常用，不用再判断请求方式是GET&#x2F;POST</span><br><span class="line">   * 复写 doGet &#x2F;doPost 方法</span><br><span class="line"></span><br><span class="line">   一个Servlet能够定义多个访问路径</span><br><span class="line"></span><br><span class="line">4.  定义方式： </span><br><span class="line"></span><br><span class="line">   * &#x2F;user   路径匹配</span><br><span class="line">   * &#x2F;user&#x2F;aaa  多层路径</span><br><span class="line">   * &#x2F;user&#x2F;* ：哪种都可以访问到</span><br><span class="line">   * *.do  ： 前面加什么都可以，后面必须跟do   扩展名匹配</span><br><span class="line"></span><br><span class="line">## HTTP 超文本传输</span><br><span class="line"></span><br><span class="line">### **1. Hyper Text Translation Protocol**</span><br><span class="line"></span><br><span class="line">* 目的： 定义了客户端和服务器通信时，发送的数据格式</span><br><span class="line"></span><br><span class="line">* 特点： </span><br><span class="line">  1. 基于TCP&#x2F;IP的高级协议</span><br><span class="line">  2. 默认端口号 ：80</span><br><span class="line">  3. 基于响应和请求一一对应的模式</span><br><span class="line">  4. 无状态的： 每次请求间相互独立，每次请求一个资源都是独立的，分步进行的</span><br><span class="line">* 历史版本：</span><br><span class="line">  * 1.0 每一次 请求都会重新建立链接</span><br><span class="line">  * 1.1 复用了链接，节约资源</span><br><span class="line"></span><br><span class="line">### 2. 请求消息数据格式</span><br><span class="line"></span><br><span class="line">1. 请求行</span><br><span class="line"></span><br><span class="line">   * 请求方式 请求url 请求协议&#x2F;版本 </span><br><span class="line"></span><br><span class="line">     (GET&#x2F; login.html HTTP&#x2F;1.1)</span><br><span class="line"></span><br><span class="line">     * GET： </span><br><span class="line">       1. 请求参数在请求行中</span><br><span class="line">       2. 请求url长度有限</span><br><span class="line">       3. 不太安全</span><br><span class="line">     * POST: </span><br><span class="line">       1. 请求参数在请求体中（专门封装了）</span><br><span class="line">       2. 请求url长度无限</span><br><span class="line">       3. 相对安全</span><br><span class="line"></span><br><span class="line">2. 请求头 ： 浏览器告诉服务器的信息</span><br><span class="line"></span><br><span class="line">   * 请求头名称： 请求头值（键值对）</span><br><span class="line"></span><br><span class="line">     常见的请求头:</span><br><span class="line"></span><br><span class="line">     * User-Agent: 浏览器告诉服务器，所使用的的浏览器版本信息，解决浏览器兼容问题  包含浏览器的关键字（Chrom Firfox......） </span><br><span class="line">     * Accept: 解析什么样格式的页面</span><br><span class="line">     * ......</span><br><span class="line">     * Referer：告诉服务器  当前请求从哪里来 （防止盗取连接、便于统计工作）</span><br><span class="line">       * 盗取超链接：referer来判断当前请求连接是否在指定网站 获取而来</span><br><span class="line">       * 统计工作：</span><br><span class="line">     * Connection: 连接是否能被复用</span><br><span class="line"></span><br><span class="line">3. 请求空行</span><br><span class="line"></span><br><span class="line">   * 空行</span><br><span class="line"></span><br><span class="line">4. 请求体（正文）：</span><br><span class="line"></span><br><span class="line">   * 封装post请求小心的请求参数  例如：</span><br><span class="line"></span><br><span class="line">     username&#x3D;111;</span><br><span class="line"></span><br><span class="line">   1. 从流对象中拿去数据</span><br><span class="line"></span><br></pre></td></tr></table></figure>GET /Tomcat_2_war_exploded/index2.html HTTP/1.1Host: localhost:8080Connection: keep-aliveCache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.105 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Sec-Fetch-Site: noneSec-Fetch-Mode: navigateSec-Fetch-User: ?1Sec-Fetch-Dest: documentAccept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9Cookie: JSESSIONID=1B454411C9ADDC7AAFFE3D5BF306E302</code></pre></li></ul><h3><span id="3-request">3. Request</span></h3><ol><li><p>原理</p><ol><li>Request Response对象 均由服务器创建，我们使用</li></ol></li><li><p> Request： 获取请求操作</p></li><li><p>继承结构：</p><ul><li>ServletRequest 接口</li><li>HttpServletRequest  继承该接口 仍然是接口</li><li>Tomcat 中的类 RequestFacede来实现 该接口</li></ul></li><li><p>Request 功能：</p><ol><li><p>获取请求行数据</p><ul><li><p>获取请求方式 String getMethod();</p></li><li><p><strong>获取虚拟目录</strong> String getContextPath();</p></li><li><p>获取Servlet 路径: /demo1   getServletPath();</p></li><li><p>获取get方式请求参数 getQueryString();</p></li><li><p>**获取请求的URI ** getRequestURL()</p><ul><li>URL: 统一资源定位符   </li><li>URI: 统一资源标识符   范围&gt;URL </li></ul></li><li><p>获取协议和版本： getProtocal()</p></li><li><p>获取客户机的IP: getRemoteAddress();</p></li></ul></li><li><p>获取请求头数据</p><ol><li>方法：<ul><li>getHeader（name） ：通过请求头名称获取请求头的值</li><li>getHeaderNames(): 获取所有请求头的名称</li></ul></li></ol></li><li><p>获取请求体数据</p><p>步骤：</p><ol><li>获取流对象<ul><li>bufferedReader getReader() 字符数据流</li><li>ServletInputStream getInputStrea() 获取字节输入流</li></ul></li><li>从流对象中拿去数据</li></ol></li></ol></li><li><p>其他功能：</p><ol><li>获取请求参数通用方式： <ol><li>getParameter(string) 根据参数名称获取参数值</li><li>getParameterValues（） 返回参数名称返回参数值的数组（复选框）</li><li>getParameterNames() 获取所有请求的参数名称</li><li>Map&lt;str,str[]&gt; getParameterMap() 获取所有参数的map集</li></ol></li><li>中文乱码问题：<ul><li>get 方式在tomcat 8 已经 被解决</li><li>post 在输入中文时易乱码</li><li>在获取参数前修改 编码 使其跟html编码相同</li><li>request.setcharartorEncoding（”utf-8”）</li></ul></li><li>请求转发： 一种在服务器内部的资源跳转方式<ol><li>request. getrequestdispatcher(/uri).forward(request,respose)</li><li>特点： <ol><li>浏览器地址栏路径 未发生变化 </li><li>只能转发到<strong>当前的服务器</strong>内部资源中</li><li>转发 是一次请求，多个资源间使用同一个请求 </li></ol></li></ol></li><li>共享数据：<ol><li>域对象： 一个有作用范围的对象，可以再范围    内共享数据</li><li>request域： 代表一次请求，一般用于请求转发的多个资源共享数据</li><li>方法：<ol><li>setAttribute(name,obj) 存储数据</li><li>getAttribute(name) 通过键获取值</li><li>removeAttribute(String name) 通过键删除值</li></ol></li></ol></li><li> 获取ServletContext（）  对象</li></ol></li></ol><h3><span id="4-响应消息数据格式">4. 响应消息数据格式</span></h3><ol><li>响应行<ul><li>组成 ：协议/版本  响应状态码  状态码描述</li><li>响应状态码： 服务器告诉客户端 浏览器本次请求和响应的一个状态</li><li>状态码都是三位数字<ul><li><ol><li>1XX: 服务器服务器接收客户端消息 未接收完成，等待一段时间后 发送1xx 状态码</li><li>2XX： 接收成功！ </li><li>3XX： 302: 重定向  资源跳转   304: 缓存</li><li>4XX：客户端错误<ol><li>404： 请求路径无对应资源</li><li>405：请求方式没有对应的doPost/doGet方法</li></ol></li><li>5XX：服务器端错误（比如 类中方法异常）</li></ol></li></ul></li></ul></li><li>响应头<ol><li>常见的响应头：<ol><li>Content-type： 服务器告诉客户端响应头的数据格式、编码格式</li><li>Content-dispostion： 服务器告诉客户端 以什么格式打开响应头<ol><li>in-line 默认值： 在当前页面打开</li><li>attachment： 以附件形式打开（弹出新窗口）</li></ol></li></ol></li></ol></li><li>响应空行</li><li>响应体<ol><li>发送的数据 ，<html>形式</html></li></ol></li></ol><h3><span id="5-response对象">5. Response对象</span></h3><p>功能：设置响应消息 </p><ol><li><p>设置响应行</p><ol><li>设置状态码： setStatus(int x)</li></ol></li><li><p>设置响应头</p><ol><li>setHeader(String name,String value)</li></ol></li><li><p>设置响应体</p><ol><li><p>获取输出流</p><ol><li><p>字符输出流 getWriter()</p><ol><li><p><strong>获取流对象之前</strong>设置编码： resp.setCharsetEncodeing(“xxx”)</p></li><li><p><strong>设置浏览器编码</strong></p><p>resp.setHeader(“content-type”,”text/html;charset=utf-8”)</p></li><li><p><strong>简单形式</strong>： </p><p>resp.setContentType(“text/html;charset=utf-8”)</p></li></ol></li><li><p>字节输出流 getoutputStream()</p><ol><li>op.write(“xx”.getBytes(“utf-8”))</li><li>也要setContentType！</li><li>字节输出流一般用于输出图片</li></ol></li></ol></li><li><p>使用流，将数据输出到客户端浏览器</p></li></ol></li></ol><h4><span id="案例">案例：</span></h4><ol><li><p>重定向的特点：</p><ol><li>地址栏发生变化 </li><li>可以访问其他服务器的资源”<a href="http://www.baidu.com&quot;/">www.baidu.com&quot;</a></li><li>两次请求，不能再用request对象共享数据</li></ol></li><li><p>转发的特点</p><ol><li>服务器地址不变</li><li>只能访问当前服务器下的资源</li><li>一次请求，可以用request对象共享数据</li></ol></li><li><p>路径写法：</p><ol><li><p>相对路径： 不能确定唯一资源</p><ul><li><p>./index.html  </p></li><li><p>不以/开头 ，以. 开头</p></li><li><p>规则：确定访问当前资源和目标资源的相对关系</p><ul><li>语法 : ./当前目录</li></ul><p>​        ../ 后退一级的目录</p></li></ul></li><li><p>绝对路径：确定唯一资源</p><ul><li>​    如 :http:///ssxxxx.x..xx..x       /xxx/xxx</li><li>​    以 /开头的</li><li>规则： 定义的路径给谁用<ul><li>给客户端用： 加虚拟目录</li><li>给服务器： 不用加虚拟目录</li></ul></li></ul></li><li><p>动态获取虚拟目录</p><ul><li>req.getContextPath(),获取上一级目录</li></ul></li></ol></li></ol><h3><span id="servletcontext-interface">ServletContext    (interface)</span></h3><ol><li><p>代表： 整个Web应用，可以和程序的容器（服务器）来通信</p></li><li><p>获取方式：</p><ol><li>req.getServletContext();</li><li>this.getServletContext();(必须继承HttpServlet)</li></ol></li><li><p>功能：</p><ol><li><p>获取MIME类型：</p><ul><li>MIME: 互联网通信过程中定义的一种文件数据类型<ul><li>比如： text/html    image/jpeg</li></ul></li><li>获取： getMimeType(str file)</li></ul></li><li><p>域对象：共享数据</p><ol><li>setAttribute()</li><li>getAttribute()</li><li>removeAttribute()<ul><li>servletContext域的范围:所有用户请求的数据（类似于一个全局的类对象），使用要谨慎，而且其生命周期很长</li></ul></li></ol></li><li><p>获取文件的真实路径</p><ol><li><p> getRealPath(str)</p></li><li><p>“/b.txt” —Web 目录下的</p></li><li><p>“/WEB-INF/b.txt”  —WEB-INF目录下的</p></li><li><p>“/WEB-INF/classes/a.txt”  —-src目录下的</p><p>因为会自动存储在WEB-INF的classes中的</p></li><li><p>注意： ClassLoader只能获取src下的路径（局限）</p></li></ol></li></ol></li></ol><h2><span id="cookie"><strong>Cookie</strong></span></h2><ol><li><p>会话： 一次会话中包含的多次请求和响应</p><ol><li>一次会话： 浏览器第一次给服务器发送请求，直到一方断开为止</li></ol></li><li><p>功能：在一次会话范围内的多次请求间 **共享数据 **</p></li><li><p>方式：</p><ol><li><p>客户端会话： Cookie  数据存入到客户端</p><ol><li><p>使用步骤：</p><ol><li>创建对像   API  绑定数据</li><li>发送Cookie</li><li>获取Cookie，拿到数据</li></ol></li><li><p>创建： new Cookie();</p><ul><li>resp.addCookie(cookie)带着Cookie 去下一个地方</li><li>req.getCookies()</li></ul></li><li><p>实际原理：</p><ul><li>响应头 ： set-cookie: msg=hello, 变成了键值对的形式，客户端会把这个数据保存到本地，然后带到第二个请求的请求头中 Cookie: msg=hello</li></ul></li><li><p>Cookie 细节：</p><ol><li>一次能发送多个Cookie吗？</li></ol><ul><li>可</li></ul><ol start="2"><li><p>Cookie在浏览器重的保存时间</p><ul><li>Cookie 不设置下，关闭浏览器再访问就没有了</li><li>设置生命周期：<ul><li>setMaxAge（int seconds）</li><li>在创建Cookie时使用</li><li>x&gt;0 持久化写入到硬盘文件，x代表存活秒数，关闭浏览器再打开，也可以访问到</li><li>x&lt;0 默认值</li><li>x=0 删除信息</li></ul></li></ul></li><li><p>Tomcat 8 之后才能直接存中文 </p></li><li><p>Cookie 获取范围</p><ol><li>setPath（） 设置虚拟目录</li><li>同一个服务器下的多项目</li></ol></li><li><p>Cookie  单个：4kb</p><p>​                同一个域名下 ：20个</p></li><li><p>Cookie 用来存储<strong>少量不太敏感</strong>的情况</p></li><li><p>在不登陆的情况下，完成<strong>服务器对客户端</strong>的识别</p></li></ol></li></ol></li></ol></li></ol><h2><span id="session">Session</span></h2><ol><li><p>request.getSession（） getAttribute setAttribute remove….</p></li><li><p>仅此在一次会话中访问对象  ， 关闭浏览器就没有了 </p></li><li><p>原理：依赖于Cookie</p></li><li><p>细节：</p><ol><li><p>客户端关闭后，两次获取的session不是同一个</p><p>默认不是，设置： 用Cookie保存 id</p></li><li><p>客户端不关闭，服务器关闭后两次获取的session不是同一个</p><p>但要确保数据不丢失</p><ul><li> session的钝化： 服务器正常关闭前，将session对象序列化存到硬盘上</li><li>session的活化： 服务器启动后，将session文件转化到内存中的session对象</li></ul></li><li><p>销毁：</p><ol><li>服务器关闭</li><li>调用invaliddate方法</li><li>30min后自动关闭</li></ol></li><li><p><strong>session可存储任意大小任意 的数据  ， 更安全</strong></p></li></ol></li></ol><h2><span id="jsp-java-server-pages">JSP (Java Server Pages)</span></h2><ol><li>概念：既可以有html标签 也可以有java代码   </li><li>目的：简化书写</li><li>原理<ul><li>JSP 本质上就是一个Servlet<ul><li>.jsp —-&gt; .java/.class</li></ul></li></ul></li><li>JSP脚本： 声明java代码的方式    <ol><li>&lt;% ……   %&gt;：定义的java代码，在service方法中可以定义的都可</li><li>&lt;%!  …%&gt;：定义成员变量和成员方法</li><li>&lt;%= ..%&gt;：输出语句 ，（输出成员变量值）</li><li>内置对象： request  response out，其凡是在jspService中定义的，都可以用<ol><li><strong>response 缓冲永远先于 out 输出不论顺序</strong>，会先找到response缓冲区并拼接到service中</li><li>所以：尽量不用response.getWriter()写</li></ol></li><li>可以截断： 在中部用{ } 阶段 并插入html语句</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库 学习</title>
      <link href="2019/07/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/"/>
      <url>2019/07/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1><span id="数据库学习">数据库学习</span></h1><!-- toc --><ul><li><a href="#mysql">Mysql</a><ul><li><a href="#1-ddl">1. DDL :</a></li><li><a href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93crud-%E5%8A%9F%E8%83%BD-%E5%88%9B%E5%BB%BA-%E6%9F%A5%E8%AF%A2-%E6%9B%B4%E6%96%B0-%E5%88%A0%E9%99%A4">操作数据库：CRUD 功能    （创建、查询、更新、删除）</a><ul><li><a href="#1%E6%9F%A5%E8%AF%A2%E4%B8%8E%E5%88%9B%E5%BB%BA">1.查询与创建</a></li><li>[show databases、  create database  xxx  、show create  database xxx(查询名称和字符类型)](#show-databases-create-database-xxx-show-create-database-xxx查询名称和字符类型)</li></ul></li></ul></li><li><a href="#%E6%93%8D%E4%BD%9C%E8%A1%A8">操作表</a></li><li><a href="#dml-%E5%A2%9E%E5%88%A0%E6%94%B9%E8%A1%A8%E4%B8%AD%E6%95%B0%E6%8D%AE">DML 增删改表中数据</a></li><li><a href="#dql-%E6%9F%A5%E8%AF%A2%E8%A1%A8%E4%B8%AD%E8%AE%B0%E5%BD%95">DQL 查询表中记录 （*）</a></li><li><a href="#%E5%A4%96%E9%94%AE%E7%BA%A6%E6%9D%9F">外键约束</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%8C%83%E5%BC%8F">数据库设计范式</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E8%BF%98%E5%8E%9F">数据库的备份和还原</a></li><li><a href="#%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2">多表查询</a></li><li><a href="#%E4%BA%8B%E5%8A%A1">事务</a></li><li><a href="#dcl-%E7%AE%A1%E7%90%86%E7%94%A8%E6%88%B7%E6%8E%88%E6%9D%83">DCL ：管理用户，授权  ：</a></li><li><a href="#jdbc-template-%E4%B8%8E-%E8%BF%9E%E6%8E%A5%E6%B1%A0">JDBC Template 与 连接池</a><ul><li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0">数据库连接池</a></li><li><a href="#spring-jdbc-jdbc-template">Spring JDBC–JDBC Template</a></li></ul></li></ul><!-- tocstop --><h2><span id="mysql">Mysql</span></h2><h3><span id="1-ddl">1.  DDL :</span></h3><h3><span id="操作数据库crud-功能-创建-查询-更新-删除">操作数据库：CRUD  功能    （创建、查询、更新、删除）</span></h3><h4><span id="1查询与创建">1.查询与创建</span></h4><h4><span id="show-databases-create-database-xxx-show-create-database-xxx查询名称和字符类型">show databases、  create database  xxx  、show create  database xxx(查询名称和字符类型)\</span></h4><p>​        create database xxx if not exists XX(不会报错)  </p><p>​        create database xx character set xxx(utf-8)</p><p>​        可以连用语句   create database xxx if not exists XX character set xxx</p><span id="more"></span><ol start="2"><li><p>修改</p><p>alter database xxx  character set xxxx        设置已创建的数据库的字符类型</p></li><li><p>删除</p><p>​    drop database  (if exists xxx)  *要先转到当前的database</p><p>4.使用数据库</p></li></ol><p>​            查询当前的数据库   Select database();</p><p>​            使用数据库                use xxxx;</p><h2><span id="操作表">操作表</span></h2><p>​        CRUD</p><ol><li><p>查询    show tables；</p><p>查询表结构  desc xxx(表名)</p></li><li><p>创建    create table xxx（</p><p>​            列名1  数据类型1，</p><p>​            列名2  数据类型2，</p><p>​            ……..</p><p>​            列名n  数据类型n</p><p>​            ); </p><p>数据库中的数据类型(int 、double（n,m）最多n位，小数点后m位</p><p>​                                、date（yyyy-MM-dd）、datetime(yyyy-mm-dd HH:mm:ss)</p><p>​                                timestamp（时间戳，若不给这个字段赋值，则默认使用当前系统时间）</p><p>​                                varchar(需指定最大字符)</p><p>)</p></li></ol><p>3.删除          drop table xxx /   (if exists xxx)</p><p>4.修改表      修改表名 :  alter table xxx rename to （newxxx）</p><p>​                    修改表的字符集  :alter table xxx character set utf-8</p><p>​                    添加一列  ：    alter table xx add aaa(new colume)  bbb(数据类型)</p><p>​                    修改列名 类型： alter table 表名 change 列名 新列名字  新数据类型 </p><p>​                                                alter table 表名  modify 列名 新数据类型</p><p>​                    删除列： alter table 表名 drop 列名; </p><h2><span id="dml-增删改表中数据">DML 增删改表中数据</span></h2><ol><li><p>添加数据</p><p>​            insert into (表名)(column , ~, , ,) values  (x,x,x)  // 列名与值必须对应</p><p>​            inster into （表名）valuse （xxxxx）给所有的行列加上值，否则报错</p></li></ol><p>​                  除了数字类型，其他的必须引号，单双都可</p><p>​    2. 删除数据</p><p>​                    delete from (table) where xxx (condition) 没有where 条件的话则完全删除</p><pre><code>                Truncate table 删除表中所有记录  比  deleye from table  效率更高</code></pre><p>​    3. 修改数据：</p><p>​            update table set colume =x1, …… (where  ,,,,)一样可以加入条件<br>​            不加条件则会将表中所有数据 都更改         </p><h2><span id="dql-查询表中记录">DQL 查询表中记录 （*）</span></h2><hr><ol><li>普通查询   select * from 表名</li><li>语法：  select  字段列表   from 表名列表 where 条件列表  group by 分组字段  <br>          order by 排序   limit  分页限定<br>          去除重复关键字：  DISTINCT<br>         起别名关键字： AS xxx      </li><li>基础查询：<br> 1. 多个字段的查询：  <br>            select (DISTINCT)xxx  ,yyy   from table <br>             select (DISTINCT)xxx +yyy   (AS 总分)  from table 求总合且能够换名字 <br>             select (DISTINCT)xxx +IFNULL(yyy,0)   from table 解决null无法相加问题</li><li>条件查询<br> 1.  条件语句中的= 只有一个=符号  <br> 2. &lt;&gt; 与!=  等价    、可以用&amp;&amp;但推荐使用 AND<br> 3. BETWEEN  AND 关键字 也能处理中间量</li><li>模糊查询<br> setlect * from table WHERE  xxx LIKE ‘_ /‘%’<br> _  :  单个字符  %  :多个字符<br> —若前面没有字符 ‘’%x%” 一样能查出该条数据！！</li><li>排序查询：’<br> select     …  order by xxx DESC/ASC ,aaa …（降序、升序）</li><li>聚合函数：(运算会排除null值)<br> count \max\min\sum\avg<br> select xxx(colume) from table ;<br> select count (ifnull (column,0)) from student;（将null值替换为0）</li><li>分组查询：<br> select sex ,avg(column) AS 平均值，count (id) from table Where … GROUP BY sex Having count(column)…;<br> —AS xxx 起别名，注意逗号<br> —其后可以跟 聚合函数<br> —条件语句在 GROUP BY 之前    <strong>不满足 则不参与分组</strong><br> —聚合函数在 GROUP BY 之后 且有having关键字  <strong>不满足 则不显示</strong></li><li>分页查询：<br> select * from student LIMIT a,b;<br> —a : 起始的页数 (0是第一条)  b: 结尾的页数+1 [a,b);</li></ol><h2><span id="外键约束">外键约束</span></h2><ol><li><p>创建： create table xxx(</p><p>​            外键列</p><p>​            costraint 外键名 foreign key （外键列名称）（此处括号必须加）                      references 主表名称(主表列名称)（一般是主键）</p><p>);</p><p>*<em>外键关联后主表不能被删除</em> * </p></li></ol><p>​    2.删除 ： Alter  table xxx drop foreign key 外键名;</p><p>​    3.添加：  Alter  table xxx add costraint 外键名 foreign key 外键列名称 references 主表名称(主表列名称)（一般是主键）;</p><ol start="4"><li><p><em><strong>级联</strong></em>  （外键可以为NULL ）</p><ul><li>创建表后级联更新：Alter table （foreign table） ADD CONSTRAINT ……..         ON UPDATE  CASCADE;  (ON DELELTE CASCADE)</li></ul></li></ol><hr><h2><span id="数据库设计范式">数据库设计范式</span></h2><p><strong>目的：解决数据库中的问题</strong></p><ol><li>第一范式： 每一列都是不可分割的原子数据项</li><li>第二范式：在第一范式基础上，非码属性必须完全依赖于候选码<ul><li>函数依赖 ： 通过A属性（组）的值 可以确定 唯一B属性的值  (B依赖于A)</li><li>完全函数依赖： A是属性组  则B属性值的确定 需要A属性组中<strong>所有的属性值</strong></li><li>部分函数依赖： A是属性组  。。。。。。。只需要依赖A中的部分属性值</li><li>传递函数依赖：A (组)确定 唯一B， B(组)  确定唯一C  则C传递函数依赖于A</li><li>码： 一张表中的 一个属性或属性组被其他所有属性完全依赖，则这个属性为该              表的码<ul><li>主属性：码属性组中的所有属性</li></ul></li></ul></li><li>第三范式，在第二范式基础上，任何非主属性不依赖其他非主属性</li></ol><h2><span id="数据库的备份和还原">数据库的备份和还原</span></h2><ol><li>命令行：<ul><li>mysqldump -uuser -ppassword xxx(database)&gt;path</li><li>使用备份文件 source path;</li></ul></li></ol><hr><h2><span id="多表查询">多表查询</span></h2><pre><code>* 语法：select * from  aaa,bbb,......（笛卡尔积方式）</code></pre><ul><li>多表查询的分类<ol><li>内连接查询：<ol><li>隐式内连接查询：<br> Select *(emp.name)  from aaa,bbb WHERE emp.id=dept.id;<br> 规范写法<br> Select t1.name,t2.name <pre><code> from  emp t1, dept t2     WHERE t1.id=t2.id;</code></pre></li><li>显示内连接：<br> select xxx from table (INNER) JOIN table2 on emp.id=dept.id;</li></ol></li><li>外连接查询：<br>   左外连接：<pre><code>   SELECT XX FROM TABLE LEFT [OUTER] JOIN table2 ON                     table.id=table2.id;   **查询左表所有数据以及交集部分 （避免on 查询中的空值现象）** </code></pre>   右外连接：同上</li><li>子查询：<pre><code> 1. 结果是单行单列：     可作为条件，用运算符判断 （比如avg max...） 2. 结果是多行单列(多个id值)     in(......) 3. 结果是多行多列的     子查询可作为一张虚拟表，作为表的查询</code></pre></li></ol><hr><h2><span id="事务">事务</span></h2><pre><code>1. 基本介绍   * 概念：包含多个操作的业务，被事务管理时，要么同时成功要么同时失败（例如转账）  * 操作：      * 1. 开启事务-start transaction;      * 2. 回滚-rollback(发现问题时回滚);      * 3. 提交-commit;      * Mysql数据库中事务默认自动提交:一条DML自动提交一次事务      （Oracle是手动提交的）       查看默认提交方式 select @@autocommit       修改 ：  set ......... =0； （手动提交）2.事务的四大特征    1. 原子性： 是不可分割的最小操作单位     2. 持久性： 事务一旦提交或回滚，数据库将持久的保存数据    3. 隔离性： 多个事务之间，相互独立    4. 一致性： 事务操作前后，数据总量不变（守恒）3.事务的隔离级别    * 概念： 多个事务操作同一批数据，引发一些问题，设置隔离级别便可以解决                 这些问题    * 存在问题：        1. 脏读： 一个事务读取到另一个事务中未提交的数据        2. 不可重复读（虚读）：同一个事务中两次得到的数据不一致        3. 幻读：一个事务操作DML数据表中所有记录，另一个事务添加了一条                         数据，则第一个事务查询不到自己的修改    * 隔离级别：        1. read uncommitted： 读未提交 （脏读、虚度、幻读）        2. read committed ： 读已提交 （不可重复读，幻读）        3. repeatable read：可重复度 （幻读）(默认)        4. seriablizable： 串行换（解决所有问题）    * 查询隔离级别：        select @tx_isolation;    *设置： set global transaction isolation level ....;</code></pre><h2><span id="dcl-管理用户授权">DCL  ：管理用户，授权  ：</span></h2>DBA: 数据库管理员：<ol><li>管理用户： <ul><li>查询：切换mysql数据库， 查询user表<br>  % 表示可以再任意主机使用用户登录数据库</li><li>创建： Create user ‘namexxx@’主机名’ indentified by ‘password’</li><li>删除： DROP USER ‘namexxx@’主机名’ </li></ul></li><li>修改用户密码：<br> UPDATE USER SET password = password(‘xxx’) where user =’xxx’’<br> set password dor ‘name’@’zhuji’ =password(‘newpassword’)’<br> 忘记密码后：<pre><code>  1. net stop mysql  ---停止服务 （需要管理员权限）  2. mysqld --skip-grant-tables---使用无验证方式启动  3. 打开新的cmd 窗口，直接输入mysql 命令  4. user mysql  5. 使用命令更改 .....  6. 关闭窗口  7. 打开任务管理器，手动结束mysqld进程</code></pre></li><li>授权：<ol><li>查询权限<br> show grants for ‘user’@’hostxxx’;</li><li>授予权限<br> grant 权限列表 on xxxdatabase .xxxtable to ‘xxxUser’@’host’;<br> all（所有权限） </li><li>撤销权限<br> revoke xxx on xxxdatabase.xxtable to  ‘xxxUser’@’host’;</li></ol></li></ol></li></ul><hr><h2><span id="jdbc-template-与-连接池">JDBC Template 与 连接池</span></h2><h3><span id="数据库连接池">数据库连接池</span></h3><ol><li>目的：（避免使用后就开除的现象） 节约用户时间，重复使用连接对象。</li><li>概念： 容器。存放数据库连接，系统初始后容器被创建，容器中申请一些连接对象，用           户访问数据库时，从容器中获取连接对象，访问后将归还这些连接对象</li><li>有点： 节约资源， 用户访问高效</li><li>实现：<ol><li>接口：datasource <ul><li>方法getConnection()获取连接</li><li>若是从连接池中，则connection.close（）代表归还这一个 连接</li><li>由数据库厂商来实现</li></ul></li><li>C3P0:数据库连接池技术<ol><li>导入jar包 以及依赖的jar包 放入libs中 </li><li><strong>定义配置文件(properties OR xml )并 直接放入src目录</strong><br> *一个配置文件可以有多个配置 ，以配置名区别<ul><li>设置URL user password </li><li>设置最大连接数与超时连接秒数</li></ul></li><li>创建核心对象<br> DataSource ss = new ComboPooledDataSource（x）<br> 参数为空： 默认配置<br> 参数为Configname：指定配置<br> Connection con=ds.getConnection</li><li>连接</li></ol></li><li>Druid：数据库联机吃实现技术，by阿里巴巴    （性能好）<ol><li>导入jar包</li><li>配置文件 <ul><li>properties </li><li>可以任意名称 任意路径，不自动加载 </li></ul></li><li>获取数据库连接池对象 ：通过工厂类获取<br> ds=DruidDataSourceFactory.creteDataSource（需要pro对象） thiscalss.class.getClassloaaer()..getReourcesAsStream(“xxx.xx”)</li><li>连接<br> conn=ds.getConnection();</li></ol></li><li>**定义工具类 **</li></ol><h3><span id="spring-jdbcjdbc-template">Spring JDBC–JDBC Template</span></h3><pre><code> *Spring 框架对JDBC的简单封装 1.导入jar包 2.创建jdbctemplate对象，依赖于dataSource     jdbctemplate t=new jdbctemplate(ds） 3.调用其中方法完成crud操作**（建议查看源码）**     1. update(sql,?1，？2,?3,?4....)         不需要手动关闭连接 .......自动归还连接     2. queryformap() **（只能是一个数据行）**     3. queryforlist()  可先将每个计划 封装成map 再 将map作为list的泛型     4. query() 返回对象为javabean         1. 参数（sql,new RowMapper&lt;T&gt;()&#123;                  &#125;）；匿名内部类，自己实现查找方式         2. （sql，new BeanPropertyRowMapper&lt;T&gt;(T.class)）             注意：对于数据表中为null的值，普通类型无法识别，会报错，这里使用包装类 进行解决     5. querForobject (sql, xxx.class（xxx:数据类型）)</code></pre></li></ol><p>A</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="2019/03/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>2019/03/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1><span id="数据结构">数据结构</span></h1><!--toc--><h2><span id="二叉搜索树">二叉搜索树</span></h2><h3><span id="添加">添加</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node.i&lt;<span class="keyword">this</span>.i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.left = node;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.left.addNode(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.right = node;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.right.addNode(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>中序遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">midLook</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    midLook(root.left);</span><br><span class="line">    System.out.println(root.i);</span><br><span class="line">    midLook(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>层序遍历</p><p><strong>优先队列方式！</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">floorList</span><span class="params">(Node root)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    LinkedList&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    Node node ;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        node = queue.poll();</span><br><span class="line">        System.out.println(node.i);</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.add(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题</title>
      <link href="2019/01/22/LeetCode%E5%88%B7%E9%A2%98/"/>
      <url>2019/01/22/LeetCode%E5%88%B7%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1><span id="leetcode-刷题">LeetCode 刷题</span></h1><!-- toc --><ul><li><a href="#jz-03-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0">JZ-03. 两数相加</a><ul><li><a href="#%E6%80%9D%E8%80%83">思考：</a></li><li><a href="#1-%E5%9F%BA%E4%BA%8E%E5%93%88%E5%B8%8C%E8%A1%A8">1. 基于哈希表</a></li><li><a href="#2-%E5%8E%9F%E5%9C%B0%E7%BD%AE%E6%8D%A2-nb">2. 原地置换  nb</a></li></ul></li><li><a href="#jz-04-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE">JZ-04. 二维数组中的查找</a><ul><li><a href="#%E8%A7%82%E5%AF%9F">观察：</a></li><li><a href="#1-%E8%87%AA%E5%B7%B1%E6%83%B3%E7%9A%84%E7%9F%A9%E9%98%B5%E5%88%86%E5%89%B2%E6%B3%95">1. 自己想的矩阵分割法</a></li><li><a href="#2-%E7%BF%BB%E8%BD%AC%E7%9F%A9%E9%98%B5-%E7%BA%BF%E6%80%A7%E6%90%9C%E7%B4%A2">2. 翻转矩阵 / 线性搜索</a></li></ul></li><li><a href="#jz-10-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6">JZ-10. 青蛙跳台阶</a><ul><li><a href="#%E6%80%9D%E8%80%83">思考</a></li><li><a href="#1-%E9%80%92%E5%BD%92%E8%B6%85%E6%97%B6">1. 递归（超时）</a></li><li><a href="#2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">2. 动态规划</a></li></ul></li><li><a href="#jz-14-i-%E5%89%AA%E7%BB%B3%E5%AD%90">JZ-14 -I 剪绳子</a><ul><li><a href="#%E6%80%9D%E8%80%83-1">思考：</a></li><li><a href="#o-1">O (1):</a></li></ul></li><li><a href="#jz-22-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9">JZ-22. 链表中倒数第k个节点</a><ul><li><a href="#%E6%80%9D%E8%80%83-1">思考</a></li><li><a href="#1-%E9%80%92%E5%BD%92%E5%AF%BB%E6%89%BE">1. 递归寻找？</a></li><li><a href="#2-%E5%8F%8C%E6%8C%87%E9%92%88-%E7%9C%9F%E5%A6%99%E5%95%8A">2. 双指针 真妙啊</a></li><li><a href="#%E6%80%9D%E8%80%83-2">思考：</a></li></ul></li><li><a href="#jz-24-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8">JZ-24. 反转链表</a><ul><li><a href="#%E6%80%9D%E8%80%83-2">思考</a></li><li><a href="#1-%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84-pre-%E6%8C%87%E9%92%88%E4%BB%A3%E7%A0%81">1. 自己写的 pre 指针代码</a></li><li><a href="#2-%E5%8F%8C%E6%8C%87%E9%92%88">2. 双指针</a></li><li><a href="#3-%E9%80%92%E5%BD%92">3. 递归</a></li></ul></li><li><a href="#jz-47-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC">Jz-47. 礼物的最大价值</a><ul><li><a href="#1-%E9%80%92%E5%BD%92">1. 递归</a></li><li><a href="#2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">2. 动态规划</a></li></ul></li><li><a href="#jz-48-%E6%9C%80%E9%95%BF%E7%9A%84%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2">Jz-48. 最长的不含重复字符的子字符串</a><ul><li><a href="#%E6%80%9D%E8%80%83-3">思考</a></li><li><a href="#1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">1. 动态规划</a></li></ul></li><li><a href="#jz-54-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9">JZ-54. 二叉搜索树第k大节点</a><ul><li><a href="#%E6%80%9D%E8%80%83-4">思考</a></li><li><a href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86">中序遍历</a></li></ul></li><li><a href="#jz-56-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E7%BB%84%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0-i">JZ-56 数组中数组出现的次数 I</a><ul><li><a href="#%E6%80%9D%E8%80%83-5">思考</a></li><li><a href="#1-my-hashtable">1. My hashTable</a></li><li><a href="#2-my-hashmap">2. My HashMap</a></li><li><a href="#3-%E5%BC%82%E6%88%96%E5%A4%A7%E6%B3%95">3. 异或大法</a></li></ul></li><li><a href="#jz-63-%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6">Jz-63. 股票的最大利润</a><ul><li><a href="#%E6%80%9D%E8%80%83-6">思考</a></li><li><a href="#1-%E5%8F%8C%E6%8C%87%E9%92%88%E9%81%8D%E5%8E%86">1. 双指针遍历</a></li><li><a href="#2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-1">2. 动态规划</a></li></ul></li><li><a href="#1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C">1. 两数之和</a><ul><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#1-%E5%8F%8C%E5%A4%B4%E6%8C%87%E9%92%88">1. 双头指针</a></li><li><a href="#2-%E5%93%88%E5%B8%8C%E8%A1%A8">2. 哈希表</a></li></ul></li><li><a href="#%E4%B8%80-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8">一. 买卖股票</a><ul><li><a href="#%E6%9A%B4%E5%8A%9B%E6%B3%95">暴力法</a></li></ul></li><li><a href="#%E4%BA%8C-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2">二. 反转字符串</a><ul><li><a href="#%E4%B8%80%E6%AC%A1%E9%81%8D%E5%8E%86">一次遍历</a></li><li><a href="#%E9%80%92%E5%BD%92%E6%B3%95">递归法</a></li></ul></li><li><a href="#%E4%B8%89-%E8%AE%A1%E7%AE%97%E6%95%B4%E6%95%B0n%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9-%E7%B2%BE%E5%BA%A6%E4%B8%BA000001">三. 计算整数n的平方根  精度为0.00001</a><ul><li><a href="#%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95">牛顿迭代法</a></li></ul></li><li><a href="#%E5%9B%9B-%E8%AE%A1%E7%AE%97%E6%95%B4%E6%95%B0n%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9-%E8%BF%94%E5%9B%9E%E6%95%B4%E6%95%B0">四. 计算整数n的平方根 返回整数</a><ul><li><a href="#%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95">牛顿迭代法：</a></li><li><a href="#%E4%BA%8C%E5%88%86%E6%B3%95">二分法:</a></li><li><a href="#%E7%94%A8%E9%99%A4%E6%B3%95%E9%81%BF%E5%85%8D-int-%E6%BA%A2%E5%87%BA%E7%9A%84%E6%83%85%E5%86%B5">用除法避免 int 溢出的情况</a></li></ul></li><li><a href="#%E4%BA%94-%E8%AE%A1%E7%AE%97%E6%B0%B4%E7%AE%B1%E5%AE%B9%E7%A7%AF">五. 计算水箱容积</a><ul><li><a href="#%E4%B8%80%E6%AC%A1%E9%81%8D%E5%8E%86-%E5%8F%8C%E6%8C%87%E9%92%88">一次遍历 （双指针）</a></li></ul></li><li><a href="#%E5%85%AD-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97-1012">六. 整数转罗马数字————–(10/12)</a><ul><li><a href="#haspmap-%E5%AD%98%E5%82%A8%E9%94%AE%E5%80%BC%E5%AF%B9-%E5%88%A4%E6%96%AD">HaspMap 存储键值对 判断</a></li><li><a href="#%E8%B4%AA%E5%BF%83%E6%B3%95int-string-%E5%9F%BA%E6%9C%AC%E6%95%B0%E7%BB%84-%E5%AF%B9%E5%BA%94%E5%AD%98%E5%82%A8"><strong>贪心法</strong>int String 基本数组 对应存储</a></li><li><a href="#%E6%80%9D%E8%80%83-7">思考</a><ul><li><a href="#hashmap-%E4%B8%AD%E7%9A%84get%E6%96%B9%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%98%AF%E5%90%A6%E4%B8%BAo1">HashMap 中的get方法时间复杂度是否为O（1）？</a></li></ul></li></ul></li><li><a href="#%E4%B8%83-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88-1012">七. 电话号码的字母组合  ———-（10/12）</a><ul><li><a href="#string%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BF%AD%E4%BB%A3">String类型的迭代</a></li><li><a href="#stringbuilder-%E5%AE%9E%E7%8E%B0%E7%9A%84%E8%BF%AD%E4%BB%A3">StringBuilder 实现的迭代</a></li><li><a href="#%E6%80%9D%E8%80%83-8">思考</a></li></ul></li><li><a href="#%E5%85%AB-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6">八. 二叉树的最大深度</a><ul><li><a href="#%E9%80%92%E5%BD%92%E6%B3%95-1">递归法</a></li><li><a href="#%E6%80%9D%E8%80%83-9">思考</a></li></ul></li><li><a href="#%E4%B9%9D-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8">九. 合并两个有序列表</a><ul><li><a href="#1-%E8%BF%AD%E4%BB%A3">1. 迭代</a></li><li><a href="#2-%E9%80%92%E5%BD%92">2. 递归</a></li><li><a href="#%E5%88%86%E6%9E%90">分析：</a></li></ul></li><li><a href="#%E5%8D%81-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-1016%E6%9C%AA%E5%AE%8C%E5%85%A8%E7%90%86%E8%A7%A3">十. 反转链表 ——–10.16未完全理解</a><ul><li><a href="#1-%E8%BF%AD%E4%BB%A3-1">1. 迭代</a></li><li><a href="#2-%E9%80%92%E5%BD%92-1">2. 递归</a></li></ul></li><li><a href="#%E5%8D%81%E4%B8%80-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9">十一. 删除排序数组中的重复项</a><ul><li><a href="#1-%E6%9A%B4%E5%8A%9B%E4%B8%89%E5%BE%AA%E7%8E%AF-%E8%A7%A3%E9%9D%9E%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84">1. 暴力三循环 –解非排序数组</a></li><li><a href="#2-%E5%8F%8C%E6%8C%87%E9%92%88%E5%8D%95%E5%BE%AA%E7%8E%AF-%E8%A7%A3%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84">2. 双指针单循环 — 解排序数组</a></li><li><a href="#%E5%8F%8D%E6%80%9D">反思</a></li></ul></li><li><a href="#%E5%8D%81%E4%BA%8C-%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97">十二. 外观数列</a><ul><li><a href="#string-%E4%B8%8E-stringbuilder-%E5%85%B3%E4%BA%8E%E6%95%88%E7%8E%87%E5%92%8C%E9%80%92%E5%BD%92%E7%9A%84%E4%BD%BF%E7%94%A8">* String 与 StringBuilder 关于效率和递归的使用</a></li><li><a href="#1-%E9%80%92%E5%BD%92-1">1. 递归</a></li><li><a href="#2-%E7%9C%8B%E9%A2%98%E8%A7%A3%E5%90%8E%E7%9A%84%E7%BB%86%E8%8A%82%E8%B0%83%E6%95%B4">2. 看题解后的细节调整</a></li></ul></li><li><a href="#43-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98">43. 字符串相乘</a><ul><li><a href="#%E6%80%9D%E8%80%83-3">思考：</a></li><li><a href="#1-my-%E8%87%AA%E5%AE%9E%E7%8E%B0%E7%9A%84%E8%BF%9B%E4%BD%8D%E6%9C%BA%E5%88%B6">1. My 自实现的进位机制</a></li></ul></li><li><a href="#53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C">53. 最大子序和</a><ul><li><a href="#%E6%80%9D%E8%80%83-10">思考</a></li><li><a href="#1-my-dp">1. My DP</a></li><li><a href="#%E6%94%B9%E8%BF%9B">改进</a></li><li><a href="#3-%E5%88%86%E6%B2%BB-%E7%BA%BF%E6%AE%B5%E6%A0%91">3. 分治  线段树</a></li></ul></li><li><a href="#105-%E5%89%8D%E4%B8%AD%E5%BA%8F%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91">105. 前中序构造二叉树</a><ul><li><a href="#%E6%80%9D%E8%B7%AF-1">思路</a></li><li><a href="#1-my-%E9%80%92%E5%BD%92">1. My 递归</a></li><li><a href="#2-hashmap%E7%9A%84%E5%B0%8F%E6%94%B9%E8%BF%9B">2. hashmap的小改进</a></li><li><a href="#3-%E8%BF%AD%E4%BB%A3-%E6%A0%88">3. 迭代 + 栈</a></li></ul></li><li><a href="#146-lru%E7%BC%93%E5%AD%98">146. LRU缓存</a><ul><li><a href="#%E6%80%9D%E8%80%83-11">思考</a></li><li><a href="#1-my-lruhashmap">1. My LruHashMap</a></li></ul></li><li><a href="#155-%E6%9C%80%E5%B0%8F%E6%A0%88">155. 最小栈</a><ul><li><a href="#%E6%80%9D%E8%80%83-12">思考</a></li><li><a href="#1-%E8%87%AA%E5%AE%9A%E4%B9%89">1. 自定义</a></li></ul></li><li><a href="#263-%E4%B8%91%E6%95%B0">263. 丑数</a><ul><li><a href="#%E6%80%9D%E8%80%83-13">思考</a></li><li><a href="#1-%E7%AE%80%E5%8D%95%E9%80%92%E5%BD%92">1. 简单递归</a></li><li><a href="#2-%E8%BF%AD%E4%BB%A3">2. 迭代</a></li></ul></li><li><a href="#300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97">300. 最长递增子序列</a><ul><li><a href="#%E6%80%9D%E8%80%83-14">思考</a></li><li><a href="#1-%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84dp">1. 自己写的dp</a></li><li><a href="#2-%E7%9C%9F%E6%AD%A3%E7%9A%84dp">2. 真正的dp</a></li><li><a href="#%E8%B4%AA%E5%BF%83%E4%BA%8C%E5%88%86">贪心+二分</a></li></ul></li><li><a href="#322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2">322. 零钱兑换</a><ul><li><a href="#%E6%80%9D%E8%80%83-15">思考</a></li><li><a href="#1-%E8%AE%B0%E5%BF%86dfs">1. 记忆DFS</a></li><li><a href="#2-dp">2. DP</a></li></ul></li><li><a href="#lru%E5%AE%9E%E7%8E%B0">LRU实现</a></li><li><a href="#%E9%98%BF%E9%87%8C2020-%E6%A0%88%E6%B1%82%E8%A1%A8%E8%BE%BE%E5%BC%8F">阿里2020. 栈求表达式</a></li></ul><!-- tocstop --><hr><p>[TOC]</p><span id="more"></span><hr><h2><span id="jz-03-两数相加">JZ-03. 两数相加</span></h2><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210308090153998.png" alt="image-20210308090153998"></p><h3><span id="思考">思考：</span></h3><p>未排序、有重复数字、找出的是任意的重复数字、所有数字大小都在0—n-1的范围内、输出的是重复的那个数字</p><h3><span id="1-基于哈希表">1. 基于哈希表</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Map map = <span class="keyword">new</span>  HashMap();</span><br><span class="line"> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span>(i&lt;nums.length)&#123;</span><br><span class="line">     <span class="keyword">if</span>((<span class="keyword">int</span>)map.getOrDefault(nums[i],-<span class="number">1</span>) != -<span class="number">1</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> nums[i];</span><br><span class="line">     &#125;</span><br><span class="line">     map.put(nums[i], nums[i]);</span><br><span class="line">     i++;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> -<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210308092439462.png" alt="image-20210308092439462"></p><p>时间复杂度 O(N)  空间复杂度  O(N)</p><h3><span id="2-原地置换-nb">2. 原地置换  nb</span></h3><p>这里确实 应该多看题目给的数字范围在0–n-1思考，这是解这道题的关键，之前的哈希表是没有用到这个条件的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">           <span class="keyword">while</span>(nums[i] != i)&#123;</span><br><span class="line">               <span class="keyword">if</span>(nums[i] == nums[nums[i]])&#123;</span><br><span class="line">                   <span class="keyword">return</span> nums[i];</span><br><span class="line">               &#125;</span><br><span class="line">               temp = nums[nums[i]];</span><br><span class="line">               nums[nums[i]] = nums[i];</span><br><span class="line">               nums[i] = temp;</span><br><span class="line">           &#125;</span><br><span class="line">         </span><br><span class="line">       &#125;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>理解这里的思想主要是自己想一个数组一步步去进行    有点桶排序的感觉？</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210308124958004.png" alt="image-20210308124958004"></p><p>这里最后发现问题的关键是   n-1范围内， 索引为i对应的位置上肯定是 i ，然后去判断时 发现重复的元素，肯定是在他的值对应的索引上去找的，如果有这个值，则找到了，没有，则说明还未填上，则填上。</p><p><span style="color: #00BFFF;font-size:24px">这里主要是还是要掌握桶排序的思想，先去思考能不能通过O  N的方式解决问题</span></p><h2><span id="jz-04-二维数组中的查找">JZ-04. 二维数组中的查找</span></h2><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210310083059606.png" alt="image-20210310083059606"></p><h3><span id="观察">观察：</span></h3><p>每行递增、每列递增</p><h3><span id="1-自己想的矩阵分割法">1. 自己想的矩阵分割法</span></h3><h3><span id="2-翻转矩阵-线性搜索">2.  翻转矩阵 / 线性搜索</span></h3><p>​    矩阵的右上角开始</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> j = matrix[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>||j&lt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span>(matrix[i][j]&gt;num) j--;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j]&lt;num) i++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] == num)</span><br><span class="line">        System.out.println(num);</span><br></pre></td></tr></table></figure><h2><span id="jz-10-青蛙跳台阶">JZ-10. 青蛙跳台阶</span></h2><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210315090449362.png" alt="image-20210315090449362"></p><h3><span id="思考">思考</span></h3><p>就是拼砖头的递归思想</p><p>返回格式  ()+1</p><h3><span id="1-递归超时">1. 递归（超时）</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(num == <span class="number">0</span> || num == <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>   <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(num == <span class="number">2</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">return</span> getMax(num-<span class="number">2</span>)+getMax(num - <span class="number">1</span>) ;</span><br></pre></td></tr></table></figure><p>递归的时间复杂度是On*n 空间复杂度 On 所以肯定超时了</p><h3><span id="2-动态规划">2.  动态规划</span></h3><p>典型的斐波那契数列问题，艹,就是一个三个缓存数进行斐波那契数列的运算</p><p><strong>为什么是斐波那契？</strong></p><p><strong>以后看算法题的时候，先看其通项结构</strong></p><p>f(n) = f(n-1) + f(n-2)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt; num;i++)&#123;</span><br><span class="line">   sum = (a+b)%<span class="number">1000000007</span>;</span><br><span class="line">   a = b;</span><br><span class="line">   b = sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a;</span><br></pre></td></tr></table></figure><p>时间复杂度 On 空间复杂度 O1</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210315092525503.png" alt="image-20210315092525503"></p><h2><span id="jz-14-i-剪绳子">JZ-14 -I 剪绳子</span></h2><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210330163524643.png" alt="image-20210330163524643"></p><h3><span id="思考">思考：</span></h3><p>动态规划、通项式、贪心算法？</p><p>后来发现在求On的时候有复杂的情况，就放弃了，应该是数学方面的问题，不应该暴力迭代</p><h3><span id="o-1">O (1):</span></h3><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210330163659124.png" alt="image-20210330163659124"></p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210330163712589.png" alt="image-20210330163712589"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> a = n / <span class="number">3</span>, b = n % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>, a);</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">1</span>) <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>, a - <span class="number">1</span>) * <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>, a) * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">作者：jyd</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/jian-sheng-zi-lcof/solution/mian-shi-ti-14-i-jian-sheng-zi-tan-xin-si-xiang-by/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="jz-22-链表中倒数第k个节点">JZ-22. 链表中倒数第k个节点</span></h2><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210315222551714.png" alt="image-20210315222551714"></p><h3><span id="思考">思考</span></h3><p>正常情况下，O n+n？</p><h3><span id="1-递归寻找">1. 递归寻找？</span></h3><p>我最开始准备是 getNode(node.next)先往下去找，找到next为null时再向上返回，但是这时候如何去减k值我就不知道了</p><h3><span id="2-双指针-真妙啊">2. 双指针 真妙啊</span></h3><p>让前指针先走k步，然后后指针跟随者前指针一起走</p><p>核心的点是在当pre为null时，也就是走到头了，这时候former与pre差k步，也就是倒数第k个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ListNode premer = head;</span><br><span class="line">   ListNode former = head;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">       </span><br><span class="line">       premer = premer.next;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">while</span>(premer != <span class="keyword">null</span>)&#123;</span><br><span class="line">       premer = premer.next;</span><br><span class="line">       former = former.next;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> former;</span><br></pre></td></tr></table></figure><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210315225759099.png" alt="image-20210315225759099"></p><p>时间复杂度O n 空间复杂度 O2</p><p><strong>如果这种问题递归不行的话，就想想双指针会怎么做吧</strong></p><p><strong>换一种思路</strong></p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210315082753010.png" alt="image-20210315082753010"></p><h3><span id="思考">思考：</span></h3><p>从棋盘左上角触发，到达右下角 </p><p>递归？</p><h2><span id="jz-24-反转链表">JZ-24. 反转链表</span></h2><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210308212250360.png" alt="image-20210308212250360"></p><h3><span id="思考">思考</span></h3><p>似乎没什么，注意  null</p><h3><span id="1-自己写的-pre-指针代码">1. 自己写的 pre 指针代码</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head.next ==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        ListNode prer;</span><br><span class="line">        ListNode pre;</span><br><span class="line">        ListNode Lastpre;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            pre = head;</span><br><span class="line">            Lastpre = head;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                pre = pre.next;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(NullPointerException e)&#123;</span><br><span class="line">                pre = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                pre = pre.next;</span><br><span class="line">                Lastpre = Lastpre.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            prer = pre.next;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Lastpre.next = prer;</span><br><span class="line">            pre.next = head;</span><br><span class="line">            head = pre;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span>(prer == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure><p>​    写了很久，结果太拉了，自己都不想分析了</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210308224413999.png" alt="image-20210308224413999"></p><h3><span id="2-双指针">2. 双指针</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ListNode cur =<span class="keyword">null</span>;</span><br><span class="line">ListNode pre = head;</span><br><span class="line">ListNode t ;</span><br><span class="line"><span class="keyword">while</span>(pre != <span class="keyword">null</span>)&#123;</span><br><span class="line">    t = pre.next;</span><br><span class="line">    pre.next = cur;</span><br><span class="line">    cur = pre;  <span class="comment">// ①标记</span></span><br><span class="line">    pre = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cur;</span><br></pre></td></tr></table></figure><p>这里主要还是自己以前的老问题，就是标记1处，这里就理解为是单纯的赋值就行了</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210308224939792.png" alt="image-20210308224939792"></p><h3><span id="3-递归">3. 递归</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line">ListNode ret = reverseList(head.next);</span><br><span class="line">head.next.next = head;</span><br><span class="line"><span class="comment">// 5.next = head;</span></span><br><span class="line">head.next = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//此处置空的时候一定要注意关注点是ret 而不是head...</span></span><br><span class="line"><span class="keyword">return</span> ret;</span><br></pre></td></tr></table></figure><p>递归理解起来有一定的难度</p><p>特别是注意ret 和 head的包含关系, 如果理解不了的时候就报head.next.next 用另一个遍历替换  head.next = ret 集中关注在ret上，因为递归，所以内存消耗肯定很多啦</p><p><span style="color:#3CB371;font-size:20px">这种递归给我的启示是以后分不清next的时候或者等价关系，就用中间变量去解耦，或者用已知指针替换，这样会更好理解一些</span></p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210308232940772.png" alt="image-20210308232940772"></p><h2><span id="jz-47-礼物的最大价值">Jz-47. 礼物的最大价值</span></h2><h3><span id="1-递归">1. 递归</span></h3><h3><span id="2-动态规划">2. 动态规划</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span></span>&#123;</span><br><span class="line">          <span class="keyword">for</span>( <span class="keyword">int</span> i =<span class="number">0</span>;i&lt; matrix.length ; i++)&#123;</span><br><span class="line">              <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;matrix[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                  <span class="keyword">if</span>(i == <span class="number">0</span>&amp;&amp; j ==<span class="number">0</span> ) <span class="keyword">continue</span>;</span><br><span class="line">                  <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                      matrix[i][j] += matrix[i][j-<span class="number">1</span>];</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</span><br><span class="line">                      matrix[i][j] += matrix[i-<span class="number">1</span>][j];</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">else</span> &#123;</span><br><span class="line">                      matrix[i][j] += Math.max(matrix[i][j-<span class="number">1</span>],matrix[i-<span class="number">1</span>][j]);</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> matrix[matrix.length-<span class="number">1</span>][matrix[<span class="number">0</span>].length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度 O m*n 空间复杂度 O 1</p><p>回顾动态规划的思想，这种问题还是很典型，这种动态规划的思想会破坏原有矩阵</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210315090005261.png" alt="image-20210315090005261"></p><p>继续优化</p><p>对矩阵很大的情况，很少有可能会在第一行或者第一列进行加，所以这个时候可以先进行初始化。然后相当于从[1] [1]开始</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) <span class="comment">// 初始化第一行</span></span><br><span class="line">         grid[<span class="number">0</span>][j] += grid[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) <span class="comment">// 初始化第一列</span></span><br><span class="line">         grid[i][<span class="number">0</span>] += grid[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) </span><br><span class="line">             grid[i][j] += Math.max(grid[i][j - <span class="number">1</span>], grid[i - <span class="number">1</span>][j]);</span><br><span class="line">     <span class="keyword">return</span> grid[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>自己对动态规划还是不熟悉</p><h2><span id="jz-48-最长的不含重复字符的子字符串">Jz-48. 最长的不含重复字符的子字符串</span></h2><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210318165801690.png" alt="image-20210318165801690"></p><h3><span id="思考">思考</span></h3><p>平常解 时间复杂度</p><p>关键是每一次index到一个数都需要和当前字符串的字母进行对比，能避免吗？实质是相同字母的最大间距，也可能不是</p><h3><span id="1-动态规划">1. 动态规划</span></h3><h2><span id="jz-54-二叉搜索树第k大节点">JZ-54. 二叉搜索树第k大节点</span></h2><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210405161703797.png" alt="image-20210405161703797"></p><h3><span id="思考">思考</span></h3><p>递归  ？</p><h3><span id="中序遍历">中序遍历</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res =<span class="number">0</span>, m =<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        m = k;</span><br><span class="line">        getMax(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMax</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        getMax(node.right);</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(--m == <span class="number">0</span>)&#123;</span><br><span class="line">            res = node.val;</span><br><span class="line">        &#125;</span><br><span class="line">        getMax(node.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度 On  空间复杂度 O1</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210405164353990.png" alt="image-20210405164353990"></p><p>这道题主要一直在纠结递归的返回参数问题，思考的时候没有思考深入， 没有想清楚本质，以后遇到这种问题还是要多想一哈，不过感觉递归还是个人的弱点…..</p><p><strong>涉及到二叉搜索树，就要想清楚他的性质，中序遍历是从小到大的排序数组</strong></p><h2><span id="jz-56-数组中数组出现的次数-i">JZ-56 数组中数组出现的次数 I</span></h2><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210402213300125.png" alt="image-20210402213300125"></p><h3><span id="思考">思考</span></h3><p>On 时间复杂度 O1 空间复杂度</p><p>哈希表肯定用不了  取模算不了    动态规划算不了    双指针     数组肯定是偶数长度的  </p><p>两次遍历？ 排序？</p><h3><span id="1-my-hashtable">1. My hashTable</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">int</span>[] result = &#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(max&lt;nums[i])</span><br><span class="line">                max = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] hash = <span class="keyword">new</span> <span class="keyword">int</span>[max*<span class="number">2</span>+<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;max*<span class="number">2</span>+<span class="number">2</span>;i++)&#123;</span><br><span class="line">            hash[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i  = <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = nums[i];</span><br><span class="line">            <span class="keyword">if</span>(hash[x*<span class="number">2</span>] != -<span class="number">1</span>)&#123;</span><br><span class="line">                hash[<span class="number">2</span>*x+<span class="number">1</span>] = x;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                hash[<span class="number">2</span>*x] = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash[<span class="number">2</span>*nums[i]+<span class="number">1</span>] == -<span class="number">1</span> )&#123;</span><br><span class="line">                <span class="keyword">if</span>(result[<span class="number">0</span>] == -<span class="number">1</span>)&#123;</span><br><span class="line">                    result[<span class="number">0</span>] = nums[i];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    result[<span class="number">1</span>] = nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">          <span class="keyword">return</span> result;     </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>居然还不错？</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210402220633539.png" alt="image-20210402220633539"></p><h3><span id="2-my-hashmap">2. My HashMap</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">       </span><br><span class="line">       HashMap&lt;Integer,Integer&gt; hashMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">int</span>[] result = &#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(hashMap.getOrDefault(nums[i],-<span class="number">1</span>) == -<span class="number">1</span>)&#123;</span><br><span class="line">               hashMap.put(nums[i],<span class="number">1</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               hashMap.put(nums[i],<span class="number">2</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(hashMap.get(nums[i])==<span class="number">1</span>)&#123;</span><br><span class="line">               <span class="keyword">if</span>(result[<span class="number">0</span>] == -<span class="number">1</span>)&#123;</span><br><span class="line">                   result[<span class="number">0</span>] = nums[i];</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   result[<span class="number">1</span>] = nums[i];</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210402221317356.png" alt="image-20210402221317356"></p><h3><span id="3-异或大法">3. 异或大法</span></h3><p>理由： 相同的两个数字异或结果肯定为 0 ，且<strong>异或具有交换性</strong></p><p>分组：找到不同的a,b不同的位数 进行分组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">         total ^= num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mask = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>((mask &amp; total) == <span class="number">0</span>)&#123;</span><br><span class="line">        mask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a =<span class="number">0</span> ,b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>((mask &amp; num) ==<span class="number">0</span>)&#123;</span><br><span class="line">            a ^= num;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            b ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;a,b&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210403095612566.png" alt="image-20210403095612566"></p><h2><span id="jz-63-股票的最大利润">Jz-63. 股票的最大利润</span></h2><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210316215457375.png" alt="image-20210316215457375"></p><h3><span id="思考">思考</span></h3><p>双指针？排序？</p><p>前后遍历  O 2N</p><h3><span id="1-双指针遍历">1. 双指针遍历</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prices.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxInterval = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> preIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> lasIndex = prices.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(preIndex != lasIndex)&#123;</span><br><span class="line">        <span class="keyword">while</span>(lasIndex != preIndex)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[lasIndex] - prices[preIndex] &gt;maxInterval)&#123;</span><br><span class="line">                maxInterval = prices[lasIndex] - prices[preIndex];</span><br><span class="line">            &#125;</span><br><span class="line">            lasIndex --;</span><br><span class="line">        &#125;</span><br><span class="line">        preIndex ++;</span><br><span class="line">        lasIndex = prices.length - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxInterval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度 On*n 空间复杂度 O1 </p><h3><span id="2-动态规划">2. 动态规划</span></h3><p>核心思想</p><p>创建一个数组 dp[i]代表的是i天卖出时的最大收益</p><p>又可等于 第i-1天的最大收益 或者 第i天价格 - 前i-1天价格的最低价</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> minValue = Integer.MAX_VALUE;</span><br><span class="line">       <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;prices.length; i++)&#123;</span><br><span class="line">           minValue = Math.min(minValue,prices[i]);</span><br><span class="line">           profit = Math.max(profit,prices[i]-minValue);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> profit;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210316225500458.png" alt="image-20210316225500458"></p><p>时间复杂度On 空间复杂度O1</p><p>还是，多去找通项公式，不一定是符号表达的，能用语言刻画的一样可以</p><h2><span id="1-两数之和">1. 两数之和</span></h2><blockquote><p>日期： 2021-3-7   23:02</p></blockquote><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210307223505616.png" alt="image-20210307223505616"></p><p>先审题， 两个整数，返回数组下标，给出的数组不是排序的，返回的数组是排序的？</p><p>回过头才发现忽略的因素：  数组是否有相同元素？</p><h3><span id="思路">思路</span></h3><ol><li>二分？</li><li>排序后找？</li><li></li></ol><p>我的代码：</p><h3><span id="1-双头指针">1.  双头指针</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">   <span class="keyword">int</span> i,j;</span><br><span class="line"><span class="comment">//一个向前 一个向后，避免重复查找</span></span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; nums.length;i++)&#123;</span><br><span class="line">       <span class="keyword">for</span>(j = nums.length-<span class="number">1</span>; j&gt;i; j--)&#123;</span><br><span class="line">           <span class="keyword">if</span>(nums[i]+nums[j] == target)&#123;</span><br><span class="line">               result[<span class="number">0</span>] = i;</span><br><span class="line">               result[<span class="number">1</span>] = j;</span><br><span class="line">               <span class="keyword">return</span> result;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210307224350988.png" alt="image-20210307224350988"></p><p>时间复杂度  O(N<sup>2</sup>)   空间复杂度 O(1)</p><h3><span id="2-哈希表">2. 哈希表</span></h3><p>确实，最开始想到了郑老板出题的时候这个，只是怕放入map集合又会消耗一定的时间，哎…..</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Map map = <span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();</span><br><span class="line"><span class="keyword">int</span> j ;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">    j = (<span class="keyword">int</span>)map.getOrDefault(nums[i],-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(j != -<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;j,i&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(target - nums[i] , i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210307230039420.png" alt="image-20210307230039420"></p><p>时间复杂度 :  O(N)   空间复杂度 O(N) 哈希表的开销</p><p>这里由于哈希表 的get方法是 O(1)的开销，所以考虑哈希表的方式直接查找，精妙之处在与其索引key的灵活使用</p><h2><span id="一-买卖股票">一. 买卖股票</span></h2><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20201007090522974.png" alt="image-20201007090522974"></p><p>我的代码：</p><h3><span id="暴力法">暴力法</span></h3><ol><li>```java<br>//暴力法：    for二重循环 两指针索引 遍历<br>//缺点 ： 时间慢， 有重复计算<br>//时间复杂度：  O(n^2)  空间复杂度 O(1)–一个常量<br>public static int maxProfit(int[] prices) {<pre><code>    int max=0;    for(int i=0;i&lt;prices.length;i++)&#123;        for(int j=prices.length-1;j&gt;i;j--)&#123;            if(prices[j]-prices[i]&gt;max) &#123;                max = prices[j] - prices[i];            &#125;        &#125;    &#125;    return max;&#125;</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   ![image-20201007090734202](https:&#x2F;&#x2F;s401177923-1302493622.cos.ap-nanjing.myqcloud.com&#x2F;mdImages&#x2F;image-20201007090734202.png)</span><br><span class="line"></span><br><span class="line">### 动态规划</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">&#x2F;&#x2F;动态规划  一次遍历</span><br><span class="line">&#x2F;&#x2F;原因：  买入的 股票价格总是在最前面！！！</span><br><span class="line">&#x2F;&#x2F;时间复杂度： O(n)  空间复杂度 O(1)--两个常量</span><br><span class="line">public static int maxProfit_2(int[] prices) &#123;</span><br><span class="line">        int max&#x3D;0,min&#x3D;Integer.MAX_VALUE;</span><br><span class="line">        for(int i&#x3D;0;i&lt;prices.length;i++)&#123;</span><br><span class="line">           if(prices[i]&lt;min)</span><br><span class="line">                min&#x3D;prices[i];</span><br><span class="line">            else if(prices[i]-min&gt;max)&#x2F;&#x2F;这一步很重要</span><br><span class="line">                max&#x3D;prices[i]-min;</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20201007092356306.png" alt="image-20201007092356306"></p><hr><h2><span id="二-反转字符串">二. 反转字符串</span></h2><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20201008231317959.png" alt="image-20201008231317959"></p><p>我的代码：</p><h3><span id="一次遍历">一次遍历</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] s)</span></span>&#123;</span><br><span class="line">        <span class="comment">//一次遍历？ 空间复杂度O(n)=1 ,时间复杂度O(n)=n;</span></span><br><span class="line">        <span class="keyword">char</span> temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            temp=s[i];</span><br><span class="line">            s[i]=s[s.length-i-<span class="number">1</span>];</span><br><span class="line">            s[s.length-i-<span class="number">1</span>]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="递归法">递归法</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>[] reverse_1(<span class="keyword">char</span>[]s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)&#123;</span><br><span class="line">    <span class="comment">//递归法</span></span><br><span class="line">    <span class="keyword">if</span>(left&lt;right) &#123;</span><br><span class="line">        <span class="keyword">char</span> temp;</span><br><span class="line">        temp = s[left];</span><br><span class="line">        s[left] = s[right];</span><br><span class="line">        s[right] = temp;</span><br><span class="line">        <span class="keyword">return</span> reverse_1(s, left + <span class="number">1</span>, right - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算结果：</p><p>​        <strong>一次遍历</strong></p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20201008231524846.png" alt="image-20201008231524846"></p><p>​        <strong>递归</strong></p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20201008232649376.png" alt="image-20201008232649376"></p><p>分析思考： </p><pre><code>            1. 双指针 方法， 指向头尾指针，两标兵向中部靠齐，if循环和while判断都可以            2. 采用递归，内存占用会高一点 ，执行用时也非常慢</code></pre><hr><h2><span id="三-计算整数n的平方根-精度为000001">三. 计算整数n的平方根  精度为0.00001</span></h2><h3><span id="牛顿迭代法">牛顿迭代法</span></h3><p>牛顿迭代法不安全</p><p>我的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">sqrtByMyOwn</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(num==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">double</span> result1,result2=Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">double</span> i=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i*i&lt;num)&#123;</span><br><span class="line">                i+=<span class="number">0.5</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result1=i;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                result2=result1/<span class="number">2</span>+num/(<span class="number">2</span>*result1);</span><br><span class="line">                <span class="keyword">if</span>(result1-result2&lt;<span class="number">0.00001</span>) &#123;</span><br><span class="line">                    BigDecimal b=<span class="keyword">new</span> BigDecimal(result2);</span><br><span class="line">                    <span class="keyword">double</span> result=b.setScale(<span class="number">5</span>, BigDecimal.ROUND_HALF_UP).doubleValue();</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                    result1=result2;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2><span id="四-计算整数n的平方根-返回整数">四. 计算整数n的平方根 返回整数</span></h2><h3><span id="牛顿迭代法">牛顿迭代法：</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sqrtByNewton</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> i=x;</span><br><span class="line">    <span class="keyword">while</span>((<span class="keyword">long</span>)i*i&gt;x)&#123;</span><br><span class="line">        i=(i+x/i)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20201009180452249.png" alt="image-20201009180452249"></p><h3><span id="二分法">二分法:</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sqrtWithBinary</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">     <span class="keyword">long</span> result=-<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">long</span> left=<span class="number">0</span>,right=x/<span class="number">2</span>+<span class="number">1</span>,mid;</span><br><span class="line">     <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">         mid=(right+left+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">         <span class="keyword">if</span>(mid*mid&gt;x)&#123;</span><br><span class="line">             right=mid-<span class="number">1</span>;</span><br><span class="line">         &#125;<span class="keyword">else</span> <span class="keyword">if</span>(mid*mid&lt;x)&#123;</span><br><span class="line">             left=mid;</span><br><span class="line">             result=mid;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="keyword">return</span> (<span class="keyword">int</span>)mid;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(left&gt;=right)</span><br><span class="line">             <span class="keyword">return</span> (<span class="keyword">int</span>)right;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    分析： 此处mid=(right+left+1)/2; 必须是在右中部。因为在左中部容易出现无限循环的现象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20201009180734101.png" alt="image-20201009180734101"></p><h3><span id="用除法避免-int-溢出的情况">用除法避免 int 溢出的情况</span></h3><p>用 int 型测试较大数字时， 由于 i*i 可能溢出，所以 需要提前设置为long 型 ，而后强转为 int</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">1</span>||x==<span class="number">0</span>)<span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=x/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(x/mid==mid||(x/mid&gt;mid&amp;&amp;x/(mid+<span class="number">1</span>)&lt;(mid+<span class="number">1</span>)))&#123;<span class="comment">//刚好</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(x/mid&gt;mid)&#123;<span class="comment">//mid比根小</span></span><br><span class="line">                left=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//mid比根大</span></span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20201009182029446.png" alt="image-20201009182029446"></p><h2><span id="五-计算水箱容积">五. 计算水箱容积</span></h2><h3><span id="一次遍历-双指针">一次遍历 （双指针）</span></h3><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20201010183940869.png" alt="image-20201010183940869"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">waterV_1</span><span class="params">(<span class="keyword">int</span>[] a )</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> max=<span class="number">0</span>,tmp=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">int</span> i=<span class="number">0</span>,j=a.length-<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">             <span class="keyword">if</span>(a[i]&lt;=a[j])</span><br><span class="line">                 tmp=a[i]*(j- i++);</span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span>(a[i]&gt;a[j])</span><br><span class="line">                 tmp=a[j]*(j-- -i);</span><br><span class="line">             <span class="keyword">if</span>(max&lt;tmp)</span><br><span class="line">                 max=tmp;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> max;</span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">             时间复杂度：O(N)O(N)，双指针总计最多遍历整个数组一次。</span></span><br><span class="line"><span class="comment">             空间复杂度：O(1)O(1)，只需要额外的常数级别的空间。</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20201010182820360.png" alt="image-20201010182820360"></p><p>解题思路：</p><p>​                由暴力的两重for循环， 考虑到 左右两侧的可移动性，进而想到双指针</p><hr><h2><span id="六-整数转罗马数字1012">六. 整数转罗马数字————–(10/12)</span></h2><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20201012085753307.png" alt="image-20201012085753307"></p><p>我的代码：</p><h3><span id="haspmap-存储键值对-判断">HaspMap 存储键值对 判断</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">getOne</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">     StringBuilder stringBuilder=<span class="keyword">new</span> StringBuilder(<span class="string">&quot;&quot;</span>);</span><br><span class="line">     <span class="keyword">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">90</span>,<span class="number">100</span>,<span class="number">400</span>,<span class="number">500</span>,<span class="number">900</span>,<span class="number">1000</span>&#125;;</span><br><span class="line">     <span class="keyword">int</span> i=a.length-<span class="number">1</span>;</span><br><span class="line">     Map hashMap=<span class="keyword">new</span> HashMap&lt;Integer,String&gt;();</span><br><span class="line">     hashMap.put(<span class="number">1</span>,<span class="string">&quot;I&quot;</span>);  hashMap.put(<span class="number">4</span>,<span class="string">&quot;IV&quot;</span>); hashMap.put(<span class="number">9</span>,<span class="string">&quot;IX&quot;</span>);</span><br><span class="line">     hashMap.put(<span class="number">40</span>,<span class="string">&quot;XL&quot;</span>); hashMap.put(<span class="number">90</span>,<span class="string">&quot;XC&quot;</span>);hashMap.put(<span class="number">400</span>,<span class="string">&quot;CD&quot;</span>);</span><br><span class="line">     hashMap.put(<span class="number">900</span>,<span class="string">&quot;CM&quot;</span>);  hashMap.put(<span class="number">5</span>,<span class="string">&quot;V&quot;</span>); hashMap.put(<span class="number">10</span>,<span class="string">&quot;X&quot;</span>);</span><br><span class="line">     hashMap.put(<span class="number">50</span>,<span class="string">&quot;L&quot;</span>);hashMap.put(<span class="number">100</span>,<span class="string">&quot;C&quot;</span>);   hashMap.put(<span class="number">1000</span>,<span class="string">&quot;M&quot;</span>);</span><br><span class="line">     <span class="keyword">while</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">         <span class="keyword">if</span>(n/a[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">             n=n-a[i];</span><br><span class="line">             stringBuilder.append(hashMap.get(a[i]));</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             i--;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> String.valueOf(stringBuilder);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20201012090037059.png" alt="image-20201012090037059"></p><h3><span id="贪心法int-string-基本数组-对应存储"><strong>贪心法</strong>int String 基本数组 对应存储</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     StringBuilder stringBuilder=<span class="keyword">new</span> StringBuilder(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span>[] a = &#123;<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">     String[] s = &#123;<span class="string">&quot;M&quot;</span>,<span class="string">&quot;CM&quot;</span>,<span class="string">&quot;D&quot;</span>,<span class="string">&quot;CD&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;XC&quot;</span>,<span class="string">&quot;L&quot;</span>,<span class="string">&quot;XL&quot;</span>,<span class="string">&quot;X&quot;</span>,<span class="string">&quot;IX&quot;</span>,<span class="string">&quot;V&quot;</span>,<span class="string">&quot;IV&quot;</span>,<span class="string">&quot;I&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span>(i&lt;a.length)&#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span>(num&gt;=a[i])&#123;</span><br><span class="line">             num=num-a[i];</span><br><span class="line">             stringBuilder.append(s[i]);</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             i++;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> String.valueOf(stringBuilder);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20201012090139984.png" alt="image-20201012090139984"></p><h3><span id="思考">思考</span></h3><ul><li>对于判断 和 输出对于字符的思路，我的思路上与题设大体一致</li><li>不能解决 4 -9 的问题，就只能存储进数组中，通过索引解决</li></ul><h4><span id="hashmap-中的get方法时间复杂度是否为o1">HashMap 中的get方法时间复杂度是否为O（1）？</span></h4><p>在hash不发生冲突的情况下， 是O（1），也就是说，最优情况才是O(1)，没有第二种方法直接建立int a[] 和String s[]的直接对应联系来的 快 </p><h2><span id="七-电话号码的字母组合-1012">七. 电话号码的字母组合  ———-（10/12）</span></h2><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20201012205456540.png" alt="image-20201012205456540"></p><p>我的代码：</p><h3><span id="string类型的迭代">String类型的迭代</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> String letterMap[] = &#123;</span><br><span class="line">            <span class="string">&quot; &quot;</span>,    <span class="comment">//0</span></span><br><span class="line">            <span class="string">&quot;&quot;</span>,     <span class="comment">//1</span></span><br><span class="line">            <span class="string">&quot;abc&quot;</span>,  <span class="comment">//2</span></span><br><span class="line">            <span class="string">&quot;def&quot;</span>,  <span class="comment">//3</span></span><br><span class="line">            <span class="string">&quot;ghi&quot;</span>,  <span class="comment">//4</span></span><br><span class="line">            <span class="string">&quot;jkl&quot;</span>,  <span class="comment">//5</span></span><br><span class="line">            <span class="string">&quot;mno&quot;</span>,  <span class="comment">//6</span></span><br><span class="line">            <span class="string">&quot;pqrs&quot;</span>, <span class="comment">//7</span></span><br><span class="line">            <span class="string">&quot;tuv&quot;</span>,  <span class="comment">//8</span></span><br><span class="line">            <span class="string">&quot;wxyz&quot;</span>  <span class="comment">//9</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; res;   </span><br><span class="line"><span class="function">List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(digits.equals(<span class="string">&quot;&quot;</span>))</span><br><span class="line">           <span class="keyword">return</span> list;</span><br><span class="line">       <span class="keyword">else</span>&#123;</span><br><span class="line">           getString(digits,<span class="number">0</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span> list;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span>  <span class="title">getString</span><span class="params">(String digits,<span class="keyword">int</span> index,String tmp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index==digits.length()) &#123;</span><br><span class="line">            list.add(tmp);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> c=digits.charAt(index);</span><br><span class="line">        String letter=arrstr[c-<span class="string">&#x27;0&#x27;</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;letter.length();i++)&#123;</span><br><span class="line">            getString(digits,index+<span class="number">1</span>,tmp+letter.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20201012212830953.png" alt="image-20201012212830953"></p><h3><span id="stringbuilder-实现的迭代">StringBuilder 实现的迭代</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="comment">//一个映射表，第二个位置是&quot;abc“,第三个位置是&quot;def&quot;。。。</span></span><br><span class="line"><span class="comment">//这里也可以用map，用数组可以更节省点内存</span></span><br><span class="line">String[] letter_map = &#123;<span class="string">&quot; &quot;</span>,<span class="string">&quot;*&quot;</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="string">&quot;ghi&quot;</span>,<span class="string">&quot;jkl&quot;</span>,<span class="string">&quot;mno&quot;</span>,<span class="string">&quot;pqrs&quot;</span>,<span class="string">&quot;tuv&quot;</span>,<span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line"><span class="comment">//注意边界条件</span></span><br><span class="line"><span class="keyword">if</span>(digits==<span class="keyword">null</span> || digits.length()==<span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line">iterStr(digits, <span class="keyword">new</span> StringBuilder(), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最终输出结果的list</span></span><br><span class="line">List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iterStr</span><span class="params">(String str, StringBuilder letter, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="comment">//递归的终止条件，注意这里的终止条件看上去跟动态演示图有些不同，主要是做了点优化</span></span><br><span class="line"><span class="comment">//动态图中是每次截取字符串的一部分，&quot;234&quot;，变成&quot;23&quot;，再变成&quot;3&quot;，最后变成&quot;&quot;，这样性能不佳</span></span><br><span class="line"><span class="comment">//而用index记录每次遍历到字符串的位置，这样性能更好</span></span><br><span class="line"><span class="keyword">if</span>(index == str.length()) &#123;</span><br><span class="line">res.add(letter.toString());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取index位置的字符，假设输入的字符是&quot;234&quot;</span></span><br><span class="line"><span class="comment">//第一次递归时index为0所以c=2，第二次index为1所以c=3，第三次c=4</span></span><br><span class="line"><span class="comment">//subString每次都会生成新的字符串，而index则是取当前的一个字符，所以效率更高一点</span></span><br><span class="line"><span class="keyword">char</span> c = str.charAt(index);</span><br><span class="line"><span class="comment">//map_string的下表是从0开始一直到9， c-&#x27;0&#x27;就可以取到相对的数组下标位置</span></span><br><span class="line"><span class="comment">//比如c=2时候，2-&#x27;0&#x27;，获取下标为2,letter_map[2]就是&quot;abc&quot;</span></span><br><span class="line"><span class="keyword">int</span> pos = c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">String map_string = letter_map[pos];</span><br><span class="line"><span class="comment">//遍历字符串，比如第一次得到的是2，页就是遍历&quot;abc&quot;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;map_string.length();i++) &#123;</span><br><span class="line">            </span><br><span class="line">            letter.append(map_string.charAt(i));</span><br><span class="line">            <span class="comment">//如果是String类型做拼接效率会比较低</span></span><br><span class="line"><span class="comment">//iterStr(str, letter+map_string.charAt(i), index+1);</span></span><br><span class="line">            iterStr(str, letter, index+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//这个方法保证了每一次大循环后得到的stringbuilder都是新的</span></span><br><span class="line">            <span class="comment">//注意： 这里的删除方法很重要！！</span></span><br><span class="line">            letter.deleteCharAt(letter.length()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20201012205626708.png" alt="image-20201012205626708"></p><h3><span id="思考">思考</span></h3><p>StringBuilder 确实操作比 String类型快很多很多，且在 空间占用上也远远低于 String</p><p>这还得归结于String 相加时 总会新分配一个String对象进行赋值</p><hr><h2><span id="八-二叉树的最大深度">八. 二叉树的最大深度</span></h2><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20201013151647518.png" alt="image-20201013151647518"></p><p>我的代码：</p><h3><span id="递归法">递归法</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    try catch 抓nullpointer异常，避免报错</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       left= <span class="number">1</span>+maxDepth(root.left);</span><br><span class="line">    right= <span class="number">1</span>+maxDepth(root.right);</span><br><span class="line">       &#125;</span><br><span class="line">       &#125;<span class="keyword">catch</span>(NullPointerException e)&#123; </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> left&gt;right?left:right;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20201013151715852.png" alt="image-20201013151715852"></p><h3><span id="思考">思考</span></h3><ul><li><p>判断 Null 型对象以后 还是加上try -catch 语句更好</p></li><li><p>学会使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">left= <span class="number">1</span>+maxDepth(root.left);</span><br><span class="line">right= <span class="number">1</span>+maxDepth(root.right);</span><br></pre></td></tr></table></figure><p>类的递归方法</p></li></ul><hr><h2><span id="九-合并两个有序列表">九. 合并两个有序列表</span></h2><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20201016083409297.png" alt="image-20201016083409297"></p><h3><span id="1-迭代">1. 迭代</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目给的是：  有 序 的数组，这点很重要</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode nodehead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode pre = nodehead;</span><br><span class="line"><span class="comment">// 理解这里pre=nodehead 的指向问题</span></span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">                    pre.next = l1; <span class="comment">// 这里的两步都能想到</span></span><br><span class="line">                    l1 = l1.next;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    pre .next= l2;</span><br><span class="line">                    l2 = l2.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 这里注意！ 关键点  是指针节点后移的步骤</span></span><br><span class="line">                <span class="comment">// 那pre之前的数呢？ ---传给nodehead了 </span></span><br><span class="line">                pre = pre.next;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (NullPointerException e)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//抓一下最后几个节点，可能不止一个节点，但他是有序的，就无妨了</span></span><br><span class="line">        pre.next=l1==<span class="keyword">null</span>?l2:l1;</span><br><span class="line">        <span class="keyword">return</span> nodehead.next;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *    时间复杂度O(n+m) 空间复杂度O(1) （pre 和nodepre作为变量）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20201016083455230.png" alt="image-20201016083455230" style="zoom:150%;"><h3><span id="2-递归">2. 递归</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l2==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">    <span class="comment">//到这里都没问题</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l1.val&lt;=l2.val) &#123;</span><br><span class="line">    <span class="comment">//此处 总爱 直接return一个 函数方法体 其实是不对的 ，具体得到的是谁呢？</span></span><br><span class="line">    <span class="comment">// 用 node.next能够实现对元素的保存</span></span><br><span class="line">            l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">        l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *    时间复杂度O(n+m) 空间复杂度O(m+n) （递归函数的调用）</span></span><br><span class="line"><span class="comment">     所以 执行结果内存消耗稍微慢于 迭代</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20201016084013216.png" alt="image-20201016084013216"></p><h3><span id="分析">分析：</span></h3><p>自己做的时候，开始是都想到了这两种算法，不过后来总觉得哪里行不通，就放弃了递归，采用迭代。分析问题的原因：</p><ol><li>问题用那种方法解决？<ol><li>从头部解决：     ——–<strong>迭代</strong><ul><li>用头元素记录 ，标兵元素去移动</li></ul></li><li>从尾部解决：     ——–<strong>递归</strong><ul><li>为了得到保存结果 用next指针继续下一次判断</li></ul></li></ol></li><li>两者的关键点 都是 巧妙的使用  next指针</li></ol><hr><h2><span id="十-反转链表-1016未完全理解">十. 反转链表 ——–10.16未完全理解</span></h2><h3><span id="1-迭代">1. 迭代</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">     ListNode cur = <span class="keyword">null</span>;</span><br><span class="line">       ListNode pre = head;</span><br><span class="line">       ListNode temp=<span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">while</span> (pre != <span class="keyword">null</span>) &#123;</span><br><span class="line">               temp = pre.next;</span><br><span class="line">               pre.next = cur;</span><br><span class="line">               cur = pre;</span><br><span class="line">               pre = temp;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="keyword">catch</span> (NullPointerException e)&#123;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">           <span class="keyword">return</span> cur;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20201016183423559.png" alt="image-20201016183423559"></p><h3><span id="2-递归">2. 递归</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">      ListNode cur=<span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(head.next==<span class="keyword">null</span>||head==<span class="keyword">null</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> head;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">       cur=reverseList(head.next);</span><br><span class="line">      </span><br><span class="line">      head.next.next=head;</span><br><span class="line">      head.next=<span class="keyword">null</span>;</span><br><span class="line">      &#125;<span class="keyword">catch</span>(NullPointerException e)&#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> cur;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20201016184502839.png" alt="image-20201016184502839"></p><hr><h2><span id="十一-删除排序数组中的重复项">十一. 删除排序数组中的重复项</span></h2><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20201018171723036.png" alt="image-20201018171723036"></p><h3><span id="1-暴力三循环-解非排序数组">1. 暴力三循环 –解非排序数组</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除数组中重复元素的</span></span><br><span class="line"><span class="comment"> * 分析： 造成 时间复杂度高的步骤： 判断 之后的元素是否相等和 移动数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// for     三层循环来做  算法不稳定  O(N3)/Ok(1)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">deleteSameNode</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total=nums.length;</span><br><span class="line">    <span class="comment">// 设置total 用于 循环体中 避免重复判断</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;total;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;total;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==nums[j]) &#123;</span><br><span class="line">                total-=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=j;k&lt;total;k++)&#123;</span><br><span class="line"></span><br><span class="line">                        nums[k]=nums[k+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                j--;       <span class="comment">//注意这里的 j--</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意点：  </p><ul><li>j– ：避免多个重复的数在一起而被漏掉</li><li>total作为循环判断的依据：    避免多个重复的数在一起而被漏掉 或者 重复判断了移动到末尾的数字</li></ul><h3><span id="2-双指针单循环-解排序数组">2. 双指针单循环 — 解排序数组</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">deleteSameNode_2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">           <span class="keyword">if</span>(nums[i]!=nums[j])&#123;</span><br><span class="line">               i++;</span><br><span class="line">               nums[i]=nums[j];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20201018231302964.png" alt="image-20201018231302964"></p><h3><span id="反思">反思</span></h3><p>这里我思考的时候 ，没有看题目要求， 直接按照一般的数组来解决了，其实 题目给的 有序数组 ，双循环再想到单循环双指针 ，是非常好解决的。此处也提供了一种思路， 先将 数组 有序化 ，再通过这种方式 进行O(n) 的运算</p><h2><span id="十二-外观数列">十二. 外观数列</span></h2><h3><span id="string-与-stringbuilder-关于效率和递归的使用">* String 与 StringBuilder 关于效率和递归的使用</span></h3><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20201027184424039.png" alt="image-20201027184424039"></p><h3><span id="1-递归">1. 递归</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 思路： 这种问题看起来很没有思路但是实际上又和前一项有联系</span></span><br><span class="line"><span class="comment">         *  考虑到追根溯源 --- 从尾部解决 然后对每一层进行分析</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//String的增删效率低 但是这里我的效率依然很低....  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    </span><br><span class="line">        StringBuilder str=<span class="keyword">new</span> StringBuilder(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        String bcstr=countAndSay(n-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bcstr.length();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;bcstr.length()-<span class="number">1</span>;k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(bcstr.charAt(i)==bcstr.charAt(k+<span class="number">1</span>)) &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            str.append(String.valueOf(j)+bcstr.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(str);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20201027184706268.png" alt="image-20201027184706268"></p><p>这种做法能做出来，但我觉得基于迭代的 空间复杂度 还有String自身的增添麻烦，且每一次迭代都会新建StringBuilder对象，是会效率不高。</p><h3><span id="2-看题解后的细节调整">2. 看题解后的细节调整</span></h3><p>细节分析： 这里的主要效率不高的拖延点在于str.append 的操作</p><p>​            可能是由于           str.append(String.valueOf(j)+bcstr.charAt(i));  使得两个字符串再次相加得到的新字符串，再将新的字符串赋值上去，使得在这里出现的String类型的增删。 且append(int ) 添加的是String类型的数字，但由于append(int+char)型的是会先将char 转换成加上int的char 再赋值给builder， 所以这里连用append 更好。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.append(j).append(bcstr.charAt(i));</span><br></pre></td></tr></table></figure><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20201027185740882.png" alt="image-20201027185740882"></p><h2><span id="43-字符串相乘">43. 字符串相乘</span></h2><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210403103757421.png" alt="image-20210403103757421"></p><h3><span id="思考">思考：</span></h3><p>不能用Bigdemical   大数相乘   注意最高位数   返回类型为String   long可能有溢出</p><p>位运算？</p><h3><span id="1-my-自实现的进位机制">1. My 自实现的进位机制</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(num1.equals(<span class="string">&quot;0&quot;</span>)||num2.equals(<span class="string">&quot;0&quot;</span>))&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> l1 = num1.length();</span><br><span class="line"><span class="keyword">int</span> l2 = num2.length();</span><br><span class="line"><span class="keyword">int</span> l3 = l1 + l2;</span><br><span class="line"><span class="keyword">char</span>[] result = <span class="keyword">new</span> <span class="keyword">char</span>[l3];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;i&lt;l3;i++)&#123;</span><br><span class="line">    result[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//冗杂</span></span><br><span class="line"><span class="keyword">int</span> min = Math.min(l1,l2);</span><br><span class="line"><span class="keyword">if</span>(l1 == min)&#123;</span><br><span class="line">    String temp  =num1;</span><br><span class="line">    num1 = num2;</span><br><span class="line">    num2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//选出最小的数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = num2.length()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = num1.length()-<span class="number">1</span>; j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">        <span class="keyword">int</span> mr =  (num1.charAt(j)-<span class="number">48</span>)*(num2.charAt(i)-<span class="number">48</span>);</span><br><span class="line">        result[i+j+<span class="number">1</span>] += ( <span class="keyword">char</span> )(mr % <span class="number">10</span> ) ;</span><br><span class="line">        <span class="keyword">if</span>(result[i+j+<span class="number">1</span>] &gt;= <span class="number">58</span>)&#123;</span><br><span class="line">            result[i+j] += <span class="number">1</span>;</span><br><span class="line">            result[i+j+<span class="number">1</span>] = (<span class="keyword">char</span>) (result[i+j+<span class="number">1</span>]-<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里有冗杂的成分</span></span><br><span class="line">        result[i+j] += mr/<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(result[i+j]&gt;=<span class="number">58</span>)&#123;</span><br><span class="line">            result[i+j-<span class="number">1</span>] += <span class="number">1</span>;</span><br><span class="line">            result[i+j] -= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(result[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(result).substring(<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度 O(m * n ) 空间复杂度 O(m+n)</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210403200458765.png" alt="image-20210403200458765"></p><p>整解的思路差不多，但是在处理result[i+j-1]这一块更加简洁</p><h2><span id="53-最大子序和">53. 最大子序和</span></h2><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210405093158517.png" alt="image-20210405093158517"></p><h3><span id="思考">思考</span></h3><p>O n 的解法</p><p>动态规划？</p><h3><span id="1-my-dp">1. My DP</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length]; </span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;dp.length;i++)&#123;</span><br><span class="line">        dp[i] =Math.max(dp[i-<span class="number">1</span>]+nums[i],nums[i]);</span><br><span class="line">        max = Math.max(dp[i],max);</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dp 序列求，最开始题没看清楚以为求的是数组子序列， 设置了end 和begin，后来一看只求最大值  … </p><p>空间复杂度 On 时间复杂度 On</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210405094811575.png" alt="image-20210405094811575"></p><h3><span id="改进">改进</span></h3><p>动态规划需要额外的数组一般是可以改进的</p><p>所以这里我改进了之后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> dp_pre = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        dp_pre =Math.max(dp_pre+nums[i],nums[i]);</span><br><span class="line">        max = Math.max(dp_pre,max);</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间复杂度变为O 1</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210405095134634.png" alt="image-20210405095134634"></p><h3><span id="3-分治-线段树">3. 分治  线段树</span></h3><p>….</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210405161553429.png" alt="image-20210405161553429"></p><h2><span id="105-前中序构造二叉树">105. 前中序构造二叉树</span></h2><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210409123330409.png" alt="image-20210409123330409"></p><h3><span id="思路">思路</span></h3><p>递归  node.left = …..</p><h3><span id="1-my-递归">1. My 递归</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addLR(<span class="number">0</span>,preorder.length-<span class="number">1</span>,<span class="keyword">new</span> TreeNode(),preorder,inorder,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">addLR</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,TreeNode node,<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;r)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(inorder[l]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = lookForPre(preorder[i],inorder);</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">            node = <span class="keyword">new</span> TreeNode();</span><br><span class="line">        node.val = inorder[index];</span><br><span class="line">        node.left = addLR(l,index-<span class="number">1</span>,node.left,preorder,inorder,i+<span class="number">1</span>);</span><br><span class="line">        node.right = addLR(index+<span class="number">1</span>,r,node.right,preorder,inorder,i+index-l+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lookForPre</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span>[] inorder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(j =<span class="number">0</span>;j&lt;inorder.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num == inorder[j])</span><br><span class="line">                <span class="keyword">return</span> j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210409123449155.png" alt="image-20210409123449155"></p><p>时间复杂度 On？  空间复杂度 On</p><h3><span id="2-hashmap的小改进">2. hashmap的小改进</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> HashMap&lt;Integer,Integer&gt; hashMap;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">       hashMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;preorder.length;i++)&#123;</span><br><span class="line">           hashMap.put(inorder[i],i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> addLR(<span class="number">0</span>,preorder.length-<span class="number">1</span>,<span class="keyword">new</span> TreeNode(),preorder,inorder,<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> TreeNode <span class="title">addLR</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,TreeNode node,<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(l&gt;r)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(inorder[l]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> index = lookForPre(preorder[i]);</span><br><span class="line">       <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">           node = <span class="keyword">new</span> TreeNode();</span><br><span class="line">       node.val = inorder[index];</span><br><span class="line">       node.left = addLR(l,index-<span class="number">1</span>,node.left,preorder,inorder,i+<span class="number">1</span>);</span><br><span class="line">       node.right = addLR(index+<span class="number">1</span>,r,node.right,preorder,inorder,i+index-l+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lookForPre</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">return</span> hashMap.get(num);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>hashmap增加了On的占用空间但在get num在中序数组中的位置时非常快….</p><p><strong>看来hashmap在算法题中还是很重要，设计到for循环查找时还是要考虑一下</strong></p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210409124022095.png" alt="image-20210409124022095"></p><h3><span id="3-迭代-栈">3. 迭代 + 栈</span></h3><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210409124118335.png" alt="image-20210409124118335"></p><p>也是类似阿里栈算法的那道题，比较难想…..</p><h2><span id="146-lru缓存">146. LRU缓存</span></h2><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210411092859009.png" alt="image-20210411092859009"></p><h3><span id="思考">思考</span></h3><p>get 和 put的方法说明  </p><h3><span id="1-my-lruhashmap">1. My LruHashMap</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">       Node next,prev;</span><br><span class="line">       <span class="keyword">int</span> key;</span><br><span class="line">       <span class="keyword">int</span> value;</span><br><span class="line">       Node(<span class="keyword">int</span> key,<span class="keyword">int</span> value)&#123;</span><br><span class="line">           <span class="keyword">this</span>.key = key;</span><br><span class="line">           <span class="keyword">this</span>.value = value;</span><br><span class="line">       &#125;</span><br><span class="line">       Node()&#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">private</span> HashMap&lt;Integer,Node&gt; cache;</span><br><span class="line">   <span class="keyword">private</span>  <span class="keyword">int</span> size;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> MaxSize;</span><br><span class="line">   <span class="keyword">private</span> Node head,tail;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">       cache = <span class="keyword">new</span> HashMap();</span><br><span class="line">       size = <span class="number">0</span>;</span><br><span class="line">       MaxSize = capacity;</span><br><span class="line">       head = <span class="keyword">new</span> Node();</span><br><span class="line">       tail = <span class="keyword">new</span> Node();</span><br><span class="line">       tail.prev  = head;</span><br><span class="line">       head.next = tail;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">       Node res = cache.get(key);</span><br><span class="line">       <span class="keyword">if</span>(res == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       addToTail(res);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> res.value;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">           Node node = <span class="keyword">new</span> Node(key,value);</span><br><span class="line">           head = node;</span><br><span class="line">           tail = node;</span><br><span class="line">           size++;</span><br><span class="line">           cache.put(key,node);</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           Node temp = cache.get(key);</span><br><span class="line">           <span class="keyword">if</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">               temp.value = value;</span><br><span class="line">               addToTail(temp);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               Node node = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">               cache.put(key, node);</span><br><span class="line">               addNewToTaile(node);</span><br><span class="line">               size++;</span><br><span class="line">               <span class="keyword">if</span> (size &gt; MaxSize) &#123;</span><br><span class="line">                   removeEldest();</span><br><span class="line">                   size--;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNewToTaile</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">       node.next = <span class="keyword">null</span>;</span><br><span class="line">       node.prev = <span class="keyword">null</span>;</span><br><span class="line">       node.prev = tail;</span><br><span class="line">       tail.next = node;</span><br><span class="line">       tail = node;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addToTail</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(head == tail)&#123;</span><br><span class="line">           <span class="keyword">return</span> ;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(node == tail)&#123;</span><br><span class="line">           <span class="keyword">return</span> ;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(node == head)&#123;</span><br><span class="line">           Node temp;</span><br><span class="line">           temp = node.next;</span><br><span class="line">           head = temp;</span><br><span class="line">           head.prev =<span class="keyword">null</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           Node prev,next;</span><br><span class="line">           prev = node.prev;</span><br><span class="line">           next = node.next;</span><br><span class="line">           <span class="keyword">if</span>(prev == <span class="keyword">null</span>)&#123;</span><br><span class="line">               tail = node.next;</span><br><span class="line">               tail.prev = <span class="keyword">null</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(next == <span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               node.prev.next = next;</span><br><span class="line">               node.next.prev = prev;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       addNewToTaile(node);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeEldest</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Node temp ;</span><br><span class="line">       cache.remove(head.key);</span><br><span class="line">       temp = head.next;</span><br><span class="line">       head = temp;</span><br><span class="line">       head.prev = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">       Node next,prev;</span><br><span class="line">       <span class="keyword">int</span> key;</span><br><span class="line">       <span class="keyword">int</span> value;</span><br><span class="line">       Node(<span class="keyword">int</span> key,<span class="keyword">int</span> value)&#123;</span><br><span class="line">           <span class="keyword">this</span>.key = key;</span><br><span class="line">           <span class="keyword">this</span>.value = value;</span><br><span class="line">       &#125;</span><br><span class="line">       Node()&#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">private</span> HashMap&lt;Integer,Node&gt; cache;</span><br><span class="line">   <span class="keyword">private</span>  <span class="keyword">int</span> size;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> MaxSize;</span><br><span class="line">   <span class="keyword">private</span> Node head,tail;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">       cache = <span class="keyword">new</span> HashMap();</span><br><span class="line">       size = <span class="number">0</span>;</span><br><span class="line">       MaxSize = capacity;</span><br><span class="line">       head = <span class="keyword">new</span> Node();</span><br><span class="line">       tail = <span class="keyword">new</span> Node();</span><br><span class="line">       tail.prev  = head;</span><br><span class="line">       head.next = tail;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">       Node res = cache.get(key);</span><br><span class="line">       <span class="keyword">if</span>(res == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       addToTail(res);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> res.value;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">           Node node = <span class="keyword">new</span> Node(key,value);</span><br><span class="line">           head = node;</span><br><span class="line">           tail = node;</span><br><span class="line">           size++;</span><br><span class="line">           cache.put(key,node);</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           Node temp = cache.get(key);</span><br><span class="line">           <span class="keyword">if</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">               temp.value = value;</span><br><span class="line">               addToTail(temp);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               Node node = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">               cache.put(key, node);</span><br><span class="line">               addNewToTaile(node);</span><br><span class="line">               size++;</span><br><span class="line">               <span class="keyword">if</span> (size &gt; MaxSize) &#123;</span><br><span class="line">                   removeEldest();</span><br><span class="line">                   size--;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNewToTaile</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">       node.next = <span class="keyword">null</span>;</span><br><span class="line">       node.prev = <span class="keyword">null</span>;</span><br><span class="line">       node.prev = tail;</span><br><span class="line">       tail.next = node;</span><br><span class="line">       tail = node;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addToTail</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(head == tail)&#123;</span><br><span class="line">           <span class="keyword">return</span> ;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(node == tail)&#123;</span><br><span class="line">           <span class="keyword">return</span> ;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(node == head)&#123;</span><br><span class="line">           Node temp;</span><br><span class="line">           temp = node.next;</span><br><span class="line">           head = temp;</span><br><span class="line">           head.prev =<span class="keyword">null</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           Node prev,next;</span><br><span class="line">           prev = node.prev;</span><br><span class="line">           next = node.next;</span><br><span class="line">           <span class="keyword">if</span>(prev == <span class="keyword">null</span>)&#123;</span><br><span class="line">               tail = node.next;</span><br><span class="line">               tail.prev = <span class="keyword">null</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(next == <span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               node.prev.next = next;</span><br><span class="line">               node.next.prev = prev;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       addNewToTaile(node);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeEldest</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Node temp ;</span><br><span class="line">       cache.remove(head.key);</span><br><span class="line">       temp = head.next;</span><br><span class="line">       head = temp;</span><br><span class="line">       head.prev = <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据LinkedHashMap 而来 — 内部节点前后指针，并且存储通过 Key,Node&lt;Key,Value&gt;存</p><p>注意<strong>特殊情况判断</strong>（这里一个bug卡了很久很久），注意插入 时容量判断问题</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210411111403208.png" alt="image-20210411111403208"></p><h2><span id="155-最小栈">155. 最小栈</span></h2><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210426175732260.png" alt="image-20210426175732260"></p><h3><span id="思考">思考</span></h3><h3><span id="1-自定义">1. 自定义</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        Node next;</span><br><span class="line">        Node(<span class="keyword">int</span> val)&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Node head;</span><br><span class="line">    Node min;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head = <span class="keyword">null</span>;</span><br><span class="line">        min = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(val);</span><br><span class="line">        node.next = head;</span><br><span class="line">        head = node;</span><br><span class="line">        <span class="keyword">if</span>(min == <span class="keyword">null</span>)&#123;</span><br><span class="line">            min = head;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(min.val &gt; val)&#123;</span><br><span class="line">            min = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.val == min.val)&#123;</span><br><span class="line">            Node node = head.next;</span><br><span class="line">            min = node;</span><br><span class="line">            <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">                min = node.val&gt;min.val ?  min:node;</span><br><span class="line">                node = node.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210426181131420.png" alt="image-20210426181131420"></p><p>思路就是维护一个头指针，和一个最小指针，在pop时进行判断，虽然会有偶尔的On时间复杂度，但整体来说是好的。从Lru中学到</p><h2><span id="263-丑数">263. 丑数</span></h2><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210410093526939.png" alt="image-20210410093526939"></p><h3><span id="思考">思考</span></h3><p>位运算？</p><h3><span id="1-简单递归">1. 简单递归</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>((n &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> isUgly(n/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>((n % <span class="number">3</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> isUgly(n/<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">if</span>((n % <span class="number">5</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> isUgly(n/<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210410094617676.png" alt="image-20210410094617676"></p><p>时间复杂度On</p><h3><span id="2-迭代">2.  迭代</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> bool = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span>( n!=<span class="number">1</span> )&#123;</span><br><span class="line">            <span class="keyword">if</span>((n &amp; <span class="number">1</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                n=n/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((n % <span class="number">3</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                n=n/<span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((n % <span class="number">5</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                n=n/<span class="number">5</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            bool  = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bool;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210410095627239.png" alt="image-20210410095627239"></p><p>还是很有感触，这迭代还是很快 ….. 所以能用迭代还是用迭代把</p><h2><span id="300-最长递增子序列">300. 最长递增子序列</span></h2><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210330164045435.png" alt="image-20210330164045435"></p><h3><span id="思考">思考</span></h3><p>可以不连续，  动态规划 dp   通项式</p><h3><span id="1-自己写的dp">1. 自己写的dp</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line"><span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> inmax = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;i; j++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[j]&lt;nums[i] &amp;&amp; nums[j]&gt;inmax )&#123;</span><br><span class="line">            inmax = nums[j];</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(inmax != Integer.MIN_VALUE&amp;&amp; dp[k] &lt; dp[j]&amp;&amp; nums[j] &lt; nums[i])&#123;</span><br><span class="line">            k = j;</span><br><span class="line">            inmax = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(inmax == Integer.MIN_VALUE) dp[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(nums[k] == nums[i]) dp[i] = dp[k];</span><br><span class="line">    <span class="keyword">else</span> dp[i] = dp[k] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(max&lt;=dp[i])&#123;</span><br><span class="line">        max = dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> max;</span><br></pre></td></tr></table></figure><p>条件判断太多了  辣鸡    </p><p>时间复杂度 O(n<sup>2</sup>)</p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210330173053621.png" alt="image-20210330173053621"></p><h3><span id="2-真正的dp">2. 真正的dp</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxans = Math.max(maxans, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-by-leetcode-soluti/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p> <img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210330173937247.png" alt="image-20210330173937247"></p><h3><span id="贪心二分">贪心+二分</span></h3><p>没看懂 ——- </p><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210330174705748.png" alt="image-20210330174705748"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>, n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] d = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        d[len] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; d[len]) &#123;</span><br><span class="line">                d[++len] = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> l = <span class="number">1</span>, r = len, pos = <span class="number">0</span>; <span class="comment">// 如果找不到说明所有的数都比 nums[i] 大，此时要更新 d[1]，所以这里将 pos 设为 0</span></span><br><span class="line">                <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (d[mid] &lt; nums[i]) &#123;</span><br><span class="line">                        pos = mid;</span><br><span class="line">                        l = mid + <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        r = mid - <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                d[pos + <span class="number">1</span>] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-by-leetcode-soluti/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h2><span id="322-零钱兑换">322. 零钱兑换</span></h2><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210407093902378.png" alt="image-20210407093902378"></p><h3><span id="思考">思考</span></h3><p>没有想dp ….很拉  有想到DFS 不过没有实现</p><h3><span id="1-记忆dfs">1. 记忆DFS</span></h3><h3><span id="2-dp">2. DP</span></h3><h2><span id="lru实现">LRU实现</span></h2><h2><span id="阿里2020-栈求表达式">阿里2020. 栈求表达式</span></h2><p><img src="https://s401177923-1302493622.cos.ap-nanjing.myqcloud.com/mdImages/image-20210330202907036.png" alt="image-20210330202907036"></p><h3><span id></span></h3>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
